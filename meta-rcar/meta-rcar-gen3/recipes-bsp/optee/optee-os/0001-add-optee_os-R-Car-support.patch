From 63fefad34fc0e8ff096be9eb57425313fa962722 Mon Sep 17 00:00:00 2001
From: Takuya Sakata <takuya.sakata.wz@bp.renesas.com>
Date: Fri, 5 Aug 2016 09:28:29 +0900
Subject: [PATCH] add optee_os R-Car support

---
 .gitignore                                         |    4 +
 core/arch/arm/kernel/elf_load.c                    |    7 +
 core/arch/arm/kernel/generic_boot.c                |   21 +-
 core/arch/arm/kernel/generic_core_bootcfg.c        |   81 +
 core/arch/arm/kernel/generic_entry_a64.S           |    4 +-
 core/arch/arm/kernel/sub.mk                        |    3 +-
 core/arch/arm/kernel/tee_time_arm_cntpct.c         |    3 +-
 core/arch/arm/kernel/thread.c                      |    8 +
 core/arch/arm/kernel/thread_a64.S                  |   18 +-
 core/arch/arm/kernel/user_ta.c                     |   34 +-
 core/arch/arm/mm/core_mmu.c                        |    2 +
 core/arch/arm/mm/core_mmu_lpae.c                   |    2 +
 core/arch/arm/plat-rcar/conf.mk                    |   88 +
 .../arm/plat-rcar/drivers/hyper_flash_control.c    |  646 ++
 .../arm/plat-rcar/drivers/hyper_flash_control.h    |   35 +
 core/arch/arm/plat-rcar/drivers/mfis_driver.c      |  262 +
 .../arch/arm/plat-rcar/drivers/qspi_flash_common.c |  346 ++
 .../arch/arm/plat-rcar/drivers/qspi_flash_common.h |   37 +
 core/arch/arm/plat-rcar/drivers/qspi_hyper_flash.c |  251 +
 .../plat-rcar/drivers/qspi_hyper_flash_common.c    |  126 +
 .../plat-rcar/drivers/qspi_hyper_flash_common.h    |  187 +
 .../arm/plat-rcar/drivers/qspi_onboard_control.c   |  555 ++
 .../arm/plat-rcar/drivers/qspi_onboard_control.h   |   34 +
 .../arch/arm/plat-rcar/drivers/qspi_quad_control.c |  540 ++
 .../arch/arm/plat-rcar/drivers/qspi_quad_control.h |   34 +
 core/arch/arm/plat-rcar/drivers/sub.mk             |    9 +
 core/arch/arm/plat-rcar/drivers/swdt_driver.c      |  222 +
 .../arm/plat-rcar/include/drivers/mfis_driver.h    |   50 +
 .../plat-rcar/include/drivers/qspi_hyper_flash.h   |   61 +
 .../arm/plat-rcar/include/drivers/swdt_driver.h    |   49 +
 core/arch/arm/plat-rcar/kern.ld.S                  |  308 +
 core/arch/arm/plat-rcar/link.mk                    |  195 +
 core/arch/arm/plat-rcar/main.c                     |  156 +
 core/arch/arm/plat-rcar/platform_config.h          |  252 +
 core/arch/arm/plat-rcar/rcar_call_maskrom_a32.S    |   39 +
 core/arch/arm/plat-rcar/rcar_call_maskrom_a64.S    |   73 +
 core/arch/arm/plat-rcar/rcar_common.h              |  104 +
 core/arch/arm/plat-rcar/rcar_ddr_training.c        |  100 +
 core/arch/arm/plat-rcar/rcar_ddr_training.h        |   35 +
 core/arch/arm/plat-rcar/rcar_interruptflags_a32.S  |   49 +
 core/arch/arm/plat-rcar/rcar_interruptflags_a64.S  |   49 +
 core/arch/arm/plat-rcar/rcar_lock.c                |   53 +
 core/arch/arm/plat-rcar/rcar_log_func.c            |  169 +
 core/arch/arm/plat-rcar/rcar_log_func.h            |  108 +
 core/arch/arm/plat-rcar/rcar_maskrom.c             |  101 +
 core/arch/arm/plat-rcar/rcar_maskrom.h             |   55 +
 core/arch/arm/plat-rcar/rcar_ta_auth.c             |  247 +
 core/arch/arm/plat-rcar/rcar_ta_auth.h             |   38 +
 core/arch/arm/plat-rcar/rcar_version.h             |   37 +
 core/arch/arm/plat-rcar/sub.mk                     |   19 +
 core/arch/arm/plat-rcar/tee/sub.mk                 |    3 +
 core/arch/arm/plat-rcar/tee/tee_standalone_fs.c    | 2538 ++++++++
 core/arch/arm/plat-rcar/tee/tee_standalone_fs.h    |  191 +
 .../plat-rcar/tee/tee_standalone_fs_key_manager.c  |  434 ++
 .../plat-rcar/tee/tee_standalone_fs_key_manager.h  |   68 +
 core/arch/arm/plat-rcar/tee_common_otp.c           |  142 +
 core/arch/arm/plat-rcar/trace_ext.c                |  121 +
 core/arch/arm/tee/arch_svc.c                       |    6 +
 core/core.mk                                       |   19 +
 core/drivers/gic.c                                 |    2 +-
 core/include/drivers/gic.h                         |    3 +
 core/include/kernel/tee_time.h                     |    2 +
 core/include/tee/tee_cryp_provider.h               |   19 +
 core/include/tee/tee_fs.h                          |    5 +
 core/include/tee/tee_fs_key_manager.h              |    4 +
 core/include/tee/tee_svc_cryp.h                    |    3 +
 core/lib/libcryptoengine/libcc.mk                  |   35 +
 core/lib/libcryptoengine/sub.mk                    |  115 +
 core/lib/libcryptoengine/tee_pka_provider.c        |  276 +
 core/lib/libcryptoengine/tee_pka_provider.h        |   42 +
 core/lib/libcryptoengine/tee_provider_common.c     |  518 ++
 core/lib/libcryptoengine/tee_provider_common.h     |  135 +
 core/lib/libcryptoengine/tee_ss_provider.c         | 6275 ++++++++++++++++++++
 core/tee/sub.mk                                    |    2 +-
 core/tee/tee_fs_key_manager.c                      |   24 +-
 core/tee/tee_ree_fs.c                              |    4 +-
 core/tee/tee_rpmb_fs.c                             |  120 +-
 core/tee/tee_svc_cryp.c                            |   17 +-
 core/tee/tee_svc_storage.c                         |   10 +-
 lib/libutee/arch/arm/utee_syscalls_asm.S           |    2 +
 lib/libutee/include/tee_api.h                      |    3 +
 lib/libutee/include/tee_api_defines_extensions.h   |    2 +
 lib/libutee/include/tee_syscall_numbers.h          |    3 +-
 lib/libutee/include/utee_syscalls.h                |    3 +
 lib/libutee/tee_api.c                              |    7 +
 lib/libutee/tee_api_objects.c                      |   13 -
 mk/config.mk                                       |    2 +-
 87 files changed, 16955 insertions(+), 119 deletions(-)
 create mode 100644 core/arch/arm/plat-rcar/conf.mk
 create mode 100644 core/arch/arm/plat-rcar/drivers/hyper_flash_control.c
 create mode 100644 core/arch/arm/plat-rcar/drivers/hyper_flash_control.h
 create mode 100644 core/arch/arm/plat-rcar/drivers/mfis_driver.c
 create mode 100644 core/arch/arm/plat-rcar/drivers/qspi_flash_common.c
 create mode 100644 core/arch/arm/plat-rcar/drivers/qspi_flash_common.h
 create mode 100644 core/arch/arm/plat-rcar/drivers/qspi_hyper_flash.c
 create mode 100644 core/arch/arm/plat-rcar/drivers/qspi_hyper_flash_common.c
 create mode 100644 core/arch/arm/plat-rcar/drivers/qspi_hyper_flash_common.h
 create mode 100644 core/arch/arm/plat-rcar/drivers/qspi_onboard_control.c
 create mode 100644 core/arch/arm/plat-rcar/drivers/qspi_onboard_control.h
 create mode 100644 core/arch/arm/plat-rcar/drivers/qspi_quad_control.c
 create mode 100644 core/arch/arm/plat-rcar/drivers/qspi_quad_control.h
 create mode 100644 core/arch/arm/plat-rcar/drivers/sub.mk
 create mode 100644 core/arch/arm/plat-rcar/drivers/swdt_driver.c
 create mode 100644 core/arch/arm/plat-rcar/include/drivers/mfis_driver.h
 create mode 100644 core/arch/arm/plat-rcar/include/drivers/qspi_hyper_flash.h
 create mode 100644 core/arch/arm/plat-rcar/include/drivers/swdt_driver.h
 create mode 100644 core/arch/arm/plat-rcar/kern.ld.S
 create mode 100644 core/arch/arm/plat-rcar/link.mk
 create mode 100644 core/arch/arm/plat-rcar/main.c
 create mode 100644 core/arch/arm/plat-rcar/platform_config.h
 create mode 100644 core/arch/arm/plat-rcar/rcar_call_maskrom_a32.S
 create mode 100644 core/arch/arm/plat-rcar/rcar_call_maskrom_a64.S
 create mode 100644 core/arch/arm/plat-rcar/rcar_common.h
 create mode 100644 core/arch/arm/plat-rcar/rcar_ddr_training.c
 create mode 100644 core/arch/arm/plat-rcar/rcar_ddr_training.h
 create mode 100644 core/arch/arm/plat-rcar/rcar_interruptflags_a32.S
 create mode 100644 core/arch/arm/plat-rcar/rcar_interruptflags_a64.S
 create mode 100644 core/arch/arm/plat-rcar/rcar_lock.c
 create mode 100644 core/arch/arm/plat-rcar/rcar_log_func.c
 create mode 100644 core/arch/arm/plat-rcar/rcar_log_func.h
 create mode 100644 core/arch/arm/plat-rcar/rcar_maskrom.c
 create mode 100644 core/arch/arm/plat-rcar/rcar_maskrom.h
 create mode 100644 core/arch/arm/plat-rcar/rcar_ta_auth.c
 create mode 100644 core/arch/arm/plat-rcar/rcar_ta_auth.h
 create mode 100644 core/arch/arm/plat-rcar/rcar_version.h
 create mode 100644 core/arch/arm/plat-rcar/sub.mk
 create mode 100644 core/arch/arm/plat-rcar/tee/sub.mk
 create mode 100644 core/arch/arm/plat-rcar/tee/tee_standalone_fs.c
 create mode 100644 core/arch/arm/plat-rcar/tee/tee_standalone_fs.h
 create mode 100644 core/arch/arm/plat-rcar/tee/tee_standalone_fs_key_manager.c
 create mode 100644 core/arch/arm/plat-rcar/tee/tee_standalone_fs_key_manager.h
 create mode 100644 core/arch/arm/plat-rcar/tee_common_otp.c
 create mode 100644 core/arch/arm/plat-rcar/trace_ext.c
 create mode 100644 core/lib/libcryptoengine/libcc.mk
 create mode 100644 core/lib/libcryptoengine/sub.mk
 create mode 100644 core/lib/libcryptoengine/tee_pka_provider.c
 create mode 100644 core/lib/libcryptoengine/tee_pka_provider.h
 create mode 100644 core/lib/libcryptoengine/tee_provider_common.c
 create mode 100644 core/lib/libcryptoengine/tee_provider_common.h
 create mode 100644 core/lib/libcryptoengine/tee_ss_provider.c

diff --git a/.gitignore b/.gitignore
index 855c9f8..32d3440 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,7 @@ cscope.*
 out
 .cproject
 .project
+/core/lib/libcryptoengine/libcrypto_engine_pka.a
+/core/lib/libcryptoengine/libcrypto_engine_secure.a
+/core/lib/libcryptoengine/include_secure
+/core/lib/libcryptoengine/include_pka
diff --git a/core/arch/arm/kernel/elf_load.c b/core/arch/arm/kernel/elf_load.c
index 420ba59..94d4000 100644
--- a/core/arch/arm/kernel/elf_load.c
+++ b/core/arch/arm/kernel/elf_load.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2015, Linaro Limited
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -142,11 +143,15 @@ static TEE_Result advance_to(struct elf_load_state *state, size_t offs)
 	if (offs > state->nwdata_len)
 		return TEE_ERROR_SECURITY;
 
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	res = crypto_ops.hash.update(state->hash_ctx, state->hash_algo,
 			state->nwdata + state->next_offs,
 			offs - state->next_offs);
 	if (res != TEE_SUCCESS)
 		return res;
+#else
+	res = TEE_SUCCESS;
+#endif
 	state->next_offs = offs;
 	return res;
 }
@@ -169,10 +174,12 @@ static TEE_Result copy_to(struct elf_load_state *state,
 		return TEE_ERROR_SECURITY;
 
 	memcpy((uint8_t *)dst + dst_offs, state->nwdata + offs, len);
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	res = crypto_ops.hash.update(state->hash_ctx, state->hash_algo,
 				      (uint8_t *)dst + dst_offs, len);
 	if (res != TEE_SUCCESS)
 		return res;
+#endif
 	state->next_offs = offs + len;
 	return res;
 }
diff --git a/core/arch/arm/kernel/generic_boot.c b/core/arch/arm/kernel/generic_boot.c
index 03c04f6..6ebb964 100644
--- a/core/arch/arm/kernel/generic_boot.c
+++ b/core/arch/arm/kernel/generic_boot.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2015, Linaro Limited
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -54,6 +55,13 @@
 #include <kernel/vfp.h>
 #endif
 
+#ifdef PLATFORM_RCAR
+#include "rcar_common.h"
+#include "rcar_log_func.h"
+#include "rcar_ddr_training.h"
+#include "rcar_maskrom.h"
+#endif
+
 #define PADDR_INVALID		0xffffffff
 
 #ifdef CFG_BOOT_SYNC_CPU
@@ -325,7 +333,10 @@ static void init_primary_helper(uint32_t pageable_part, uint32_t nsec_entry)
 	init_vfp_sec();
 
 	init_runtime(pageable_part);
-
+#ifdef PLATFORM_RCAR
+	/* Log buffer clear */
+	log_buf_init();
+#endif
 	IMSG("Initializing (%s)\n", core_v_str);
 
 	thread_init_primary(generic_boot_get_handlers());
@@ -338,6 +349,14 @@ static void init_primary_helper(uint32_t pageable_part, uint32_t nsec_entry)
 
 	if (init_teecore() != TEE_SUCCESS)
 		panic();
+#ifdef PLATFORM_RCAR
+	/* LSI Product setup */
+	product_setup();
+
+	/* Initialize DDR training */
+	ddr_training_timer_init();
+	ddr_training_timer_start();
+#endif
 	DMSG("Primary CPU switching to normal world boot\n");
 }
 
diff --git a/core/arch/arm/kernel/generic_core_bootcfg.c b/core/arch/arm/kernel/generic_core_bootcfg.c
index 956579b..408b1d6 100644
--- a/core/arch/arm/kernel/generic_core_bootcfg.c
+++ b/core/arch/arm/kernel/generic_core_bootcfg.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2014, STMicroelectronics International N.V.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -194,6 +195,86 @@ static struct map_area bootcfg_memory_map[] = {
 	 .device = true, .secure = true, .rw = true,
 	 },
 #endif
+#ifdef MEMORY1_BASE
+	{
+	 .type = MEMORY1_TYPE,
+	 .pa = MEMORY1_BASE, .size = MEMORY1_SIZE,
+	 .secure = MEMORY1_SECURE, .cached = MEMORY1_CACHED,
+	 .device = MEMORY1_DEVICE, .rw = MEMORY1_RW, .exec = MEMORY1_EXEC,
+	 },
+#endif
+#ifdef MEMORY2_BASE
+	{
+	 .type = MEMORY2_TYPE,
+	 .pa = MEMORY2_BASE, .size = MEMORY2_SIZE,
+	 .secure = MEMORY2_SECURE, .cached = MEMORY2_CACHED,
+	 .device = MEMORY2_DEVICE, .rw = MEMORY2_RW, .exec = MEMORY2_EXEC,
+	 },
+#endif
+#ifdef MEMORY3_BASE
+	{
+	 .type = MEMORY3_TYPE,
+	 .pa = MEMORY3_BASE, .size = MEMORY3_SIZE,
+	 .secure = MEMORY3_SECURE, .cached = MEMORY3_CACHED,
+	 .device = MEMORY3_DEVICE, .rw = MEMORY3_RW, .exec = MEMORY3_EXEC,
+	 },
+#endif
+#ifdef MEMORY4_BASE
+	{
+	 .type = MEMORY4_TYPE,
+	 .pa = MEMORY4_BASE, .size = MEMORY4_SIZE,
+	 .secure = MEMORY4_SECURE, .cached = MEMORY4_CACHED,
+	 .device = MEMORY4_DEVICE, .rw = MEMORY4_RW, .exec = MEMORY4_EXEC,
+	 },
+#endif
+#ifdef MEMORY5_BASE
+	{
+	 .type = MEMORY5_TYPE,
+	 .pa = MEMORY5_BASE, .size = MEMORY5_SIZE,
+	 .secure = MEMORY5_SECURE, .cached = MEMORY5_CACHED,
+	 .device = MEMORY5_DEVICE, .rw = MEMORY5_RW, .exec = MEMORY5_EXEC,
+	 },
+#endif
+#ifdef MEMORY6_BASE
+	{
+	 .type = MEMORY6_TYPE,
+	 .pa = MEMORY6_BASE, .size = MEMORY6_SIZE,
+	 .secure = MEMORY6_SECURE, .cached = MEMORY6_CACHED,
+	 .device = MEMORY6_DEVICE, .rw = MEMORY6_RW, .exec = MEMORY6_EXEC,
+	 },
+#endif
+#ifdef MEMORY7_BASE
+	{
+	 .type = MEMORY7_TYPE,
+	 .pa = MEMORY7_BASE, .size = MEMORY7_SIZE,
+	 .secure = MEMORY7_SECURE, .cached = MEMORY7_CACHED,
+	 .device = MEMORY7_DEVICE, .rw = MEMORY7_RW, .exec = MEMORY7_EXEC,
+	 },
+#endif
+#ifdef MEMORY8_BASE
+	{
+	 .type = MEMORY8_TYPE,
+	 .pa = MEMORY8_BASE, .size = MEMORY8_SIZE,
+	 .secure = MEMORY8_SECURE, .cached = MEMORY8_CACHED,
+	 .device = MEMORY8_DEVICE, .rw = MEMORY8_RW, .exec = MEMORY8_EXEC,
+	 },
+#endif
+#ifdef MEMORY9_BASE
+	{
+	 .type = MEMORY9_TYPE,
+	 .pa = MEMORY9_BASE, .size = MEMORY9_SIZE,
+	 .secure = MEMORY9_SECURE, .cached = MEMORY9_CACHED,
+	 .device = MEMORY9_DEVICE, .rw = MEMORY9_RW, .exec = MEMORY9_EXEC,
+	 },
+#endif
+#ifdef MEMORY10_BASE
+	{
+	 .type = MEMORY10_TYPE,
+	 .pa = MEMORY10_BASE, .size = MEMORY10_SIZE,
+	 .secure = MEMORY10_SECURE, .cached = MEMORY10_CACHED,
+	 .device = MEMORY10_DEVICE, .rw = MEMORY10_RW, .exec = MEMORY10_EXEC,
+	 },
+#endif
 	{.type = MEM_AREA_NOTYPE}
 };
 
diff --git a/core/arch/arm/kernel/generic_entry_a64.S b/core/arch/arm/kernel/generic_entry_a64.S
index 94fe69e..79a9b77 100644
--- a/core/arch/arm/kernel/generic_entry_a64.S
+++ b/core/arch/arm/kernel/generic_entry_a64.S
@@ -97,7 +97,7 @@ copy_init:
 #ifdef CFG_WITH_PAGER
 	adr	x1, __init_end
 #else
-	adr	x1, _end
+	ldr	x1, =_end
 #endif
 	sub	x1, x1, x0
 	bl	inv_dcache_range
@@ -125,7 +125,7 @@ copy_init:
 #ifdef CFG_WITH_PAGER
 	adr	x1, __init_end
 #else
-	adr	x1, _end
+	ldr	x1, =_end
 #endif
 	sub	x1, x1, x0
 	bl	flush_dcache_range
diff --git a/core/arch/arm/kernel/sub.mk b/core/arch/arm/kernel/sub.mk
index 0648070..b1feb8e 100644
--- a/core/arch/arm/kernel/sub.mk
+++ b/core/arch/arm/kernel/sub.mk
@@ -25,7 +25,8 @@ ifeq ($(CFG_WITH_VFP),y)
 srcs-$(CFG_ARM32_core) += vfp_a32.S
 srcs-$(CFG_ARM64_core) += vfp_a64.S
 endif
-srcs-y += trace_ext.c
+WITH_TRACE_EXT ?= y
+srcs-$(WITH_TRACE_EXT) += trace_ext.c
 srcs-$(CFG_ARM32_core) += misc_a32.S
 srcs-$(CFG_ARM64_core) += misc_a64.S
 srcs-y += mutex.c
diff --git a/core/arch/arm/kernel/tee_time_arm_cntpct.c b/core/arch/arm/kernel/tee_time_arm_cntpct.c
index c985a7a..ed81b40 100644
--- a/core/arch/arm/kernel/tee_time_arm_cntpct.c
+++ b/core/arch/arm/kernel/tee_time_arm_cntpct.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2014, 2015 Linaro Limited
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,7 +38,7 @@
 #include <mpa.h>
 #include <arm.h>
 
-static TEE_Result arm_cntpct_get_sys_time(TEE_Time *time)
+TEE_Result arm_cntpct_get_sys_time(TEE_Time *time)
 {
 	uint64_t cntpct = read_cntpct();
 	uint32_t cntfrq = read_cntfrq();
diff --git a/core/arch/arm/kernel/thread.c b/core/arch/arm/kernel/thread.c
index 3ed499c..671e658 100644
--- a/core/arch/arm/kernel/thread.c
+++ b/core/arch/arm/kernel/thread.c
@@ -49,7 +49,11 @@
 #include <assert.h>
 
 #ifdef ARM32
+#ifndef ENABLE_CRYPTOENGINE
 #define STACK_TMP_SIZE		1024
+#else
+#define STACK_TMP_SIZE		1024*4
+#endif
 #define STACK_THREAD_SIZE	8192
 
 #if TRACE_LEVEL > 0
@@ -61,7 +65,11 @@
 #endif /*ARM32*/
 
 #ifdef ARM64
+#ifndef ENABLE_CRYPTOENGINE
 #define STACK_TMP_SIZE		2048
+#else
+#define STACK_TMP_SIZE		2048*4
+#endif
 #define STACK_THREAD_SIZE	8192
 
 #if TRACE_LEVEL > 0
diff --git a/core/arch/arm/kernel/thread_a64.S b/core/arch/arm/kernel/thread_a64.S
index 32106be..1e75ac9 100644
--- a/core/arch/arm/kernel/thread_a64.S
+++ b/core/arch/arm/kernel/thread_a64.S
@@ -38,7 +38,7 @@
 	.macro get_thread_ctx core_local, res, tmp0, tmp1
 		ldr	w\tmp0, [\core_local, \
 				#THREAD_CORE_LOCAL_CURR_THREAD]
-		adr	x\res, threads
+		ldr	x\res, =threads
 		mov	x\tmp1, #THREAD_CTX_SIZE
 		madd	x\res, x\tmp0, x\tmp1, x\res
 	.endm
@@ -77,7 +77,7 @@ END_FUNC vector_fast_smc_entry
 LOCAL_FUNC vector_fiq_entry , :
 	/* Secure Monitor received a FIQ and passed control to us. */
 	bl	thread_check_canaries
-	adr	x16, thread_fiq_handler_ptr
+	ldr	x16, =thread_fiq_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	ldr	x0, =TEESMC_OPTEED_RETURN_FIQ_DONE
@@ -86,7 +86,7 @@ LOCAL_FUNC vector_fiq_entry , :
 END_FUNC vector_fiq_entry
 
 LOCAL_FUNC vector_cpu_on_entry , :
-	adr	x16, thread_cpu_on_handler_ptr
+	ldr	x16, =thread_cpu_on_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -96,7 +96,7 @@ LOCAL_FUNC vector_cpu_on_entry , :
 END_FUNC vector_cpu_on_entry
 
 LOCAL_FUNC vector_cpu_off_entry , :
-	adr	x16, thread_cpu_off_handler_ptr
+	ldr	x16, =thread_cpu_off_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -106,7 +106,7 @@ LOCAL_FUNC vector_cpu_off_entry , :
 END_FUNC vector_cpu_off_entry
 
 LOCAL_FUNC vector_cpu_suspend_entry , :
-	adr	x16, thread_cpu_suspend_handler_ptr
+	ldr	x16, =thread_cpu_suspend_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -116,7 +116,7 @@ LOCAL_FUNC vector_cpu_suspend_entry , :
 END_FUNC vector_cpu_suspend_entry
 
 LOCAL_FUNC vector_cpu_resume_entry , :
-	adr	x16, thread_cpu_resume_handler_ptr
+	ldr	x16, =thread_cpu_resume_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -126,7 +126,7 @@ LOCAL_FUNC vector_cpu_resume_entry , :
 END_FUNC vector_cpu_resume_entry
 
 LOCAL_FUNC vector_system_off_entry , :
-	adr	x16, thread_system_off_handler_ptr
+	ldr	x16, =thread_system_off_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -136,7 +136,7 @@ LOCAL_FUNC vector_system_off_entry , :
 END_FUNC vector_system_off_entry
 
 LOCAL_FUNC vector_system_reset_entry , :
-	adr	x16, thread_system_reset_handler_ptr
+	ldr	x16, =thread_system_reset_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 	mov	x1, x0
@@ -786,7 +786,7 @@ LOCAL_FUNC elx_fiq , :
 	stp	x30, x2, [sp, #ELX_FIQ_REC_LR]
 
 	bl	thread_check_canaries
-	adr	x16, thread_fiq_handler_ptr
+	ldr	x16, =thread_fiq_handler_ptr
 	ldr	x16, [x16]
 	blr	x16
 
diff --git a/core/arch/arm/kernel/user_ta.c b/core/arch/arm/kernel/user_ta.c
index 4993b09..76334d7 100644
--- a/core/arch/arm/kernel/user_ta.c
+++ b/core/arch/arm/kernel/user_ta.c
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2014, STMicroelectronics International N.V.
  * Copyright (c) 2015, Linaro Limited
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -52,8 +53,13 @@
 #include "elf_load.h"
 #include "elf_common.h"
 
+#ifdef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
+#include "rcar_ta_auth.h"
+#endif
+
 #define STACK_ALIGNMENT   (sizeof(long) * 2)
 
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 static TEE_Result load_header(const struct shdr *signed_ta,
 		struct shdr **sec_shdr)
 {
@@ -74,13 +80,16 @@ static TEE_Result load_header(const struct shdr *signed_ta,
 
 	return TEE_SUCCESS;
 }
+#endif
 
 static TEE_Result check_shdr(struct shdr *shdr)
 {
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	struct rsa_public_key key;
 	TEE_Result res;
 	uint32_t e = TEE_U32_TO_BIG_ENDIAN(ta_pub_key_exponent);
 	size_t hash_size;
+#endif
 
 	if (shdr->magic != SHDR_MAGIC || shdr->img_type != SHDR_TA)
 		return TEE_ERROR_SECURITY;
@@ -88,6 +97,7 @@ static TEE_Result check_shdr(struct shdr *shdr)
 	if (TEE_ALG_GET_MAIN_ALG(shdr->algo) != TEE_MAIN_ALGO_RSA)
 		return TEE_ERROR_SECURITY;
 
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	res = tee_hash_get_digest_size(TEE_DIGEST_HASH_TO_ALGO(shdr->algo),
 				       &hash_size);
 	if (res != TEE_SUCCESS)
@@ -120,6 +130,7 @@ out:
 	crypto_ops.acipher.free_rsa_public_key(&key);
 	if (res != TEE_SUCCESS)
 		return TEE_ERROR_SECURITY;
+#endif
 	return TEE_SUCCESS;
 }
 
@@ -182,7 +193,9 @@ static TEE_Result load_elf(struct user_ta_ctx *utc, struct shdr *shdr,
 			const struct shdr *nmem_shdr)
 {
 	TEE_Result res;
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	size_t hash_ctx_size;
+#endif
 	void *hash_ctx = NULL;
 	uint32_t hash_algo;
 	uint8_t *nwdata = (uint8_t *)nmem_shdr + SHDR_GET_SIZE(shdr);
@@ -193,6 +206,7 @@ static TEE_Result load_elf(struct user_ta_ctx *utc, struct shdr *shdr,
 	void *p;
 	size_t vasize;
 
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	if (!tee_vbuf_is_non_sec(nwdata, nwdata_len))
 		return TEE_ERROR_SECURITY;
 
@@ -217,6 +231,9 @@ static TEE_Result load_elf(struct user_ta_ctx *utc, struct shdr *shdr,
 				     (uint8_t *)shdr, sizeof(struct shdr));
 	if (res != TEE_SUCCESS)
 		goto out;
+#else
+	hash_algo = TEE_ALG_SHA256;	/* dummy data are set */
+#endif
 
 	res = elf_load_init(hash_ctx, hash_algo, nwdata, nwdata_len,
 			    &elf_state);
@@ -272,6 +289,7 @@ static TEE_Result load_elf(struct user_ta_ctx *utc, struct shdr *shdr,
 	if (res != TEE_SUCCESS)
 		goto out;
 
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	digest = malloc(shdr->hash_size);
 	if (!digest) {
 		res = TEE_ERROR_OUT_OF_MEMORY;
@@ -287,7 +305,7 @@ static TEE_Result load_elf(struct user_ta_ctx *utc, struct shdr *shdr,
 		res = TEE_ERROR_SECURITY;
 		goto out;
 	}
-
+#endif
 	/*
 	 * Replace the init attributes with attributes used when the TA is
 	 * running.
@@ -326,10 +344,17 @@ static TEE_Result ta_load(const TEE_UUID *uuid, const struct shdr *signed_ta,
 	struct shdr *sec_shdr = NULL;
 	struct ta_head *ta_head;
 
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	res = load_header(signed_ta, &sec_shdr);
 	if (res != TEE_SUCCESS)
 		goto error_return;
-
+#else
+	res = rcar_auth_ta_certificate(signed_ta, &sec_shdr);
+	if (res != TEE_SUCCESS) {
+		goto error_return;
+	}
+	signed_ta = (const struct shdr *)sec_shdr;
+#endif
 	res = check_shdr(sec_shdr);
 	if (res != TEE_SUCCESS)
 		goto error_return;
@@ -396,12 +421,15 @@ static TEE_Result ta_load(const TEE_UUID *uuid, const struct shdr *signed_ta,
 
 	tee_mmu_set_ctx(NULL);
 	/* end thread protection (multi-threaded) */
-
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	free(sec_shdr);
+#endif
 	return TEE_SUCCESS;
 
 error_return:
+#ifndef RCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
 	free(sec_shdr);
+#endif
 	tee_mmu_set_ctx(NULL);
 	if (utc) {
 		tee_mmu_final(utc);
diff --git a/core/arch/arm/mm/core_mmu.c b/core/arch/arm/mm/core_mmu.c
index 906a8a8..291e162 100644
--- a/core/arch/arm/mm/core_mmu.c
+++ b/core/arch/arm/mm/core_mmu.c
@@ -54,7 +54,9 @@
 #include <kernel/thread.h>
 #include <arm.h>
 
+#ifndef MAX_MMAP_REGIONS
 #define MAX_MMAP_REGIONS	10
+#endif
 
 /* Default NSec shared memory allocated from NSec world */
 unsigned long default_nsec_shm_size __data; /* XXX __data is a workaround */
diff --git a/core/arch/arm/mm/core_mmu_lpae.c b/core/arch/arm/mm/core_mmu_lpae.c
index 7964ab1..cffcbc2 100644
--- a/core/arch/arm/mm/core_mmu_lpae.c
+++ b/core/arch/arm/mm/core_mmu_lpae.c
@@ -166,7 +166,9 @@
 
 
 #define ADDR_SPACE_SIZE		(1ull << 32)
+#ifndef MAX_MMAP_REGIONS
 #define MAX_MMAP_REGIONS	16
+#endif
 #define NUM_L1_ENTRIES		(ADDR_SPACE_SIZE >> L1_XLAT_ADDRESS_SHIFT)
 
 #ifndef MAX_XLAT_TABLES
diff --git a/core/arch/arm/plat-rcar/conf.mk b/core/arch/arm/plat-rcar/conf.mk
new file mode 100644
index 0000000..f6f484f
--- /dev/null
+++ b/core/arch/arm/plat-rcar/conf.mk
@@ -0,0 +1,88 @@
+PLATFORM_FLAVOR ?= rcar
+PLATFORM_FLAVOR_$(PLATFORM_FLAVOR) := y
+
+# 32-bit flags
+arm32-platform-cpuarch		:= cortex-a15
+arm32-platform-cflags		+= -mcpu=$(arm32-platform-cpuarch)
+arm32-platform-aflags		+= -mcpu=$(arm32-platform-cpuarch)
+core_arm32-platform-aflags	+= -mfpu=neon
+
+# ARM debugger needs this
+platform-cflags-debug-info = -gdwarf-2
+platform-aflags-debug-info = -gdwarf-2
+
+$(call force,CFG_WITH_ARM_TRUSTED_FW,y)
+$(call force,CFG_GENERIC_BOOT,y)
+$(call force,CFG_GIC,y)
+$(call force,CFG_HWSUPP_MEM_PERM_PXN,y)
+$(call force,CFG_PM_STUBS,y)
+$(call force,CFG_SECURE_TIME_SOURCE_CNTPCT,y)
+$(call force,CFG_SWDT,y)
+$(call force,CFG_MFIS,y)
+
+ifeq ($(CFG_ARM64_core),y)
+$(call force,CFG_WITH_LPAE,y)
+ta-targets += ta_arm64
+ifdef CROSS_COMPILE32
+ta-targets += ta_arm32
+endif
+else
+$(call force,CFG_ARM32_core,y)
+ta-targets = ta_arm32
+endif
+
+CFG_TEE_CORE_EMBED_INTERNAL_TESTS ?= y
+CFG_TEE_FS_KEY_MANAGER_TEST ?= y
+CFG_WITH_STACK_CANARIES ?= y
+CFG_WITH_STATS ?= y
+
+ifeq ($(CFG_CRYPT_HW_CRYPTOENGINE),y)
+CFG_OTP_SUPPORT ?= y
+CFG_DYNAMIC_TA_AUTH_BY_HWENGINE ?= y
+core-platform-cflags += -DCFG_OTP_SUPPORT
+core-platform-cflags += -Icore/lib
+else
+CFG_OTP_SUPPORT := n
+endif
+
+CFG_DYNAMIC_TA_AUTH_BY_HWENGINE ?= n
+ifeq ($(CFG_DYNAMIC_TA_AUTH_BY_HWENGINE),y)
+core-platform-cflags += -DRCAR_DYNAMIC_TA_AUTH_BY_HWENGINE
+endif
+
+# default setting for Secure Storage
+CFG_REE_FS ?= n
+CFG_STANDALONE_FS ?= y
+STANDALONE_FS_SECTOR_ADDR ?= 0x300000
+STANDALONE_FS_SECTOR_NUM ?= 4
+# ---
+
+ifeq ($(CFG_STANDALONE_FS),y)
+core-platform-cflags += -DSTANDALONE_FS_SECTOR_ADDR=$(STANDALONE_FS_SECTOR_ADDR)
+core-platform-cflags += -DSTANDALONE_FS_SECTOR_NUM=$(STANDALONE_FS_SECTOR_NUM)
+CFG_HYPER_FLASH := y
+endif
+
+core-platform-cflags += -DPLATFORM_RCAR
+
+# Not covered by compile - /core/arch/arm/kernel/trace_ext.c
+WITH_TRACE_EXT := n
+
+# Compiler switch - Debug log(Linux terminal log)
+RCAR_DEBUG_LOG ?= 0
+ifneq ($(RCAR_DEBUG_LOG),0)
+core-platform-cflags += -DRCAR_DEBUG_LOG
+endif
+
+RCAR_INTCTX_LOG ?= 0
+ifneq ($(RCAR_INTCTX_LOG),0)
+core-platform-cflags += -DRCAR_INTCTX_LOG
+endif
+
+VERSION_OF_RENESAS ?= $(shell awk '/VERSION_OF_RENESAS/{ \
+	$$a=substr($$3,2); sub(/.$$/,"",$$a); print $$a}' \
+	< core/arch/$(ARCH)/plat-$(PLATFORM)/rcar_version.h 2> /dev/null)
+TEE_IMPL_VERSION ?= R-Car Rev.$(VERSION_OF_RENESAS)
+CFG_TEE_MANUFACTURER ?= LINARO & Renesas Electronics
+CFG_TEE_FW_IMPL_VERSION ?= $(TEE_IMPL_VERSION)
+CFG_TEE_FW_MANUFACTURER ?= ARM & Renesas Electronics
diff --git a/core/arch/arm/plat-rcar/drivers/hyper_flash_control.c b/core/arch/arm/plat-rcar/drivers/hyper_flash_control.c
new file mode 100644
index 0000000..4a81ae3
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/hyper_flash_control.c
@@ -0,0 +1,646 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <trace.h>
+#include <drivers/qspi_hyper_flash.h>
+#include "qspi_hyper_flash_common.h"
+#include "hyper_flash_control.h"
+
+static uint32_t hyper_flash_erase_sector(uint32_t sector_addr);
+static uint32_t hyper_flash_set_ext_addr_read_mode(uint32_t read_ext_top_addr,
+			uint32_t r_flash_addr, uint8_t *buf, size_t rsize);
+static uint32_t hyper_flash_write_main(uint32_t buf_addr,
+					uint32_t flash_addr, uint32_t wsize);
+static void hyper_flash_set_control_ops(struct flash_control_operations *ops);
+static uint32_t hyper_flash_set_command(uint32_t manual_set_addr,
+							uint32_t command);
+static void hyper_flash_set_disable_write_protect(void);
+static uint32_t hyper_flash_reset_to_read_mode(void);
+static uint32_t hyper_flash_read_register_data(uint32_t manual_set_addr,
+				uint32_t *read_data, uint32_t byte_count);
+static uint32_t hyper_flash_read_device_id(uint32_t *read_device_id);
+static uint32_t hyper_flash_request_write_buffer(uint32_t flash_addr,
+						uint32_t write_data_addr);
+static uint32_t hyper_flash_write_buffer_control(uint32_t flash_addr,
+						uint32_t write_data_addr);
+static uint32_t hyper_flash_write_buffer(uint32_t manual_set_addr,
+						uint32_t write_data_addr);
+
+uint32_t hyper_flash_init(struct flash_control_operations *ops)
+{
+	uint32_t read_device_id = DEVICE_UNKNOWN;
+	uint32_t ret;
+
+	/* read hyper flash device id */
+	ret = hyper_flash_read_device_id(&read_device_id);
+
+	if (ret == FL_DRV_OK) {
+		/* HyperFlash : S26KS512S */
+		if (read_device_id == HYPER_FLASH) {
+			hyper_flash_set_control_ops(ops);
+			ret = FL_DRV_OK;
+		} else {
+			ret = FL_DRV_ERR_UNSUPPORT_DEV;
+		}
+	} else {
+		ret = FL_DRV_ERR_UNSUPPORT_DEV;
+	}
+	DMSG("device id=%x", read_device_id);
+
+	return ret;
+}
+
+static uint32_t hyper_flash_erase_sector(uint32_t sector_addr)
+{
+	uint32_t status = 0U;
+	uint32_t ret;
+
+	/* 1st command write */
+	ret = hyper_flash_set_command(HYPER_FL_UNLOCK1_ADD,
+							HYPER_FL_UNLOCK1_DATA);
+
+	if (ret == FL_DRV_OK) {
+		/* 2nd command write */
+		ret = hyper_flash_set_command(HYPER_FL_UNLOCK2_ADD,
+							HYPER_FL_UNLOCK2_DATA);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* 3rd command write */
+		ret = hyper_flash_set_command(HYPER_FL_UNLOCK3_ADD,
+							HYPER_FL_ERASE_1ST_COM);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* 4th command write */
+		ret = hyper_flash_set_command(HYPER_FL_UNLOCK1_ADD,
+							HYPER_FL_UNLOCK1_DATA);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* 5th command write */
+		ret = hyper_flash_set_command(HYPER_FL_UNLOCK2_ADD,
+							HYPER_FL_UNLOCK2_DATA);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* 6th Command command write */
+		ret = hyper_flash_set_command((sector_addr>>1U),
+						HYPER_FL_SECTOR_ERASE_COM);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* BIT7: Device Ready Bit (0=Busy, 1=Ready) */
+		ret = common_wait(hyper_flash_read_device_status, &status,
+					HF_ERASE_TIMEOUT, HF_ERASE_WAIT);
+	}
+
+	return ret;
+}
+
+static uint32_t hyper_flash_set_ext_addr_read_mode(uint32_t read_ext_top_addr,
+			uint32_t r_flash_addr, uint8_t *buf, size_t rsize)
+{
+/*
+ *Read (External Address Space Read Mode)
+ */
+	uint32_t readFlAddr;
+	uint32_t readData[2];
+	uint32_t ret = FL_DRV_OK;
+
+	uint32_t DREAR_value;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80040263U;
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x01FFF301U;
+	*((volatile uint32_t *)RPC_DRCR)	=	0x001F0100U;
+	*((volatile uint32_t *)RPC_DRCMR)	=	0x00A00000U;
+	DREAR_value = (read_ext_top_addr >> EXT_ADDR_BIT_SHIFT_9);
+	*((volatile uint32_t *)RPC_DREAR)   =	(DREAR_value | 0x00000001U);
+	/*
+	 * bit23-16 EAV[7:0]   = ADR[32:26]      : set
+	 * bit2-0   EAC[2:0]   = 001  : ADR[25:0 ] Enable
+	 */
+	*((volatile uint32_t *)RPC_DRENR)	=	0xA222D400U;
+	*((volatile uint32_t *)RPC_DRDMCR)	=	0x0000000EU;
+	*((volatile uint32_t *)RPC_DRDRENR)	=	0x00005101U;
+	*((volatile uint32_t *)RPC_OFFSET1)	=	0x21511144U;
+	*((volatile uint32_t *)RPC_PHYINT)	=	0x07070002U;
+	/*
+	 * bit18 RSTEN = 1 : RPC_RESET# pin is enabled
+	 * bit17 WPEN  = 1 : RPC_WP# pin is enabled
+	 * bit16 INTEN = 1 : RPC_INT# pin is enabled
+	 * bit2  RSTVAL= 0 : RPC_RESET# = H
+	 * bit1  WPVAL = 1 : RPC_WP# = L
+	 * bit0  INT   = 0 : Interrupt Status
+	 */
+
+	/* Output read data */
+	for (readFlAddr = r_flash_addr;
+		readFlAddr < (r_flash_addr+rsize);
+		readFlAddr += FLASH_DATA_READ_BYTE_COUNT_8) {
+
+		ret = hyper_flash_read_register_data(readFlAddr,
+						readData,
+						FLASH_DATA_READ_BYTE_COUNT_8);
+		(void)memcpy(buf, readData, FLASH_DATA_READ_BYTE_COUNT_8);
+		buf += FLASH_DATA_READ_BYTE_COUNT_8;
+	}
+
+	return ret;
+}
+
+static uint32_t hyper_flash_write_main(uint32_t buf_addr,
+					uint32_t flash_addr, uint32_t wsize)
+{
+	uint32_t wbuf_size;
+	uint32_t wcount;
+	uint32_t write_num;
+	uint32_t rest_wsize;
+	uint32_t work_flash_addr;
+	uint32_t write_data_addr;
+	uint32_t work_flash_256top;
+	uint32_t w_offset;
+	uint8_t wbuff[WRITE_BUFF_SIZE];
+	uintptr_t uptr_wbuff;
+	volatile uintptr_t v_flash_addr = flash_addr;
+	uint8_t *p_flash_addr;
+	uint32_t ret = FL_DRV_OK;
+
+	hyper_flash_set_disable_write_protect();
+
+	write_data_addr = buf_addr;
+	work_flash_addr = flash_addr;
+	write_num = wsize / WRITE_BUFF_SIZE;
+	rest_wsize = wsize % WRITE_BUFF_SIZE;
+	if (rest_wsize > 0U) {
+		write_num++;
+	}
+
+	/* RPC Write Buffer size : 256byte , and rest size writing */
+	for (wcount = 0U; wcount < write_num; wcount++) {
+		if (wcount == (write_num - 1U)) {
+			if (rest_wsize > 0U) {
+				wbuf_size = rest_wsize;
+				work_flash_256top =
+					(work_flash_addr / WRITE_BUFF_SIZE) *
+								WRITE_BUFF_SIZE;
+				(void)memset(wbuff, 0xffU, WRITE_BUFF_SIZE);
+				w_offset = work_flash_addr - work_flash_256top;
+				v_flash_addr = write_data_addr;
+				p_flash_addr = (uint8_t *)v_flash_addr;
+				(void)memcpy(wbuff+w_offset, p_flash_addr,
+								wbuf_size);
+				uptr_wbuff = (uintptr_t)wbuff;
+				ret = hyper_flash_request_write_buffer(
+					work_flash_256top, uptr_wbuff);
+				break;
+			}
+		}
+		ret = hyper_flash_request_write_buffer(work_flash_addr,
+							write_data_addr);
+		work_flash_addr += WRITE_BUFF_SIZE;
+		write_data_addr += WRITE_BUFF_SIZE;
+	}
+
+	return ret;
+}
+
+static void hyper_flash_set_control_ops(struct flash_control_operations *ops)
+{
+	ops->erase = hyper_flash_erase_sector;
+	ops->set_ext_addr_read_mode = hyper_flash_set_ext_addr_read_mode;
+	ops->write = hyper_flash_write_main;
+}
+
+static uint32_t hyper_flash_set_command(uint32_t manual_set_addr,
+							uint32_t command)
+{
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000263U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 11 : HyperFlash
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF301U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 01 : QSPI Flash x 2 or HyperFlash
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00000000U;
+	/*
+	 * bit23-21 CMD[7:5] = 000 : CA47-45 = 000 =>
+	 *                                      Write/memory space/WrrapedBrst
+	 */
+
+	*((volatile uint32_t *)RPC_SMADR)	=	manual_set_addr;
+	*((volatile uint32_t *)RPC_SMOPR)	=	0x00000000U;
+	/*
+	 * CA15-3(Reserved) = all 0
+	 */
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00005101U;
+	/*
+	 * bit14-12 HYPE =101:Hyperflash mode
+	 * bit8 ADDRE  = 1 : Address DDR transfer
+	 * bit0 SPIDRE = 1 : DATA DDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0xA2225408U;
+	/*
+	 * bit31-30 CDB[1:0]   =   10 : 4bit width command
+	 * bit25-24 ADB[1:0]   =   10 : 4bit width address
+	 * bit17-16 SPIDB[1:0] =   10 : 4bit width transfer data
+	 * bit15    DME        =    0 : dummy cycle disable
+	 * bit14    CDE        =    1 : Command enable
+	 * bit12    OCDE       =    1 : Option Command enable
+	 * bit11-8  ADE[3:0]   = 0100 : ADR[23:0] output (24 Bit Address)
+	 * bit7-4   OPDE[3:0]  = 0000 : Option data disable
+	 * bit3-0   SPIDE[3:0] = 1000 : 16bit transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMWDR0)	=	command;
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000003U;
+	/*
+	 * bit2     SPIRE      = 0 : Data read disable
+	 * bit1     SPIWE      = 1 : Data write enable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					HF_WRITE_TIMEOUT, HF_WRITE_WAIT);
+	return ret;
+}
+
+static void hyper_flash_set_disable_write_protect(void)
+{
+	uint32_t dataL;
+
+	dataL = *((volatile uint32_t *)RPC_PHYINT);
+
+	/*
+	 * bit1:WPVAL(0:RPC_WP#=H(Protect Disable),1:RPC_WP#=L(Protect Enable))
+	 */
+	if ((dataL & BIT1) != 0U) {
+		dataL &= ~BIT1;
+		*((volatile uint32_t *)RPC_PHYINT) = dataL;
+	}
+}
+
+static uint32_t hyper_flash_reset_to_read_mode(void)
+{
+	uint32_t ret;
+
+	/* Reset / ASO Exit */
+	ret = hyper_flash_set_command(HYPER_FL_SMADR_TOP_ADD,
+							HYPER_FL_RESET_COM);
+	return ret;
+}
+
+static uint32_t hyper_flash_read_register_data(uint32_t manual_set_addr,
+				uint32_t *read_data, uint32_t byte_count)
+{
+	uint32_t status = 0U;
+	uint32_t ret;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000263U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 11 : HyperFlash
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF301U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 01 : QSPI Flash x 2 or HyperFlash
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00800000U;
+	/*
+	 * bit23-21 CMD[7:5] = 100 : CA47-45 = 100 =>
+	 *                                      Read/memory space/WrrapedBrst
+	 */
+
+	*((volatile uint32_t *)RPC_SMADR)	=	(manual_set_addr>>1U);
+	/*
+	 * ByteAddress(8bit) => WordAddress(16bit)
+	 */
+
+	*((volatile uint32_t *)RPC_SMOPR)	=	0x00000000U;
+	/*
+	 * CA15-3(Reserved) = all 0
+	 */
+
+	*((volatile uint32_t *)RPC_SMDMCR)	=	0x0000000EU;
+	/*
+	 *                           15 cycle dummy wait
+	 */
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00005101U;
+	/*
+	 * bit8 ADDRE  = 1 : Address DDR transfer
+	 * bit0 SPIDRE = 1 : DATA DDR transfer
+	 */
+
+	switch (byte_count) {
+	/* 2byte Read */
+	case FLASH_DATA_READ_BYTE_COUNT_2:
+		*((volatile uint32_t *)RPC_SMENR)	= 0xA222D408U;
+		/* bit3-0   SPIDE[3:0] = 1000 : 16bit transfer*/
+		break;
+	/* 4byte Read */
+	case FLASH_DATA_READ_BYTE_COUNT_4:
+		*((volatile uint32_t *)RPC_SMENR)	= 0xA222D40CU;
+		/* bit3-0   SPIDE[3:0] = 1100 : 32bit transfer */
+		break;
+	/* 8byte Read */
+	case FLASH_DATA_READ_BYTE_COUNT_8:
+		*((volatile uint32_t *)RPC_SMENR)	= 0xA222D40FU;
+	/*
+	 * bit31-30 CDB[1:0]   =   10 : 4bit width command
+	 * bit25-24 ADB[1:0]   =   10 : 4bit width address
+	 * bit17-16 SPIDB[1:0] =   10 : 4bit width transfer data
+	 * bit15    DME        =    1 : dummy cycle enable
+	 * bit14    CDE        =    1 : Command enable
+	 * bit12    OCDE       =    1 : Option Command enable
+	 * bit11-8  ADE[3:0]   = 0100 : ADR[23:0]output(24Bit Address)
+	 * bit7-4   OPDE[3:0]  = 0000 : Option data disable
+	 * bit3-0   SPIDE[3:0] = 1111 : 64bit transfer
+	 */
+		break;
+	default:
+		EMSG("Incollect read size. byte_count=%d", byte_count);
+		break;
+	}
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000005U;
+	/*
+	 * bit2     SPIRE      = 1 : Data read enable
+	 * bit1     SPIWE      = 0 : Data write disable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					HF_READ_TIMEOUT, HF_READ_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		if (byte_count == FLASH_DATA_READ_BYTE_COUNT_8) {
+			read_data[1] = *((volatile uint32_t *)RPC_SMRDR0);
+			/* read data[63:32] */
+		}
+
+		read_data[0] = *((volatile uint32_t *)RPC_SMRDR1);
+		/* read data[31:0] */
+	}
+
+	return ret;
+}
+
+
+
+static uint32_t hyper_flash_read_device_id(uint32_t *read_device_id)
+{
+	uint32_t read_data[2];
+	uint32_t set_addr;
+	uint32_t ret;
+
+	/* 1st command write */
+	ret = hyper_flash_set_command(HYPER_FL_UNLOCK1_ADD,
+							HYPER_FL_UNLOCK1_DATA);
+
+	if (ret == FL_DRV_OK) {
+		/* 2nd command write */
+		ret = hyper_flash_set_command(HYPER_FL_UNLOCK2_ADD,
+							HYPER_FL_UNLOCK2_DATA);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* 3rd command write */
+		ret = hyper_flash_set_command(HYPER_FL_UNLOCK3_ADD,
+							HYPER_FL_ID_ENTRY_COM);
+	}
+
+	for (set_addr = 0U; set_addr < (FLASH_DATA_OFFSET_BYTE_8*2U);
+		set_addr += FLASH_DATA_OFFSET_BYTE_8) {
+
+		ret = hyper_flash_read_register_data(set_addr,
+						read_data,
+						FLASH_DATA_READ_BYTE_COUNT_8);
+
+		if (set_addr == 0U) {
+			*read_device_id =
+			(((read_data[0]&0xFF000000U)>>FLASH_DATA_BIT_SHIFT_8) |
+			((read_data[0]&0x00FF0000U)<<FLASH_DATA_BIT_SHIFT_8) |
+			((read_data[0]&0x0000FF00U)>>FLASH_DATA_BIT_SHIFT_8) |
+			((read_data[0]&0x000000FFU)<<FLASH_DATA_BIT_SHIFT_8));
+		}
+	}
+
+	if (ret == FL_DRV_OK) {
+		ret = hyper_flash_reset_to_read_mode();
+	}
+
+	return ret;
+}
+
+static uint32_t hyper_flash_request_write_buffer(uint32_t flash_addr,
+						uint32_t write_data_addr)
+{
+	uint32_t status = 0U;
+	uint32_t ret;
+
+	ret = hyper_flash_write_buffer_control(flash_addr, write_data_addr);
+
+	if (ret == FL_DRV_OK) {
+		/* BIT7: Device Ready Bit (0=Busy, 1=Ready) */
+		ret = common_wait(hyper_flash_read_device_status, &status,
+					HF_WRITE_TIMEOUT, HF_WRITE_WAIT);
+	}
+
+	return ret;
+}
+
+static uint32_t hyper_flash_write_buffer_control(uint32_t flash_addr,
+						uint32_t write_data_addr)
+{
+	uint32_t ret;
+
+	/* 1st command write */
+	ret = hyper_flash_set_command(HYPER_FL_UNLOCK1_ADD,
+							HYPER_FL_UNLOCK1_DATA);
+
+	if (ret == FL_DRV_OK) {
+		/* 2nd command write */
+		ret = hyper_flash_set_command(HYPER_FL_UNLOCK2_ADD,
+							HYPER_FL_UNLOCK2_DATA);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* 3rd command write */
+		ret = hyper_flash_set_command(HYPER_FL_UNLOCK3_ADD,
+						HYPER_FL_WORD_PROGRAM_COM);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* 4th command write */
+		flash_addr = (flash_addr/2U);
+		ret = hyper_flash_write_buffer(flash_addr, write_data_addr);
+	}
+
+	return ret;
+}
+
+static uint32_t hyper_flash_write_buffer(uint32_t manual_set_addr,
+						uint32_t write_data_addr)
+{
+	uintptr_t offset;
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_DRCR)	=	0x01FF0301U;
+	/*
+	 * bit9   RCF         =  1 : Read Cache Clear
+	 */
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000277U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit2   WBUF        =  1 : Write Buffer Enable
+	 * bit1-0 PHYMEM[1:0] = 11 : HyperFlash
+	 */
+
+	for (offset = 0U; offset < WRITE_BUFF_SIZE;
+						offset = offset + WORD_SIZE) {
+		(*(volatile uint32_t *)(0xEE208000U+offset)) =
+			(*(volatile uint32_t *)(write_data_addr+offset));
+	}
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF301U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 01 : QSPI Flash x 2 or HyperFlash
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00000000U;
+	/*
+	 * bit23-21 CMD[7:5] = 000 : CA47-45 = 000 =>
+	 *                                      Write/memory space/WrrapedBrst
+	 */
+
+	*((volatile uint32_t *)RPC_SMADR)	=	manual_set_addr;
+	*((volatile uint32_t *)RPC_SMOPR)	=	0x00000000U;
+	/*
+	 * CA15-3(Reserved) = all 0
+	 */
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00005101U;
+	/*
+	 * bit8 ADDRE  = 1 : Address DDR transfer
+	 * bit0 SPIDRE = 1 : DATA DDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0xA222540FU;
+	/*
+	 * bit31-30 CDB[1:0]   =   10 : 4bit width command
+	 * bit25-24 ADB[1:0]   =   10 : 4bit width address
+	 * bit17-16 SPIDB[1:0] =   10 : 4bit width transfer data
+	 * bit15    DME        =    0 : dummy cycle disable
+	 * bit14    CDE        =    1 : Command enable
+	 * bit12    OCDE       =    1 : Option Command enable
+	 * bit11-8  ADE[3:0]   = 0100 : ADR[23:0] output (24 Bit Address)
+	 * bit7-4   OPDE[3:0]  = 0000 : Option data disable
+	 * bit3-0   SPIDE[3:0] = 1111 : 64bit transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000003U;
+	/*
+	 * bit2     SPIRE      = 0 : Data read disable
+	 * bit1     SPIWE      = 1 : Data write enable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					HF_WRITE_TIMEOUT, HF_WRITE_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		*((volatile uint32_t *)RPC_PHYCNT)	=	0x00000273U;
+		/*
+		 * bit31  CAL         =  0 : No PHY calibration
+		 * bit2   WBUF        =  0 : Write Buffer Disable
+		 * bit1-0 PHYMEM[1:0] = 11 : HyperFlash
+		 */
+
+		*((volatile uint32_t *)RPC_DRCR)	=	0x01FF0301U;
+		/*
+		 * bit9   RCF         =  1 : Read Cache Clear
+		 */
+	}
+
+	return ret;
+}
+
+uint32_t hyper_flash_read_device_status(uint32_t *read_status)
+{
+	uint32_t read_data[2];
+	uint32_t ret;
+
+	/* 1st command write */
+	ret = hyper_flash_set_command(HYPER_FL_UNLOCK1_ADD,
+							HYPER_FL_RD_STATUS_COM);
+
+	if (ret == FL_DRV_OK) {
+		/* Status Register read */
+		ret = hyper_flash_read_register_data(HYPER_FL_SMADR_TOP_ADD,
+				read_data, FLASH_DATA_READ_BYTE_COUNT_8);
+		if (ret == FL_DRV_OK) {
+			*read_status =
+			(((read_data[0] & 0xFF000000U)>>FLASH_DATA_BIT_SHIFT_8))
+		       | ((read_data[0] & 0x00FF0000U)<<FLASH_DATA_BIT_SHIFT_8)
+		       | ((read_data[0] & 0x0000FF00U)>>FLASH_DATA_BIT_SHIFT_8)
+		       | ((read_data[0] & 0x000000FFU)<<FLASH_DATA_BIT_SHIFT_8);
+
+			*read_status = (*read_status & 0x0000FFFFU);
+
+			if ((*read_status & BIT7) != 0U) {
+				ret = FL_DEVICE_READY;
+			} else {
+				ret = FL_DEVICE_BUSY;
+			}
+		} else {
+			ret = FL_DEVICE_ERR;
+		}
+	} else {
+		ret = FL_DEVICE_ERR;
+	}
+
+	return ret;
+}
diff --git a/core/arch/arm/plat-rcar/drivers/hyper_flash_control.h b/core/arch/arm/plat-rcar/drivers/hyper_flash_control.h
new file mode 100644
index 0000000..7dd9633
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/hyper_flash_control.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef HYPER_FLASH_CONTROL_H
+#define HYPER_FLASH_CONTROL_H
+
+#include "qspi_hyper_flash_common.h"
+
+uint32_t hyper_flash_init(struct flash_control_operations *ops);
+uint32_t hyper_flash_read_device_status(uint32_t *read_status);
+
+#endif /* HYPER_FLASH_CONTROL_H */
diff --git a/core/arch/arm/plat-rcar/drivers/mfis_driver.c b/core/arch/arm/plat-rcar/drivers/mfis_driver.c
new file mode 100644
index 0000000..6a1195b
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/mfis_driver.c
@@ -0,0 +1,262 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <io.h>
+#include <kernel/panic.h>
+#include <kernel/interrupt.h>
+#include <initcall.h>
+#include <drivers/mfis_driver.h>
+#include "rcar_common.h"
+
+/******************************************************************************/
+/* Defines                                                                    */
+/******************************************************************************/
+/* Register */
+#define	MFIERRCTLR(a)	((volatile uint32_t *)(0xE6260200U + (uintptr_t)((a) * 4U)))
+#define	MFIERRSTSR(a)	((volatile uint32_t *)(0xE6260240U + (uintptr_t)((a) * 4U)))
+#define	MFIERRTGTR(a)	((volatile uint32_t *)(0xE6260280U + (uintptr_t)((a) * 4U)))
+#define	MFIERRCTLR7	((volatile uint32_t *)(0xE6260260U))
+#define	MFIERRSTSR7	((volatile uint32_t *)(0xE6260264U))
+#define	MFIERRTGTR7	((volatile uint32_t *)(0xE6260268U))
+#define	MFIERRTGTR6	((volatile uint32_t *)(0xE626025CU))
+
+#define SMSTPCR2	(0xE6150138U)
+#define SMSTP_MFISFLG	((uint32_t)1U<<13U)
+
+typedef struct {
+	struct {
+		volatile uint32_t *MFIERRCTLR;
+		volatile uint32_t *MFIERRSTSR;
+		volatile uint32_t *MFIERRTGTR;
+	}array[MFIS_ERR_DET_MAX];
+}MFIS_REG_T;
+
+#define MFIS_ERR_0	(409U + 32U)
+#define MFIS_ERR_1	(410U + 32U)
+#define MFIS_ERR_2	(411U + 32U)
+#define MFIS_ERR_3	(412U + 32U)
+#define MFIS_ERR_4	(413U + 32U)
+#define MFIS_ERR_5	(414U + 32U)
+#define MFIS_ERR_6	(415U + 32U)
+#define MFIS_ERR_7	(307U + 32U)
+
+#define MFIS_STATE_NOACTIVE	(0U)
+#define MFIS_STATE_ACTIVE	(1U)
+
+/******************************************************************************/
+/* Prototype                                                                  */
+/******************************************************************************/
+static enum itr_return mfis_err_handler(struct itr_handler *h);
+static TEE_Result mfis_err_init(void);
+
+/******************************************************************************/
+/* Global                                                                     */
+/******************************************************************************/
+static uint32_t		mfis_state = MFIS_STATE_NOACTIVE;
+static uint32_t		mfis_reg_num = MFIS_ERR_DET_MAX - 1U;
+static MFIS_REG_T	mfis_reg;
+static MFIS_ERR_SETTING_T	local_setting;
+static void (*user_cb)(MFIS_ERR_FACTOR_T*) = NULL;
+
+static enum itr_return mfis_err_handler(struct itr_handler *h)
+{
+	MFIS_ERR_FACTOR_T factor = {{0U}};
+	uint32_t table;
+
+	if (NULL != h) {
+		if (MFIS_ERR_7 == h->it) {
+			table = MFIS_ERR_DET_MAX - 1U;
+		} else {
+			table = h->it - MFIS_ERR_0;
+		}
+
+		factor.error[table] = *(mfis_reg.array[table].MFIERRSTSR);
+
+		if (NULL != user_cb) {
+			user_cb(&factor);
+		}
+
+		*(mfis_reg.array[table].MFIERRSTSR) = factor.error[table];
+		(void)*(mfis_reg.array[table].MFIERRSTSR);
+		dsb();
+	}
+	return ITRR_HANDLED;
+}
+
+static struct itr_handler mfis_err_itr[] = {
+	{
+	.it = MFIS_ERR_0,
+	.flags = (uint32_t)ITRF_TRIGGER_LEVEL,
+	.handler = &mfis_err_handler
+	},
+	{
+	.it = MFIS_ERR_1,
+	.flags = (uint32_t)ITRF_TRIGGER_LEVEL,
+	.handler = &mfis_err_handler
+	},
+	{
+	.it = MFIS_ERR_2,
+	.flags = (uint32_t)ITRF_TRIGGER_LEVEL,
+	.handler = &mfis_err_handler
+	},
+	{
+	.it = MFIS_ERR_3,
+	.flags = (uint32_t)ITRF_TRIGGER_LEVEL,
+	.handler = &mfis_err_handler
+	},
+	{
+	.it = MFIS_ERR_4,
+	.flags = (uint32_t)ITRF_TRIGGER_LEVEL,
+	.handler = &mfis_err_handler
+	},
+	{
+	.it = MFIS_ERR_5,
+	.flags = (uint32_t)ITRF_TRIGGER_LEVEL,
+	.handler = &mfis_err_handler
+	},
+	{
+	.it = MFIS_ERR_6,
+	.flags = (uint32_t)ITRF_TRIGGER_LEVEL,
+	.handler = &mfis_err_handler
+	},
+	{
+	.it = MFIS_ERR_7,
+	.flags = (uint32_t)ITRF_TRIGGER_LEVEL,
+	.handler = &mfis_err_handler
+	}
+};
+
+int32_t mfis_error_detection_start(MFIS_ERR_SETTING_T *err,
+		void (*cb)(MFIS_ERR_FACTOR_T*))
+{
+	int32_t ret = MFIS_SUCCESS;
+	uint32_t loop;
+	uint32_t reg;
+	uint32_t enable_flag = 0U;
+
+	if ((NULL == err) || (NULL == cb)) {
+		ret = MFIS_ERR_PARAMETER;
+	}
+
+	if ((MFIS_SUCCESS == ret) && (MFIS_STATE_NOACTIVE != mfis_state)) {
+		ret = MFIS_ERR_SEQUENCE;
+	}
+
+	if (MFIS_SUCCESS == ret) {
+		reg = read32(SMSTPCR2);
+		reg &= ~SMSTP_MFISFLG;
+		write32(reg, SMSTPCR2);
+		
+		for (loop = 0U; loop < mfis_reg_num; loop++) {
+			if ((0U != err->control[loop])
+					|| (0U != err->target[loop])) {
+				reg = *(mfis_reg.array[loop].MFIERRSTSR);
+				*(mfis_reg.array[loop].MFIERRTGTR) =
+						err->target[loop];
+				*(mfis_reg.array[loop].MFIERRSTSR) = reg;
+				*(mfis_reg.array[loop].MFIERRCTLR) =
+						err->control[loop];
+
+				itr_enable(&mfis_err_itr[loop]);
+				
+				enable_flag = 1U;
+			}
+		}
+		if (enable_flag == 1U) {
+			local_setting = *err;
+			user_cb = cb;
+			mfis_state = MFIS_STATE_ACTIVE;
+		} else {
+			ret = MFIS_ERR_PARAMETER;
+		}
+	}
+
+	return ret;
+}
+
+int32_t mfis_error_detection_stop(void)
+{
+	uint32_t reg;
+	uint32_t loop;
+	int32_t ret = MFIS_SUCCESS;
+
+	if (MFIS_STATE_ACTIVE != mfis_state) {
+		ret = MFIS_ERR_SEQUENCE;
+	} else {
+		
+		for (loop = 0U; loop < mfis_reg_num; loop++) {
+			if ((0U != local_setting.control[loop])
+					|| (0U != local_setting.target[loop])) {
+				itr_disable(&mfis_err_itr[loop]);
+				reg = *(mfis_reg.array[loop].MFIERRSTSR);
+				*(mfis_reg.array[loop].MFIERRSTSR) = reg;
+				*(mfis_reg.array[loop].MFIERRTGTR) = 0U;
+				*(mfis_reg.array[loop].MFIERRCTLR) = 0U;
+			}
+		}
+		
+		reg = read32(SMSTPCR2);
+		reg |= SMSTP_MFISFLG;
+		write32(reg, SMSTPCR2);
+
+		user_cb = NULL;
+		mfis_state = MFIS_STATE_NOACTIVE;
+	}
+
+	return ret;
+}
+
+static TEE_Result mfis_err_init(void)
+{
+	uint32_t loop;
+	uint32_t type;
+	
+	(void)memset(&mfis_reg, 0x00, sizeof(MFIS_REG_T));
+
+	for(loop = 0U; loop < (MFIS_ERR_DET_MAX - 1U); loop++)
+	{
+		mfis_reg.array[loop].MFIERRCTLR = MFIERRCTLR(loop);
+		mfis_reg.array[loop].MFIERRSTSR = MFIERRSTSR(loop);
+		mfis_reg.array[loop].MFIERRTGTR = MFIERRTGTR(loop);
+		itr_add(&mfis_err_itr[loop]);
+	}
+	mfis_reg.array[6U].MFIERRTGTR = MFIERRTGTR6;
+
+	type = read32(PRR) & PRR_PRODUCT_MASK;
+
+	if (PRR_PRODUCT_M3 == type) {
+		mfis_reg.array[7U].MFIERRCTLR = MFIERRCTLR7;
+		mfis_reg.array[7U].MFIERRSTSR = MFIERRSTSR7;
+		mfis_reg.array[7U].MFIERRTGTR = MFIERRTGTR7;
+		itr_add(&mfis_err_itr[7U]);
+		mfis_reg_num = MFIS_ERR_DET_MAX;
+	}
+
+	return TEE_SUCCESS;
+}
+
+driver_init(mfis_err_init);
diff --git a/core/arch/arm/plat-rcar/drivers/qspi_flash_common.c b/core/arch/arm/plat-rcar/drivers/qspi_flash_common.c
new file mode 100644
index 0000000..ff8f535
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/qspi_flash_common.c
@@ -0,0 +1,346 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <trace.h>
+#include <drivers/qspi_hyper_flash.h>
+
+#include "qspi_hyper_flash_common.h"
+#include "qspi_flash_common.h"
+#include "qspi_onboard_control.h"
+#include "qspi_quad_control.h"
+
+static uint32_t qspi_common_read_device_id(uint32_t *read_device_id);
+static uint32_t qspi_common_erase_sector(uint32_t manual_set_addr);
+
+uint32_t qspi_common_init(struct flash_control_operations *ops)
+{
+/*
+ * S25FS128S and S25FL512S are common logic
+ */
+	uint32_t read_device_id = DEVICE_UNKNOWN;
+	uint32_t ret;
+
+	/* read qspi flash device id */
+	ret = qspi_common_read_device_id(&read_device_id);
+	if (ret == FL_DRV_OK) {
+		/* update the device id */
+		switch (read_device_id) {
+		/* QSPI_ONBOARD : S25S128S */
+		case QSPI_ONBOARD:
+			qspi_onboard_set_control_ops(ops);
+			ret = FL_DRV_OK;
+			break;
+		/* QSPI_QUAD : S25FL512S */
+		case QSPI_QUAD:
+			qspi_quad_set_control_ops(ops);
+			ret = FL_DRV_OK;
+			break;
+		/* Unsupport device id */
+		default:
+			ret = FL_DRV_ERR_UNSUPPORT_DEV;
+			EMSG("Unsupport device id=%x", read_device_id);
+			break;
+		}
+	} else {
+		ret = FL_DRV_ERR_UNSUPPORT_DEV;
+	}
+	DMSG("device id=%x", read_device_id);
+
+	return ret;
+}
+
+uint32_t qspi_common_erase_control(uint32_t sector_addr)
+{
+/*
+ * Qspi:Sector Erase
+ * 4SE DCh
+ */
+	uint32_t read_status = 0U;
+	uint32_t ret;
+
+	/* WRITE ENABLE */
+	ret = qspi_common_set_command(QSPI_FL_COMMAND_WRITE_ENABLE);
+	
+	if (ret == FL_DRV_OK) {
+		ret = qspi_common_erase_sector(sector_addr);
+	}
+
+	if (ret == FL_DRV_OK) {
+		ret = common_wait(qspi_common_read_device_status, &read_status,
+					QSPI_ERASE_TIMEOUT, QSPI_ERASE_WAIT);
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_common_erase_sector(uint32_t manual_set_addr)
+{
+/*
+ * 4SE DCh 4-byte address
+ * S25FS128S and S25FL512S are common logic
+ */
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00DC0000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0xDC : Sector Erase 4-byte address command
+	 */
+
+	*((volatile uint32_t *)RPC_SMADR)	=	manual_set_addr;
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x00004F00U;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   00 : 1bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    0 : No dummy cycle
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 1111 : ADR[31:0] output (32 Bit Address)
+	 * bit3-0   SPIDE[3:0] = 0000 : No transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000001U;
+	/*
+	 * bit2     SPIRE      = 0 : Data read disable
+	 * bit1     SPIWE      = 0 : Data write disable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_READ_TIMEOUT, QSPI_READ_WAIT);
+
+	return ret;
+}
+
+static uint32_t qspi_common_read_device_id(uint32_t *read_device_id)
+{
+/*
+ * S25FS128S and S25FL512S are common logic
+ */
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x009F0000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x9F : Read ID command(for Palladium QSPI model)
+	 */
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x0000400FU;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   00 : 1bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    0 : No dummy cycle
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 0000 : Address output disable
+	 * bit3-0   SPIDE[3:0] = 1111 : 32bit transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000005U;
+	/*
+	 * bit2     SPIRE      = 1 : Data read enable
+	 * bit1     SPIWE      = 0 : Data write disable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_READ_TIMEOUT, QSPI_READ_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		/* read data[31:0] */
+		*read_device_id = *((volatile uint32_t *)RPC_SMRDR0);
+
+		/* mask : device id 03h */
+		*read_device_id = *read_device_id & 0x00FFFFFFU;
+	}
+
+	return ret;
+}
+
+uint32_t qspi_common_read_device_status(uint32_t *read_status)
+{
+/*
+ * S25FS128S and S25FL512S are common logic
+ */
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00050000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x05 : StatusReadCommand(for PalladiumQSPImodel)
+	 */
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x0000400FU;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   00 : 1bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    0 : No dummy cycle
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 0000 : Address output disable
+	 * bit3-0   SPIDE[3:0] = 1111 : 32bit transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000005U;
+	/*
+	 * bit2     SPIRE      = 1 : Data read enable
+	 * bit1     SPIWE      = 0 : Data write disable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_READ_TIMEOUT, QSPI_READ_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		/* read data[31:0] */
+		*read_status = *((volatile uint32_t *)RPC_SMRDR0);
+
+		if ((*read_status & BIT0) == 0U) {
+			ret = FL_DEVICE_READY;
+		} else {
+			ret = FL_DEVICE_BUSY;
+		}
+
+		if ((*read_status & BIT5) != 0U) {
+			ret = FL_DEVICE_ERR;
+		}
+	} else {
+		ret = FL_DEVICE_ERR;
+	}
+
+	return ret;
+}
+
+uint32_t qspi_common_set_command(uint32_t command)
+{
+/*
+ * S25FS128S and S25FL512S are common logic
+ */
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	command;
+	/*
+	 * bit23-16 CMD[7:0] : command
+	 */
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x00004000U;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   00 : 1bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    0 : No dummy cycle
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 0000 : Address output disable
+	 * bit3-0   SPIDE[3:0] = 0000 : No transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000001U;
+	/*
+	 * bit2     SPIRE      = 0 : Data read disable
+	 * bit1     SPIWE      = 0 : Data write disable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_WRITE_TIMEOUT, QSPI_WRITE_WAIT);
+
+	return ret;
+}
diff --git a/core/arch/arm/plat-rcar/drivers/qspi_flash_common.h b/core/arch/arm/plat-rcar/drivers/qspi_flash_common.h
new file mode 100644
index 0000000..9a60e83
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/qspi_flash_common.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef QSPI_FLASH_COMMON_H
+#define QSPI_FLASH_COMMON_H
+
+#include "qspi_hyper_flash_common.h"
+
+uint32_t qspi_common_init(struct flash_control_operations *ops);
+uint32_t qspi_common_set_command(uint32_t command);
+uint32_t qspi_common_erase_control(uint32_t sector_addr);
+uint32_t qspi_common_read_device_status(uint32_t *read_status);
+
+#endif /* QSPI_FLASH_COMMON_H */
diff --git a/core/arch/arm/plat-rcar/drivers/qspi_hyper_flash.c b/core/arch/arm/plat-rcar/drivers/qspi_hyper_flash.c
new file mode 100644
index 0000000..478a9c5
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/qspi_hyper_flash.c
@@ -0,0 +1,251 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include <trace.h>
+#include <drivers/qspi_hyper_flash.h>
+
+#include "qspi_hyper_flash_common.h"
+#include "qspi_flash_common.h"
+#include "hyper_flash_control.h"
+
+static uint32_t erase_flash_unsupported(uint32_t sector_addr);
+static uint32_t ext_addr_read_mode_flash_unsupported(uint32_t read_ext_top_addr,
+			uint32_t flash_addr, uint8_t *buf, size_t rsize);
+static uint32_t write_flash_unsupported(uint32_t buf_addr,
+					uint32_t flash_addr, uint32_t wsize);
+static uint32_t init_rpc(void);
+
+static struct flash_control_operations flash_control_ops = {
+	.erase = erase_flash_unsupported,
+	.set_ext_addr_read_mode = ext_addr_read_mode_flash_unsupported,
+	.write = write_flash_unsupported,
+};
+
+uint32_t qspi_hyper_flash_init(void)
+{
+	uint32_t ret;
+
+	ret = init_rpc();
+
+	if (ret == FL_DRV_OK) {
+		ret = hyper_flash_init(&flash_control_ops);
+	}
+
+	if (ret != FL_DRV_OK) {
+		ret = qspi_common_init(&flash_control_ops);
+	}
+
+	return ret;
+}
+
+uint32_t qspi_hyper_flash_erase(uint32_t sector_addr)
+{
+	uint32_t ret = FL_DRV_OK;
+	uint32_t check_sector_size;
+
+	DMSG("sector_addr=%x", sector_addr);
+
+	check_sector_size = (sector_addr) % (SECTOR_SIZE);
+	if (check_sector_size != 0U) {
+		ret = FL_DRV_ERR_SECTOR_ADDR;
+		EMSG("sector_addr is not sector top address. sector_addr=%x",
+			sector_addr);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* erase the according to device id */
+		ret = flash_control_ops.erase(sector_addr);
+	}
+
+	DMSG("ret=%d", ret);
+
+	return ret;
+}
+
+uint32_t qspi_hyper_flash_read(uint32_t flash_addr, uint8_t *buf, size_t rsize)
+{
+	uint32_t ret = FL_DRV_OK;
+	uint32_t check_sector_size;
+	uint32_t ext_top_addr;
+	uint32_t quotient;
+
+	volatile uintptr_t v_flash_addr = (SPI_IOADDRESS_TOP + flash_addr);
+	uint8_t *p_flash_addr;
+
+	DMSG("flash_addr=%x, buf=%p, rsize=%zu", flash_addr, buf, rsize);
+
+	if (buf == NULL) {
+		ret = FL_DRV_ERR_BUF_INCORRECT;
+		EMSG("buf is incorrect.");
+	}
+	if ((rsize > SECTOR_SIZE) || (rsize < FLASH_DATA_READ_BYTE_COUNT_8) ||
+				((rsize % FLASH_DATA_READ_BYTE_COUNT_8) > 0U)) {
+		ret = FL_DRV_ERR_OUT_OF_RANGE;
+		EMSG("rsize is out of range. rsize=%zu", rsize);
+	}
+
+	/* Ex. )
+	 *	Each value is not an actual value.Each value is for description
+	 *      ---------------------------------------------------------
+	 *	flash_addr      : 0x408(1032)
+	 *	SECTOR_SIZE     : 0x100(256)
+	 *	rsize           : 50
+	 *	already written : 8 ( from 0x400(1024) to 0x407 (1031))
+	 *	---------------------------------------------------------
+	 *	[calculate] already written size at sector
+	 *		1032 % 256 = 8
+	 *	[compare] check aector exceed
+	 *		(8 + 50) is over 256 ?
+	 *		No : Not sector exceeded
+	 *		Yes: Sector exceeded
+	 *	---------------------------------------------------------
+	*/
+	check_sector_size = ((flash_addr) % (SECTOR_SIZE)) + rsize;
+
+	if (check_sector_size > SECTOR_SIZE) {
+		ret = FL_DRV_ERR_SECTOR_EXCEED;
+		EMSG("Sector exceeded. flash_addr=%x, rsize=%zu",
+			flash_addr, rsize);
+	}
+
+	/* External address reading position calculation From 64MB boundary. */
+	if (flash_addr > EXT_ADD_BORDER_SIZE_64MB) {
+		quotient = (flash_addr / EXT_ADD_BORDER_SIZE_64MB);
+		v_flash_addr = SPI_IOADDRESS_TOP +
+			(flash_addr - (quotient * EXT_ADD_BORDER_SIZE_64MB));
+		p_flash_addr = (uint8_t *)v_flash_addr;
+		DMSG("p_flash_addr=%p", p_flash_addr);
+		(void)p_flash_addr; /* suppress compile error */
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* Switch to the external address read mode */
+		ext_top_addr = (flash_addr & EXT_ADDR_MASK);
+		ret = flash_control_ops.set_ext_addr_read_mode(ext_top_addr,
+						flash_addr, buf, rsize);
+	}
+
+	DMSG("ret=%d", ret);
+
+	return ret;
+
+}
+
+uint32_t qspi_hyper_flash_write(uint32_t flash_addr, const uint8_t *buf,
+				size_t wsize)
+{
+	uint32_t ret = FL_DRV_OK;
+	uint32_t check_sector_size;
+
+	DMSG("flash_addr=%x, buf=%p, wsize=%zu", flash_addr, buf, wsize);
+
+	if (buf == NULL) {
+		ret = FL_DRV_ERR_BUF_INCORRECT;
+		EMSG("buf is incorrect.");
+	}
+	if ((wsize > SECTOR_SIZE) || (wsize < FLASH_DATA_READ_BYTE_COUNT_8) ||
+				((wsize % FLASH_DATA_READ_BYTE_COUNT_8) > 0U)) {
+		ret = FL_DRV_ERR_OUT_OF_RANGE;
+		EMSG("wsize is out of range. wsize=%zu", wsize);
+	}
+
+	check_sector_size = ((flash_addr) % (SECTOR_SIZE)) + wsize;
+
+	if (check_sector_size > SECTOR_SIZE) {
+		ret = FL_DRV_ERR_SECTOR_EXCEED;
+		EMSG("Sector exceeded. flash_addr=%x, wsize=%zu",
+			flash_addr, wsize);
+	}
+
+	if (ret == FL_DRV_OK) {
+		/* To write the according to device id */
+		ret = flash_control_ops.write((uintptr_t)buf,
+							flash_addr, wsize);
+	}
+
+	DMSG("ret=%d", ret);
+
+	return ret;
+}
+
+static uint32_t erase_flash_unsupported(uint32_t sector_addr)
+{
+	EMSG("Not execute erase. Unsupport device. sector_addr=%x",
+								sector_addr);
+	return FL_DRV_ERR_UNSUPPORT_DEV;
+}
+
+static uint32_t ext_addr_read_mode_flash_unsupported(uint32_t read_ext_top_addr,
+			uint32_t flash_addr, uint8_t *buf, size_t rsize)
+{
+	EMSG(
+	"Not execute ext_addr_read_mode. Unsupport device. read_ext_addr=%x",
+							read_ext_top_addr);
+	EMSG("flash_addr=%x , buf=%p, rsize=%zu", flash_addr, buf, rsize);
+	return FL_DRV_ERR_UNSUPPORT_DEV;
+}
+
+static uint32_t write_flash_unsupported(uint32_t buf_addr,
+					uint32_t flash_addr, uint32_t wsize)
+{
+	EMSG(
+	"Not execute write.Unsupport device.buf_addr=%x flash_addr=%x wsize=%d",
+		buf_addr, flash_addr, wsize);
+
+	return FL_DRV_ERR_UNSUPPORT_DEV;
+}
+
+static uint32_t init_rpc(void)
+{
+	uint32_t ret = FL_DRV_OK;
+	uint32_t dataL;
+
+	/* Set RPC clock mode */
+
+	dataL = 0x00000013;	/* RPC clock 80MHz */
+
+	*((volatile uint32_t *)CPG_CPGWPR)	= ~dataL;
+	*((volatile uint32_t *)CPG_RPCCKCR)	=  dataL;
+
+	soft_delay(1);		/* wait 1ms */
+
+	/* Reset RPC */
+
+	dataL = 0x00020000;	/* Bit17 RPC reset */
+
+	*((volatile uint32_t *)CPG_CPGWPR)	= ~dataL;
+	*((volatile uint32_t *)CPG_SRCR9)	=  dataL;
+	soft_delay(1);		/* wait 1ms (20us) */
+
+	*((volatile uint32_t *)CPG_CPGWPR)	= ~dataL;
+	*((volatile uint32_t *)CPG_SRSTCLR9)	=  dataL;
+	soft_delay(1);		/* wait 1ms (40us) */
+
+	return ret;
+}
diff --git a/core/arch/arm/plat-rcar/drivers/qspi_hyper_flash_common.c b/core/arch/arm/plat-rcar/drivers/qspi_hyper_flash_common.c
new file mode 100644
index 0000000..7d7658b
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/qspi_hyper_flash_common.c
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <kernel/tee_time.h>
+#include <tee/tee_svc.h>
+#include <drivers/qspi_hyper_flash.h>
+#include <trace.h>
+#include "qspi_hyper_flash_common.h"
+#include "qspi_flash_common.h"
+#include "hyper_flash_control.h"
+
+uint32_t common_wait_spi_transfer(uint32_t *dataL)
+{
+	uint32_t ret = FL_DEVICE_BUSY;
+
+	/* Wait for TEND = 1 */
+	*dataL = *((volatile uint32_t *)RPC_CMNSR);
+	if ((*dataL & BIT0) != 0U) {
+		ret = FL_DEVICE_READY;
+	}
+
+	return ret;
+}
+
+uint32_t common_wait(uint32_t (*read_status)(uint32_t *), uint32_t *data,
+						uint32_t timeout, uint32_t wait)
+{
+	uint32_t ret = FL_DRV_OK;
+	TEE_Result res;
+	uint32_t mytime;
+	TEE_Time base;
+	TEE_Time current;
+	uint32_t result;
+
+	res = tee_time_get_sys_time(&base);
+	if (res != TEE_SUCCESS) {
+		ret = FL_DRV_ERR_GET_SYS_TIME;
+		EMSG("get_sys_time:base res=%x", res);
+	} else {
+		while (ret == FL_DRV_OK) {
+
+			result = read_status(data);
+			if (result != FL_DEVICE_BUSY) {
+				break;
+			}
+
+			res = tee_time_get_sys_time(&current);
+			if (res != TEE_SUCCESS) {
+				ret = FL_DRV_ERR_GET_SYS_TIME;
+				EMSG("get_sys_time:current res=%x", res);
+			} else {
+				mytime = ((current.seconds - base.seconds)
+				     * 1000U) + (current.millis - base.millis);
+				if (mytime >= timeout) {
+					ret = FL_DRV_ERR_TIMEOUT;
+					EMSG("Time out of device status Ready");
+					break;
+				}
+				/*
+				 * continues for one ms.
+				 * over one ms is syscall_wait running.
+				 */
+				if (mytime > 1U) {
+					res = syscall_wait(wait);
+					if (res != TEE_SUCCESS) {
+						ret = FL_DRV_ERR_SYSCALL_WAIT;
+						EMSG("syscall_wait res=%x",
+									res);
+					}
+				}
+			}
+		}
+		if (result == FL_DEVICE_ERR) {
+			ret = FL_DRV_ERR_STATUS_INCORRECT;
+		}
+	}
+
+	return ret;
+}
+
+void soft_delay(uint32_t delay_ms)
+{
+	TEE_Result ret;
+	volatile int32_t loop;
+	TEE_Time start_time;
+	TEE_Time end_time;
+	uint32_t s;
+	uint32_t e;
+
+	ret = arm_cntpct_get_sys_time(&start_time);
+
+	if (ret == TEE_SUCCESS) {
+		s = start_time.seconds * 1000 + start_time.millis;
+		do {
+			for(loop = 0; loop < 10000; loop++); /* dummy loop */
+			ret = arm_cntpct_get_sys_time(&end_time);
+			if (ret == TEE_SUCCESS) {
+				e = end_time.seconds * 1000 + end_time.millis;
+			}
+		} while ((ret == TEE_SUCCESS) && ((e - s) < delay_ms));
+	}
+}
diff --git a/core/arch/arm/plat-rcar/drivers/qspi_hyper_flash_common.h b/core/arch/arm/plat-rcar/drivers/qspi_hyper_flash_common.h
new file mode 100644
index 0000000..e327002
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/qspi_hyper_flash_common.h
@@ -0,0 +1,187 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef QSPI_HYPER_FLASH_COMMON_H
+#define QSPI_HYPER_FLASH_COMMON_H
+
+#include <stdint.h>
+#include <string.h>
+#include <platform_config.h>
+
+/*
+ * Constant definition
+ */
+
+/* RCarH3_RPC  SPI Multi I/O Bus Controller (RPC) */
+/* Top of RPC memory space : 0x08000000-0x0BFFFFFF = 64MBytes */
+#define SPI_IOADDRESS_TOP	0x08000000U
+/* Common control register */
+#define RPC_CMNCR	(RPC_BASE + 0x0000U)
+/* Data read control register */
+#define RPC_DRCR	(RPC_BASE + 0x000CU)
+/* Data read command setting register */
+#define RPC_DRCMR	(RPC_BASE + 0x0010U)
+/* Data read enable setting register */
+#define RPC_DREAR	(RPC_BASE + 0x0014U)
+#define	RPC_DROPR	(RPC_BASE + 0x0018U)
+/* Data read enable setting register */
+#define RPC_DRENR	(RPC_BASE + 0x001CU)
+/* Manual mode control register */
+#define RPC_SMCR	(RPC_BASE + 0x0020U)
+/* Manual mode command setting register */
+#define RPC_SMCMR	(RPC_BASE + 0x0024U)
+/* Manual mode address setting register */
+#define RPC_SMADR	(RPC_BASE + 0x0028U)
+/* Manual mode option setting register */
+#define RPC_SMOPR	(RPC_BASE + 0x002CU)
+/* Manual mode enable setting register */
+#define RPC_SMENR	(RPC_BASE + 0x0030U)
+/* Manual mode read data register 0 */
+#define RPC_SMRDR0	(RPC_BASE + 0x0038U)
+/* Manual mode read data register 1 */
+#define RPC_SMRDR1	(RPC_BASE + 0x003CU)
+/* Manual mode write data register 0 */
+#define RPC_SMWDR0	(RPC_BASE + 0x0040U)
+/* Common status register */
+#define RPC_CMNSR	(RPC_BASE + 0x0048U)
+/* Data read dummy cycle setting register */
+#define RPC_DRDMCR	(RPC_BASE + 0x0058U)
+/* Data read DDR enable register */
+#define RPC_DRDRENR	(RPC_BASE + 0x005CU)
+/* Manual mode dummy cycle setting register */
+#define RPC_SMDMCR	(RPC_BASE + 0x0060U)
+/* Manual mode DDR enable register */
+#define RPC_SMDRENR	(RPC_BASE + 0x0064U)
+/* PHY control register */
+#define RPC_PHYCNT	(RPC_BASE + 0x007CU)
+/* Offset */
+#define RPC_OFFSET1	(RPC_BASE + 0x0080U)
+/* PHY interrupt register */
+#define RPC_PHYINT	(RPC_BASE + 0x0088U)
+
+#define CPG_CPGWPR	(0xE6150900U)
+#define CPG_RPCCKCR	(0xE6150238U)
+#define CPG_SRCR9	(0xE6150924U)
+#define CPG_SRSTCLR9	(0xE6150964U)
+
+/* device id */
+/* QSPI_ONBOARD : S25FS128S */
+#define QSPI_ONBOARD 0x00182001U
+/* QSPI_QUAD : S25FL512S */
+#define QSPI_QUAD 0x00200201U
+/* HyperFlash : S26KS512S */
+#define HYPER_FLASH 0x007E0001U
+/* Unsupport device */
+#define DEVICE_UNKNOWN 0xFFFFFFFFU
+
+/* Timeout / Wait time */
+/* HyperFlash : S26KS512S */
+#define HF_ERASE_TIMEOUT	3000U
+#define HF_READ_TIMEOUT		100U
+#define HF_WRITE_TIMEOUT	100U
+#define HF_ERASE_WAIT		200U
+#define HF_READ_WAIT		10U
+#define HF_WRITE_WAIT		10U
+
+/* QSPI onboard,quad : S25FS128S,S25FL512S */
+#define QSPI_ERASE_TIMEOUT	3000U
+#define QSPI_READ_TIMEOUT	100U
+#define QSPI_WRITE_TIMEOUT	100U
+#define QSPI_ERASE_WAIT		200U
+#define QSPI_READ_WAIT		10U
+#define QSPI_WRITE_WAIT		10U
+
+#define FL_DEVICE_BUSY		0U
+#define FL_DEVICE_READY		1U
+#define FL_DEVICE_ERR		2U
+
+/* HyperFlash write command control */
+#define HYPER_FL_UNLOCK1_ADD		0x555U
+#define HYPER_FL_UNLOCK1_DATA		((uint32_t)0xAAU << (uint32_t)24U)
+#define HYPER_FL_UNLOCK2_ADD		0x2AAU
+#define HYPER_FL_UNLOCK2_DATA		((uint32_t)0x55U << (uint32_t)24U)
+#define HYPER_FL_UNLOCK3_ADD		0x555U
+#define HYPER_FL_RESET_COM		((uint32_t)0xF0U << (uint32_t)24U)
+#define	HYPER_FL_WORD_PROGRAM_COM	((uint32_t)0xA0U << (uint32_t)24U)
+#define HYPER_FL_ID_ENTRY_COM		((uint32_t)0x90U << (uint32_t)24U)
+#define	HYPER_FL_RD_STATUS_COM		((uint32_t)0x70U << (uint32_t)24U)
+#define HYPER_FL_ERASE_1ST_COM		((uint32_t)0x80U << (uint32_t)24U)
+#define HYPER_FL_SECTOR_ERASE_COM	((uint32_t)0x30U << (uint32_t)24U)
+/* SMADR Register address */
+#define HYPER_FL_SMADR_TOP_ADD		0x00000000U
+
+/* QSPI Flash write command control */
+/*Write Enable command */
+#define QSPI_FL_COMMAND_WRITE_ENABLE	0x00060000U
+
+/* bit code for mask */
+#define BIT0	((uint32_t)0x00000001U)
+#define BIT1	((uint32_t)0x00000002U)
+#define BIT5	((uint32_t)0x00000020U)
+#define BIT7	((uint32_t)0x00000080U)
+#define EXT_ADDR_MASK	((uint32_t)0xFC000000U)
+
+/* Volatile Status and Configuration Registers (CR3V) */
+#define SPIREG_CR3V	0x00800004U
+
+/* read byte count, offset byte count */
+#define FLASH_DATA_READ_BYTE_COUNT_2	2U
+#define FLASH_DATA_READ_BYTE_COUNT_4	4U
+#define FLASH_DATA_READ_BYTE_COUNT_8	8U
+#define FLASH_DATA_OFFSET_BYTE_8	8U
+
+/* bit shift count */
+#define FLASH_DATA_BIT_SHIFT_8		8U
+#define EXT_ADDR_BIT_SHIFT_9		9U
+
+/* access size */
+#define WORD_SIZE		0x00000004U
+#define WRITE_BUFF_SIZE		0x00000100U
+#define ERASE_SIZE_256KB	0x00040000U
+#define ERASE_SIZE_64KB		0x00010000U
+#define EXT_ADD_BORDER_SIZE_64MB 0x04000000U
+
+/* read_sector_size_bit on/off flag */
+#define READ_SECTOR_SIZE_BIT_OFF	0U
+#define READ_SECTOR_SIZE_BIT_ON		1U
+/*
+ * Global variable declaration
+ */
+struct flash_control_operations {
+	uint32_t (*erase)(uint32_t sector_addr);
+	uint32_t (*set_ext_addr_read_mode)(uint32_t read_ext_top_addr,
+			uint32_t r_flash_addr, uint8_t *buf, size_t rsize);
+	uint32_t (*write)(uint32_t buf_addr,
+				uint32_t flash_addr, uint32_t wsize);
+};
+
+uint32_t common_wait_spi_transfer(uint32_t *dataL);
+uint32_t common_wait(uint32_t (*read_status)(uint32_t *), uint32_t *data,
+					uint32_t timeout, uint32_t wait);
+void soft_delay(uint32_t delay_ms);
+
+#endif /* QSPI_HYPER_FLASH_COMMON_H */
diff --git a/core/arch/arm/plat-rcar/drivers/qspi_onboard_control.c b/core/arch/arm/plat-rcar/drivers/qspi_onboard_control.c
new file mode 100644
index 0000000..7c60a0e
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/qspi_onboard_control.c
@@ -0,0 +1,555 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include <trace.h>
+#include <drivers/qspi_hyper_flash.h>
+
+#include "qspi_hyper_flash_common.h"
+#include "qspi_flash_common.h"
+#include "qspi_onboard_control.h"
+
+static uint32_t qspi_onboard_erase_main(uint32_t sector_addr);
+static uint32_t qspi_onboard_set_ext_addr_read_mode(uint32_t read_ext_top_addr,
+			uint32_t r_flash_addr, uint8_t *buf, size_t rsize);
+static uint32_t qspi_onboard_write_main(uint32_t buf_addr,
+					uint32_t flash_addr, uint32_t wsize);
+static uint32_t qspi_onboard_set_sector_erase_size(uint32_t sector_size_bit);
+static uint32_t qspi_onboard_read_register_data(uint32_t manual_set_addr,
+						uint8_t *read_register_data);
+static uint32_t qspi_onboard_read_flash_data4Byte(uint32_t readFlAddr,
+							uint32_t *readData);
+static uint32_t qspi_onboard_request_write_buffer(uint32_t flash_addr,
+						uint32_t write_data_addr);
+static uint32_t qspi_onboard_write_buffer(uint32_t manual_set_addr,
+						uint32_t write_data_addr);
+static uint32_t qspi_onboard_write_register_data(uint32_t manual_set_addr,
+						uint8_t write_data);
+
+static uint32_t qspi_onboard_erase_main(uint32_t sector_addr)
+{
+	uint32_t sector_size_bit = BIT1;
+	uint32_t sector_size = SECTOR_SIZE;
+	uint32_t ret;
+
+	switch (sector_size) {
+	/* sector size is 64KB. */
+	case ERASE_SIZE_64KB:
+		sector_size_bit = ~sector_size_bit;
+		break;
+	default:
+		DMSG("SECTOR_SIZE =%x", SECTOR_SIZE);
+		break;
+	}
+
+	ret = qspi_onboard_set_sector_erase_size(sector_size_bit);
+	if (ret == FL_DRV_OK) {
+		ret = qspi_common_erase_control(sector_addr);
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_onboard_set_ext_addr_read_mode(uint32_t read_ext_top_addr,
+			uint32_t r_flash_addr, uint8_t *buf, size_t rsize)
+{
+/*
+ * for OnBoard QspiFlash(S25FS128S)
+ * FAST_READ 0Bh (CR2V[7]=0) is followed by a 3-byte address
+ */
+	uint32_t readFlAddr;
+	uint32_t readData;
+	uint32_t DREAR_value;
+	uint32_t ret = FL_DRV_OK;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x01FFF300U;
+	*((volatile uint32_t *)RPC_DRCR)	=	0x001F0100U;
+	/*
+	 * bit20-16 RBURST[4:0] = 11111 : 32 continuous data unit
+	 * bit8     RBE         =     1 : Burst read
+	 */
+
+	*((volatile uint32_t *)RPC_DRCMR)	=	0x000B0000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x0B : FAST_READ 0Bh
+	 */
+	DREAR_value = (read_ext_top_addr >> EXT_ADDR_BIT_SHIFT_9);
+	*((volatile uint32_t *)RPC_DREAR)	=	DREAR_value;
+	/*
+	 * bit23-16 EAV[7:0]   = ADR[32:25]      : set
+	 * bit2-0   EAC[2:0]   = 000  : ADR[24:0 ] Enable
+	 */
+
+	*((volatile uint32_t *)RPC_DROPR)	=	0x00000000U;
+	/*
+	 * bit31-24 OPD3[7:0]  = H'0  : Option Data 3 (Set Mode)
+	 */
+
+	*((volatile uint32_t *)RPC_DRENR)	=	0x0000C700U;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 DRDB[1:0]  =   00 : 1bit width transfer data (QSPI0_IO0-3)
+	 * bit15    DME        =    1 : dummy cycle enable
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 0111 : ADR[23:0] output (24 Bit Address)
+	 */
+
+	*((volatile uint32_t *)RPC_DRDMCR)	=	0x00000007U;
+	/* 8 cycle dummy
+	 * bit17-16 DMCYC[2:0] =  10 : 4 bit width
+	 * bit2-0 DMCYC[2:0]   = 111 : 8 cycle dummy wait
+	 * bit2-0 DMCYC[2:0]   = 011 : 4 cycle dummy wait
+	 */
+
+	*((volatile uint32_t *)RPC_DRDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 DRDRE  = 0 : DATA SDR transfer
+	 */
+
+	/* Output read data */
+	for (readFlAddr = r_flash_addr;
+		readFlAddr < (r_flash_addr+rsize);
+		readFlAddr += FLASH_DATA_READ_BYTE_COUNT_4) {
+
+		ret = qspi_onboard_read_flash_data4Byte(readFlAddr, &readData);
+		(void)memcpy(buf, &readData, FLASH_DATA_READ_BYTE_COUNT_4);
+		buf += FLASH_DATA_READ_BYTE_COUNT_4;
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_onboard_write_main(uint32_t buf_addr,
+					uint32_t flash_addr, uint32_t wsize)
+{
+	uint32_t wbuf_size;
+	uint32_t wcount;
+	uint32_t write_num;
+	uint32_t rest_wsize;
+	uint32_t work_flash_addr;
+	uint32_t write_data_addr;
+	uint32_t work_flash_256top;
+	uint32_t w_offset;
+	uint8_t wbuff[WRITE_BUFF_SIZE];
+	uintptr_t uptr_wbuff;
+	volatile uintptr_t v_flash_addr = flash_addr;
+	uint8_t *p_flash_addr;
+	uint32_t ret = FL_DRV_OK;
+
+	write_data_addr = buf_addr;
+	work_flash_addr = flash_addr;
+	write_num = wsize / WRITE_BUFF_SIZE;
+	rest_wsize = wsize % WRITE_BUFF_SIZE;
+	if (rest_wsize > 0U) {
+		write_num++;
+	}
+
+	/* RPC Write Buffer size : 256byte , and rest size writing */
+	for (wcount = 0U; wcount < write_num; wcount++) {
+		if (wcount == (write_num - 1U)) {
+			if (rest_wsize > 0U) {
+				wbuf_size = rest_wsize;
+				work_flash_256top =
+					(work_flash_addr / WRITE_BUFF_SIZE) *
+								WRITE_BUFF_SIZE;
+				(void)memset(wbuff, 0xffU, WRITE_BUFF_SIZE);
+				w_offset = work_flash_addr - work_flash_256top;
+				v_flash_addr = write_data_addr;
+				p_flash_addr = (uint8_t *)v_flash_addr;
+				(void)memcpy(wbuff+w_offset, p_flash_addr,
+								wbuf_size);
+				uptr_wbuff = (uintptr_t)wbuff;
+				ret = qspi_onboard_request_write_buffer(
+					work_flash_256top, uptr_wbuff);
+				break;
+			}
+		}
+		ret = qspi_onboard_request_write_buffer(work_flash_addr,
+							write_data_addr);
+		work_flash_addr += WRITE_BUFF_SIZE;
+		write_data_addr += WRITE_BUFF_SIZE;
+	}
+
+	return ret;
+}
+
+void qspi_onboard_set_control_ops(struct flash_control_operations *ops)
+{
+	ops->erase = qspi_onboard_erase_main;
+	ops->set_ext_addr_read_mode = qspi_onboard_set_ext_addr_read_mode;
+	ops->write = qspi_onboard_write_main;
+}
+
+static uint32_t qspi_onboard_set_sector_erase_size(uint32_t sector_size_bit)
+{
+/*
+ * Qspi:Set Sector Erase size (CR3V[1]=1   0:64kb 1:256kb)
+ */
+	uint8_t register_data = 0U;
+	uint32_t read_status = 0U;
+	uint8_t read_sector_size_bit;
+	uint8_t set_register = READ_SECTOR_SIZE_BIT_ON;
+	uint32_t ret;
+
+	ret = qspi_onboard_read_register_data(SPIREG_CR3V, &register_data);
+
+	read_sector_size_bit = (uint8_t)(register_data & BIT1);
+
+	if ((read_sector_size_bit == BIT1) && (sector_size_bit == ~BIT1)) {
+		/* setting pattern is [64kb] sector erase size */
+		register_data = register_data & (uint8_t)sector_size_bit;
+	} else if ((read_sector_size_bit == 0U) && (sector_size_bit == BIT1)) {
+		/* setting pattern is [256kb] sector erase size  */
+		register_data = register_data | (uint8_t)sector_size_bit;
+	} else {
+		set_register = READ_SECTOR_SIZE_BIT_OFF;
+	}
+
+	if (set_register == READ_SECTOR_SIZE_BIT_ON) {
+		if (ret == FL_DRV_OK) {
+		/* WRITE ENABLE */
+			ret = qspi_common_set_command(
+						QSPI_FL_COMMAND_WRITE_ENABLE);
+		}
+		/* Bit1=Block Erase Size  1:256KB , 0:64KB */
+
+		if (ret == FL_DRV_OK) {
+			ret = qspi_onboard_write_register_data(SPIREG_CR3V,
+								register_data);
+		}
+
+		if (ret == FL_DRV_OK) {
+			ret = common_wait(qspi_common_read_device_status,
+					&read_status, QSPI_ERASE_TIMEOUT,
+					QSPI_ERASE_WAIT);
+		}
+
+	}
+	return ret;
+}
+
+static uint32_t qspi_onboard_read_register_data(uint32_t manual_set_addr,
+						uint8_t *read_register_data)
+{
+/*
+ * For OnBoard QspiFlash(S25FS128S)
+ * 65h Read Any Register command (RADR 65h)
+ * Add24bit,Data8bit
+ */
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00650000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x65 : Read Any Register command (RADR 65h)
+	 */
+
+	*((volatile uint32_t *)RPC_SMADR)	=	manual_set_addr;
+	*((volatile uint32_t *)RPC_SMDMCR)	=	0x00000007U;
+	/*
+	 * bit2-0 DMCYC[2:0] = 111 : 8 cycle dummy wait
+	 */
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x0000C708U;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   00 : 1bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    1 : dummy cycle enable
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 0111 : ADR[23:0] output (24 Bit Address)
+	 * bit3-0   SPIDE[3:0] = 1000 : 8bit transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000005U;
+	/*
+	 * bit2     SPIRE      = 1 : Data read enable
+	 * bit1     SPIWE      = 0 : Data write disable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_READ_TIMEOUT, QSPI_READ_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		/* read data[7:0] */
+		*read_register_data   = *((volatile uint8_t *)RPC_SMRDR0);
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_onboard_read_flash_data4Byte(uint32_t readFlAddr,
+							uint32_t *readData)
+{
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)    = 0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+	*((volatile uint32_t *)RPC_CMNCR)      = 0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+	*((volatile uint32_t *)RPC_SMCMR)      = 0x000C0000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x0C : Fast Read command (4FAST_READ 0Ch)
+	 */
+	*((volatile uint32_t *)RPC_SMADR)      = readFlAddr;
+	*((volatile uint32_t *)RPC_SMDMCR)     = 0x00000007U;
+	/*
+	 * bit2-0 DMCYC[2:0] = 111 : 8 cycle dummy wait
+	 */
+	*((volatile uint32_t *)RPC_SMDRENR)    = 0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+	*((volatile uint32_t *)RPC_SMENR)      = 0x0000CF0FU;
+	/* bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   00 : 1bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    1 : dummy cycle enable
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 1111 : ADR[31:0] output (32 Bit Address)
+	 * bit3-0   SPIDE[3:0] = 1111 : 32bit transfer
+	 */
+	*((volatile uint32_t *)RPC_SMCR)       = 0x00000005U;
+	/*
+	 * bit2     SPIRE      = 1 : Data read enable
+	 * bit1     SPIWE      = 0 : Data write disable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_READ_TIMEOUT, QSPI_READ_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		/* read data[31:0] */
+		*readData = *((volatile uint32_t *)RPC_SMRDR0);
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_onboard_request_write_buffer(uint32_t flash_addr,
+						uint32_t write_data_addr)
+{
+	uint32_t read_status = 0U;
+	uint32_t ret;
+
+	/* WRITE ENABLE */
+	ret = qspi_common_set_command(QSPI_FL_COMMAND_WRITE_ENABLE);
+
+	if (ret == FL_DRV_OK) {
+		ret = qspi_onboard_write_buffer(flash_addr, write_data_addr);
+	}
+
+	if (ret == FL_DRV_OK) {
+		ret = common_wait(qspi_common_read_device_status, &read_status,
+					QSPI_WRITE_TIMEOUT, QSPI_WRITE_WAIT);
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_onboard_write_buffer(uint32_t manual_set_addr,
+						uint32_t write_data_addr)
+{
+	uintptr_t offset;
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_DRCR)	=	0x01FF0301U;
+	/*
+	 * bit9   RCF         =  1 : Read Cache Clear
+	 */
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000274U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit2   WBUF        =  1 : Write Buffer Enable
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	for (offset = 0U; offset < WRITE_BUFF_SIZE;
+						offset = offset + WORD_SIZE) {
+		(*(volatile uint32_t *)(0xEE208000U+offset)) =
+			(*(volatile uint32_t *)(write_data_addr+offset));
+	}
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00020000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x02 : Page Program 3-byte address
+	 */
+
+	*((volatile uint32_t *)RPC_SMADR)	=	manual_set_addr;
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x0000470FU;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   00 : 1bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    0 : No dummy cycle
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 0111 : ADR[23:0] is output
+	 * bit3-0   SPIDE[3:0] = 1111 : 32bit transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000003U;
+	/*
+	 * bit2     SPIRE      = 0 : Data read disable
+	 * bit1     SPIWE      = 1 : Data write enable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_WRITE_TIMEOUT, QSPI_WRITE_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		*((volatile uint32_t *)RPC_PHYCNT)	=	0x00000273U;
+		/*
+		 * bit31  CAL         =  0 : No PHY calibration
+		 * bit2   WBUF        =  0 : Write Buffer Disable
+		 * bit1-0 PHYMEM[1:0] = 11 : HyperFlash
+		 */
+
+		*((volatile uint32_t *)RPC_DRCR)	=	0x01FF0301U;
+		/*
+		 * bit9   RCF         =  1 : Read Cache Clear
+		 */
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_onboard_write_register_data(uint32_t manual_set_addr,
+						uint8_t write_data)
+{
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00710000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x71 : Write Any Register Command  (WRAR)
+	 */
+
+	*((volatile uint32_t *)RPC_SMADR)	=	manual_set_addr;
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x00004708U;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   00 : 1bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    0 : No dummy cycle
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 0111 : ADR[24:0] is output
+	 * bit3-0   SPIDE[3:0] = 1000 : 8bit transfer
+	 */
+
+	*((volatile uint8_t *)RPC_SMWDR0)	=	write_data;
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000003U;
+	/*
+	 * bit2     SPIRE      = 0 : Data read disable
+	 * bit1     SPIWE      = 1 : Data write enable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_WRITE_TIMEOUT, QSPI_WRITE_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		*((volatile uint32_t *)RPC_PHYCNT)	=	0x00000273U;
+		/*
+		 * bit31  CAL         =  0 : No PHY calibration
+		 * bit2   WBUF        =  0 : Write Buffer Disable
+		 * bit1-0 PHYMEM[1:0] = 11 : HyperFlash
+		 */
+
+		*((volatile uint32_t *)RPC_DRCR)	=	0x01FF0301U;
+		/*
+		 * bit9   RCF         =  1 : Read Cache Clear
+		 */
+	}
+
+	return ret;
+}
diff --git a/core/arch/arm/plat-rcar/drivers/qspi_onboard_control.h b/core/arch/arm/plat-rcar/drivers/qspi_onboard_control.h
new file mode 100644
index 0000000..9e2d87e
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/qspi_onboard_control.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef QSPI_ONBOARD_CONTROL_H
+#define QSPI_ONBOARD_CONTROL_H
+
+#include "qspi_hyper_flash_common.h"
+
+void qspi_onboard_set_control_ops(struct flash_control_operations *ops);
+
+#endif /* QSPI_ONBOARD_CONTROL_H */
diff --git a/core/arch/arm/plat-rcar/drivers/qspi_quad_control.c b/core/arch/arm/plat-rcar/drivers/qspi_quad_control.c
new file mode 100644
index 0000000..32e8c1d
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/qspi_quad_control.c
@@ -0,0 +1,540 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include <drivers/qspi_hyper_flash.h>
+
+#include "qspi_hyper_flash_common.h"
+#include "qspi_flash_common.h"
+#include "qspi_quad_control.h"
+
+static uint32_t qspi_quad_erase_control(uint32_t sector_addr);
+static uint32_t qspi_quad_read_flash_data4Byte(uint32_t readFlAddr,
+							uint32_t *readData);
+static uint32_t qspi_quad_set_ext_addr_read_mode(uint32_t read_ext_top_addr,
+			uint32_t r_flash_addr, uint8_t *buf, size_t rsize);
+static uint32_t qspi_quad_write_main(uint32_t buf_addr, uint32_t flash_addr,
+								uint32_t wsize);
+static uint32_t qspi_quad_set_quad_mode(void);
+static uint32_t qspi_quad_read_config(uint32_t *read_cnfig);
+static uint32_t qspi_quad_request_write_buffer(uint32_t flash_addr,
+						uint32_t write_data_addr);
+static uint32_t qspi_quad_write_buffer(uint32_t manual_set_addr,
+						uint32_t write_data_addr);
+static uint32_t qspi_quad_write_register_status_config(uint32_t write_status,
+						uint32_t write_config);
+
+static uint32_t qspi_quad_erase_control(uint32_t sector_addr)
+{
+/*
+ * Qspi:Sector Erase
+ */
+	uint32_t ret;
+
+	ret = qspi_common_erase_control(sector_addr);
+	return ret;
+}
+
+static uint32_t qspi_quad_read_flash_data4Byte(uint32_t readFlAddr,
+							uint32_t *readData)
+{
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)    = 0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+	*((volatile uint32_t *)RPC_CMNCR)      = 0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+	*((volatile uint32_t *)RPC_SMCMR)      = 0x006C0000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x6C : Quad Output Read (4QOR 6Ch)
+	 */
+	*((volatile uint32_t *)RPC_SMADR)      = readFlAddr;
+	*((volatile uint32_t *)RPC_SMDMCR)     = 0x00000007U;
+	/*
+	 * bit2-0 DMCYC[2:0] = 111 : 8 cycle dummy wait
+	 */
+	*((volatile uint32_t *)RPC_SMDRENR)    = 0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+	*((volatile uint32_t *)RPC_SMENR)      = 0x0002CF0FU;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   10 : 1bit width transfer data (QSPI0_IO0-3)
+	 * bit15    DME        =    1 : dummy cycle enable
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 1111 : ADR[31:0] output (32 Bit Address)
+	 * bit3-0   SPIDE[3:0] = 1111 : 32bit transfer
+	 */
+	*((volatile uint32_t *)RPC_SMCR)       = 0x00000005U;
+	/*
+	 * bit2     SPIRE      = 1 : Data read enable
+	 * bit1     SPIWE      = 0 : Data write disable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_READ_TIMEOUT, QSPI_READ_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		/* read data[31:0] */
+		*readData = *((volatile uint32_t *)RPC_SMRDR0);
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_quad_set_ext_addr_read_mode(uint32_t read_ext_top_addr,
+			uint32_t r_flash_addr, uint8_t *buf, size_t rsize)
+{
+	uint32_t readFlAddr;
+	uint32_t readData;
+	uint32_t DREAR_value;
+	uint32_t ret = FL_DRV_OK;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x01FFF300U;
+	*((volatile uint32_t *)RPC_DRCR)	=	0x001F0100U;
+	/*
+	 * bit20-16 RBURST[4:0] = 11111 : 32 continuous data unit
+	 * bit8     RBE         =     1 : Burst read
+	 */
+
+	*((volatile uint32_t *)RPC_DRCMR)	=	0x000C0000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x0C :
+	 *                      4FAST_READ 0Ch Command 4-byte address command
+	 */
+	DREAR_value = (read_ext_top_addr >> EXT_ADDR_BIT_SHIFT_9);
+	*((volatile uint32_t *)RPC_DREAR)   =	(DREAR_value | 0x00000001U);
+	/*
+	 * bit23-16 EAV[7:0]   = ADR[32:26]      : set
+	 * bit2-0   EAC[2:0]   = 001  : ADR[25:0 ] Enable
+	 */
+
+	*((volatile uint32_t *)RPC_DRENR)	=	0x0000CF00U;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 DRDB[1:0]  =   00 : 1bit width transfer data (QSPI0_IO0)
+	 * bit15    DME        =    1 : dummy cycle enable
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 1111 : ADR[23:0] output (24 Bit Address)
+	 */
+
+	*((volatile uint32_t *)RPC_DRDMCR)	=	0x00000007U;
+	/*
+	 * bit2-0 DMCYC[2:0]   = 111 : 8 cycle dummy wait
+	 */
+
+	*((volatile uint32_t *)RPC_DRDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 DRDRE  = 0 : DATA SDR transfer
+	 */
+
+	/* Output read data */
+	for (readFlAddr = r_flash_addr;
+		readFlAddr < (r_flash_addr+rsize);
+		readFlAddr += FLASH_DATA_READ_BYTE_COUNT_4) {
+
+		ret = qspi_quad_read_flash_data4Byte(readFlAddr, &readData);
+		(void)memcpy(buf, &readData, FLASH_DATA_READ_BYTE_COUNT_4);
+		buf += FLASH_DATA_READ_BYTE_COUNT_4;
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_quad_write_main(uint32_t buf_addr, uint32_t flash_addr,
+								uint32_t wsize)
+{
+	uint32_t wbuf_size;
+	uint32_t wcount;
+	uint32_t write_num;
+	uint32_t rest_wsize;
+	uint32_t work_flash_addr;
+	uint32_t write_data_addr;
+	uint32_t work_flash_256top;
+	uint32_t w_offset;
+	uint8_t wbuff[WRITE_BUFF_SIZE];
+	uintptr_t uptr_wbuff;
+	volatile uintptr_t v_flash_addr = flash_addr;
+	uint8_t *p_flash_addr;
+	uint32_t ret = FL_DRV_OK;
+
+	write_data_addr = buf_addr;
+	work_flash_addr = flash_addr;
+	write_num = wsize / WRITE_BUFF_SIZE;
+	rest_wsize = wsize % WRITE_BUFF_SIZE;
+	if (rest_wsize > 0U) {
+		write_num++;
+	}
+
+	/* RPC Write Buffer size : 256byte , and rest size writing */
+	for (wcount = 0U; wcount < write_num; wcount++) {
+		if (wcount == (write_num - 1U)) {
+			if (rest_wsize > 0U) {
+				wbuf_size = rest_wsize;
+				work_flash_256top =
+					(work_flash_addr / WRITE_BUFF_SIZE) *
+								WRITE_BUFF_SIZE;
+				(void)memset(wbuff, 0xffU, WRITE_BUFF_SIZE);
+				w_offset = work_flash_addr - work_flash_256top;
+				v_flash_addr = write_data_addr;
+				p_flash_addr = (uint8_t *)v_flash_addr;
+				(void)memcpy(wbuff+w_offset, p_flash_addr,
+								wbuf_size);
+				uptr_wbuff = (uintptr_t)wbuff;
+				ret = qspi_quad_request_write_buffer(
+					work_flash_256top, uptr_wbuff);
+				break;
+			}
+		}
+		ret = qspi_quad_request_write_buffer(work_flash_addr,
+							write_data_addr);
+		work_flash_addr += WRITE_BUFF_SIZE;
+		write_data_addr += WRITE_BUFF_SIZE;
+	}
+
+	return ret;
+}
+
+void qspi_quad_set_control_ops(struct flash_control_operations *ops)
+{
+	ops->erase = qspi_quad_erase_control;
+	ops->set_ext_addr_read_mode = qspi_quad_set_ext_addr_read_mode;
+	ops->write = qspi_quad_write_main;
+}
+
+static uint32_t qspi_quad_set_quad_mode(void)
+{
+	uint32_t status = 0U;
+	uint32_t config = 0U;
+	uint32_t read_status = 0U;
+	uint32_t ret;
+
+	ret = qspi_quad_read_config(&config);
+
+	if (ret == FL_DRV_OK) {
+		if ((config & BIT1) == 0U) {
+			/* WRITE ENABLE */
+			ret = qspi_common_set_command(
+						QSPI_FL_COMMAND_WRITE_ENABLE);
+			if (ret == FL_DRV_OK) {
+				ret = common_wait(
+					qspi_common_read_device_status,
+ 					&read_status, QSPI_WRITE_TIMEOUT,
+					QSPI_WRITE_WAIT);
+			}
+			if (ret == FL_DRV_OK) {
+				/* set QUAD=1 */
+				config |= BIT1;
+				ret = qspi_quad_write_register_status_config(
+									status,
+									config);
+			}
+			if (ret == FL_DRV_OK) {
+				ret = common_wait(
+					qspi_common_read_device_status,
+					&read_status, QSPI_WRITE_TIMEOUT,
+					QSPI_WRITE_WAIT);
+			}
+		}
+	}
+	return ret;
+}
+
+static uint32_t qspi_quad_read_config(uint32_t *read_cnfig)
+{
+	uint8_t read_data;
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	/*
+	 * Manual mode / No dummy / On Command /
+	 *                              No Address /  Data:8bit transfer
+	 */
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00350000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x35 : Read Configuration Register (CFG)
+	 */
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x00004008U;
+	/*
+	 * bit15    DME        =    0 : No dummy cycle
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 0000 : Address output disable
+	 * bit3-0   SPIDE[3:0] = 1000 : 8bit transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000005U;
+	/*
+	 * bit2     SPIRE      = 1 : Data read enable
+	 * bit1     SPIWE      = 0 : Data write disable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_READ_TIMEOUT, QSPI_READ_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		/* read data[7:0] */
+		read_data    = *((volatile uint8_t *)RPC_SMRDR0);
+		*read_cnfig  = read_data;
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_quad_request_write_buffer(uint32_t flash_addr,
+						uint32_t write_data_addr)
+{
+	uint32_t read_status = 0U;
+	uint32_t ret;
+
+	ret = qspi_quad_set_quad_mode();
+
+	if (ret == FL_DRV_OK) {
+		/* WRITE ENABLE */
+		ret = qspi_common_set_command(QSPI_FL_COMMAND_WRITE_ENABLE);
+	}
+
+	if (ret == FL_DRV_OK) {
+		ret = qspi_quad_write_buffer(flash_addr, write_data_addr);
+	}
+
+	if (ret == FL_DRV_OK) {
+		ret = common_wait(qspi_common_read_device_status, &read_status,
+					QSPI_WRITE_TIMEOUT, QSPI_WRITE_WAIT);
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_quad_write_buffer(uint32_t manual_set_addr,
+						uint32_t write_data_addr)
+{
+	uintptr_t offset;
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_DRCR)	=	0x01FF0301U;
+	/*
+	 * bit9   RCF         =  1 : Read Cache Clear
+	 */
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000274U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit2   WBUF        =  1 : Write Buffer Enable
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	for (offset = 0U; offset < WRITE_BUFF_SIZE;
+						offset = offset + WORD_SIZE) {
+		(*(volatile uint32_t *)(0xEE208000U+offset)) =
+			(*(volatile uint32_t *)(write_data_addr+offset));
+	}
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00340000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x34 : Quad Page Program 4-byte address
+	 */
+
+	*((volatile uint32_t *)RPC_SMADR)	=	manual_set_addr;
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x00024F0FU;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   10 : 4bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    0 : No dummy cycle
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 1111 : ADR[23:0] is output
+	 * bit3-0   SPIDE[3:0] = 1111 : 32bit transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000003U;
+	/*
+	 * bit2     SPIRE      = 0 : Data read disable
+	 * bit1     SPIWE      = 1 : Data write enable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_WRITE_TIMEOUT, QSPI_WRITE_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		*((volatile uint32_t *)RPC_PHYCNT)	=	0x00000273U;
+		/*
+		 * bit31  CAL         =  0 : No PHY calibration
+		 * bit2   WBUF        =  0 : Write Buffer Disable
+		 * bit1-0 PHYMEM[1:0] = 11 : HyperFlash
+		 */
+
+		*((volatile uint32_t *)RPC_DRCR)	=	0x01FF0301U;
+		/*
+		 * bit9   RCF         =  1 : Read Cache Clear
+		 */
+	}
+
+	return ret;
+}
+
+static uint32_t qspi_quad_write_register_status_config(uint32_t write_status,
+						uint32_t write_config)
+{
+	uint32_t ret;
+	uint32_t status = 0U;
+
+	*((volatile uint32_t *)RPC_PHYCNT)	=	0x80000260U;
+	/*
+	 * bit31  CAL         =  1 : PHY calibration
+	 * bit1-0 PHYMEM[1:0] = 00 : QSPI-SDR
+	 */
+
+	*((volatile uint32_t *)RPC_CMNCR)	=	0x81FFF300U;
+	/*
+	 * bit31  MD       =  1 : Manual mode
+	 * bit1-0 BSZ[1:0] = 00 : QSPI Flash x 1
+	 */
+
+	*((volatile uint32_t *)RPC_SMCMR)	=	0x00010000U;
+	/*
+	 * bit23-16 CMD[7:0] = 0x01 : Write (Status & Configuration) Register
+	 */
+
+	*((volatile uint32_t *)RPC_SMDRENR)	=	0x00000000U;
+	/*
+	 * bit8 ADDRE  = 0 : Address SDR transfer
+	 * bit0 SPIDRE = 0 : DATA SDR transfer
+	 */
+
+	*((volatile uint32_t *)RPC_SMENR)	=	0x00004008U;
+	/*
+	 * bit31-30 CDB[1:0]   =   00 : 1bit width command (QSPI0_MOSI)
+	 * bit25-24 ADB[1:0]   =   00 : 1bit width address (QSPI0_MOSI)
+	 * bit17-16 SPIDB[1:0] =   00 : 1bit width transfer data (QSPI0_MISO)
+	 * bit15    DME        =    0 : No dummy cycle
+	 * bit14    CDE        =    1 : Command enable
+	 * bit11-8  ADE[3:0]   = 0000 : ADR[23:0] is disable
+	 * bit3-0   SPIDE[3:0] = 1000 : 8bit transfer
+	 */
+
+	/* First ByteData */
+	*((volatile uint8_t *)RPC_SMWDR0) =
+					(volatile uint8_t)write_status;
+	*((volatile uint32_t *)RPC_SMCR)	=	0x00000103U;
+	/*
+	 * bit8     SSLKP      = 1 : SSL After the transfer assert continue
+	 * bit2     SPIRE      = 0 : Data read disable
+	 * bit1     SPIWE      = 1 : Data write enable
+	 * bit0     SPIE       = 1 : SPI transfer start
+	 */
+
+	ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_WRITE_TIMEOUT, QSPI_WRITE_WAIT);
+
+	if (ret == FL_DRV_OK) {
+		/* Second ByteData */
+		*((volatile uint32_t *)RPC_SMENR)	=	0x00000008U;
+		/*
+		 * bit3-0   SPIDE[3:0] = 1000 : 8bit transfer
+		 */
+
+		*((volatile uint8_t *)RPC_SMWDR0) =
+					(volatile uint8_t)write_config;
+		*((volatile uint32_t *)RPC_SMCR)	=	0x00000003U;
+		/*
+		 * bit8     SSLKP      = 0 : SSL After the transfer negated
+		 * bit2     SPIRE      = 0 : Data read disable
+		 * bit1     SPIWE      = 1 : Data write enable
+		 * bit0     SPIE       = 1 : SPI transfer start
+		 */
+	}
+
+	if (ret == FL_DRV_OK) {
+		ret = common_wait(common_wait_spi_transfer, &status,
+					QSPI_WRITE_TIMEOUT, QSPI_WRITE_WAIT);
+
+		*((volatile uint32_t *)RPC_PHYCNT)	=	0x00000273U;
+		/*
+		 * bit31  CAL         =  0 : No PHY calibration
+		 * bit2   WBUF        =  0 : Write Buffer Disable
+		 * bit1-0 PHYMEM[1:0] = 11 : HyperFlash
+		 */
+
+		*((volatile uint32_t *)RPC_DRCR)	=	0x01FF0301U;
+		/*
+		 * bit9   RCF         =  1 : Read Cache Clear
+		 */
+	}
+
+	return ret;
+}
diff --git a/core/arch/arm/plat-rcar/drivers/qspi_quad_control.h b/core/arch/arm/plat-rcar/drivers/qspi_quad_control.h
new file mode 100644
index 0000000..ca7e74e
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/qspi_quad_control.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef QSPI_QUAD_CONTROL_H
+#define QSPI_QUAD_CONTROL_H
+
+#include "qspi_hyper_flash_common.h"
+
+void qspi_quad_set_control_ops(struct flash_control_operations *ops);
+
+#endif /* QSPI_QUAD_CONTROL_H */
diff --git a/core/arch/arm/plat-rcar/drivers/sub.mk b/core/arch/arm/plat-rcar/drivers/sub.mk
new file mode 100644
index 0000000..4c72f72
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/sub.mk
@@ -0,0 +1,9 @@
+global-incdirs-y += .
+srcs-$(CFG_SWDT) += swdt_driver.c
+srcs-$(CFG_MFIS) += mfis_driver.c
+srcs-$(CFG_HYPER_FLASH) += qspi_hyper_flash_common.c
+srcs-$(CFG_HYPER_FLASH) += qspi_hyper_flash.c
+srcs-$(CFG_HYPER_FLASH) += hyper_flash_control.c
+srcs-$(CFG_HYPER_FLASH) += qspi_flash_common.c
+srcs-$(CFG_HYPER_FLASH) += qspi_onboard_control.c
+srcs-$(CFG_HYPER_FLASH) += qspi_quad_control.c
diff --git a/core/arch/arm/plat-rcar/drivers/swdt_driver.c b/core/arch/arm/plat-rcar/drivers/swdt_driver.c
new file mode 100644
index 0000000..7741b56
--- /dev/null
+++ b/core/arch/arm/plat-rcar/drivers/swdt_driver.c
@@ -0,0 +1,222 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <io.h>
+#include <kernel/panic.h>
+#include <kernel/interrupt.h>
+#include <initcall.h>
+#include <drivers/swdt_driver.h>
+
+/******************************************************************************/
+/* Defines                                                                    */
+/******************************************************************************/
+/* Register */
+#define RST_WDTRSTCR		(0xE6160054U)
+#define SWDT_SWTCNT		(0xE6030000U)
+#define SWDT_SWTCSRA		(0xE6030004U)
+#define SWDT_SWTCSRB		(0xE6030008U)
+
+#define SWDT_WDTRSTCR_UPPER_BYTE	(0xA55A0000U)
+#define SWDT_WDTRSTCR_LOWER_BYTE	(0x0000FFFFU)
+#define SWDT_SWTCSRA_UPPER_BYTE		(0xA5A5A500U)
+#define SWDT_SWTCSRA_WRFLG		((uint32_t)1U<<5U)
+#define SWDT_SWTCSRA_TME		((uint32_t)1U<<7U)
+#define SWDT_SWTCSRA_WOVF		((uint32_t)1U<<4U)
+#define SWDT_SWTCSRA_WOVFE		((uint32_t)1U<<3U)
+#define SWDT_SWTCSRA_BIT_CKS		(0x00000007U)
+#define SWDT_SWTCSRB_UPPER_BYTE		(0xA5A5A500U)
+#define SWDT_SWTCSRB_BIT_CKS		(0x0000003FU)
+#define SWDT_SWTCNT_UPPER_BYTE		(0x5A5A0000U)
+#define SWDT_SWTCNT_RESET_VALUE		(0x0000F488U)
+#define RST_WDTRSTCR_RSTMSK             ((uint32_t)1U<<1U)
+
+#define SPI_SWDT		(141U + 32U)	/* System WDT */
+
+#define SWDT_STATE_NOACTIVE	(0U)
+#define SWDT_STATE_ACTIVE	(1U)
+
+/******************************************************************************/
+/* Prototype                                                                  */
+/******************************************************************************/
+static void swdt_is_ready(void);
+static enum itr_return swdt_handler(struct itr_handler *h);
+static TEE_Result swdt_init(void);
+
+/******************************************************************************/
+/* Global                                                                     */
+/******************************************************************************/
+static uint16_t		swdt_initial_count = 0U;
+static uint32_t		swdt_state = 0U;
+static void		(*user_cb)(void) = NULL;
+
+
+static void swdt_is_ready(void)
+{
+	while (0U != (read8(SWDT_SWTCSRA) & SWDT_SWTCSRA_WRFLG)) {
+		;
+	}
+}
+
+static enum itr_return swdt_handler(struct itr_handler *h)
+{
+	uint32_t reg;
+	(void)h;
+
+	if (NULL != user_cb) {
+		user_cb();
+	}
+
+	reg = read8(SWDT_SWTCSRA);
+	reg &= ~SWDT_SWTCSRA_WOVF;
+	reg |= SWDT_SWTCSRA_UPPER_BYTE;
+	write32(reg, SWDT_SWTCSRA);
+
+	return ITRR_HANDLED;
+}
+
+static struct itr_handler swdt_itr[] = {
+	/* System Timer */
+	{
+	.it = SPI_SWDT,
+	.flags = (uint32_t)ITRF_TRIGGER_LEVEL,
+	.handler = &swdt_handler
+	}
+};
+
+int32_t swdt_start(uint16_t count, uint8_t clk,
+		uint8_t expanded_clk, void (*cb)(void))
+{
+	int32_t ret = SWDT_SUCCESS;
+	uint32_t reg;
+	uint32_t reg_WTCSRA = 0U;
+
+	/* parameter check */
+	if ((SWDT_FREQ_EXPANDED < clk) || (0U == count)) {
+		ret = SWDT_ERR_PARAMETER;	/* parameter error */
+	}
+
+	if ((SWDT_SUCCESS == ret) && (SWDT_STATE_NOACTIVE != swdt_state)) {
+		ret = SWDT_ERR_SEQUENCE;
+	}
+
+	if (SWDT_SUCCESS == ret) {
+		swdt_is_ready();
+
+		/* counter setting */
+		swdt_initial_count = (0xFFFFU - count) + 1U;
+		write32(SWDT_SWTCNT_UPPER_BYTE | swdt_initial_count, SWDT_SWTCNT);
+
+		/* interrupt or reset setting */
+		if (NULL == cb) {		/* reset route */
+			/* Reset mask register setting */
+			reg = read32(RST_WDTRSTCR) & SWDT_WDTRSTCR_LOWER_BYTE;
+			reg &= ~RST_WDTRSTCR_RSTMSK;
+			write32(reg | SWDT_WDTRSTCR_UPPER_BYTE, RST_WDTRSTCR);
+		} else {			/* interrupt route */
+			/* Reset mask register setting */
+			reg = read32(RST_WDTRSTCR) & SWDT_WDTRSTCR_LOWER_BYTE;
+			reg |= RST_WDTRSTCR_RSTMSK;
+			write32(reg | SWDT_WDTRSTCR_UPPER_BYTE, RST_WDTRSTCR);
+
+			user_cb = cb;
+			itr_enable(swdt_itr);
+
+			/* enable interrupt */
+			reg_WTCSRA = SWDT_SWTCSRA_WOVFE;
+		}
+
+		if (SWDT_FREQ_EXPANDED == clk) {
+			reg = read8(SWDT_SWTCSRB);
+			reg &= ~(uint32_t)SWDT_SWTCSRB_BIT_CKS;
+			reg |= SWDT_SWTCSRB_UPPER_BYTE | ((uint32_t)expanded_clk & SWDT_SWTCSRB_BIT_CKS);
+			write32(reg, SWDT_SWTCSRB);
+		}
+
+		/* start */
+		reg_WTCSRA |= clk;
+		write32(reg_WTCSRA | SWDT_SWTCSRA_UPPER_BYTE, SWDT_SWTCSRA);
+		
+		reg = read8(SWDT_SWTCSRA);
+		reg |= SWDT_SWTCSRA_TME;
+		write32(reg | SWDT_SWTCSRA_UPPER_BYTE, SWDT_SWTCSRA);
+
+		swdt_state = SWDT_STATE_ACTIVE;
+	}
+
+	return ret;
+}
+
+int32_t swdt_stop(void)
+{
+	uint32_t reg;
+	int32_t ret = SWDT_SUCCESS;
+
+	if (SWDT_STATE_ACTIVE != swdt_state) {
+		ret = SWDT_ERR_SEQUENCE;
+	} else {
+
+		itr_disable(swdt_itr);
+		user_cb = NULL;
+
+		reg = read8(SWDT_SWTCSRA);
+		reg &= ~SWDT_SWTCSRA_TME;
+		reg |= SWDT_SWTCSRA_UPPER_BYTE;
+		write32(reg, SWDT_SWTCSRA);
+
+		/* Reset mask register setting */
+		reg = read32(RST_WDTRSTCR) & SWDT_WDTRSTCR_LOWER_BYTE;
+		reg |= RST_WDTRSTCR_RSTMSK;
+		write32(reg | SWDT_WDTRSTCR_UPPER_BYTE, RST_WDTRSTCR);
+
+		swdt_state = SWDT_STATE_NOACTIVE;
+	}
+	return ret;
+}
+
+int32_t swdt_kick(void)
+{
+	int32_t ret = SWDT_SUCCESS;
+
+	if (SWDT_STATE_ACTIVE != swdt_state) {
+		ret = SWDT_ERR_SEQUENCE;
+	} else {
+		swdt_is_ready();
+		
+		write32(SWDT_SWTCNT_UPPER_BYTE | swdt_initial_count, SWDT_SWTCNT);
+	}
+	return ret;
+}
+
+
+static TEE_Result swdt_init(void)
+{
+	itr_add(swdt_itr);
+
+	return TEE_SUCCESS;
+}
+
+driver_init(swdt_init);
diff --git a/core/arch/arm/plat-rcar/include/drivers/mfis_driver.h b/core/arch/arm/plat-rcar/include/drivers/mfis_driver.h
new file mode 100644
index 0000000..35fdd1c
--- /dev/null
+++ b/core/arch/arm/plat-rcar/include/drivers/mfis_driver.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef MFIS_DRIVER_H_
+#define MFIS_DRIVER_H_
+
+#define	MFIS_ERR_DET_MAX	(8U)
+
+#define	MFIS_SUCCESS			(0)
+#define	MFIS_ERR_PARAMETER		(-1)
+#define	MFIS_ERR_SEQUENCE		(-2)
+
+typedef struct {
+	uint32_t	control[MFIS_ERR_DET_MAX];	/* MFIERRxxxRy */
+	uint32_t	target[MFIS_ERR_DET_MAX];
+}MFIS_ERR_SETTING_T;
+
+typedef struct {
+	uint32_t	error[MFIS_ERR_DET_MAX];
+}MFIS_ERR_FACTOR_T;
+
+int32_t mfis_error_detection_start(MFIS_ERR_SETTING_T *err,
+		void (*cb)(MFIS_ERR_FACTOR_T*));
+int32_t mfis_error_detection_stop(void);
+
+#endif /* MFIS_DRIVER_H_ */
diff --git a/core/arch/arm/plat-rcar/include/drivers/qspi_hyper_flash.h b/core/arch/arm/plat-rcar/include/drivers/qspi_hyper_flash.h
new file mode 100644
index 0000000..65bf7ab
--- /dev/null
+++ b/core/arch/arm/plat-rcar/include/drivers/qspi_hyper_flash.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef QSPI_HYPER_FLASH_H
+#define QSPI_HYPER_FLASH_H
+
+#include <stdint.h>
+#include <string.h>
+
+/*
+ * Constant definition
+ */
+
+/* function return code */
+/* correct end */
+#define FL_DRV_OK			0U
+/* incorrect end */
+#define FL_DRV_ERR_UNSUPPORT_DEV	1U
+#define FL_DRV_ERR_SECTOR_ADDR		2U
+#define FL_DRV_ERR_BUF_INCORRECT	3U
+#define FL_DRV_ERR_OUT_OF_RANGE		4U
+#define FL_DRV_ERR_SECTOR_EXCEED	5U
+#define FL_DRV_ERR_TIMEOUT		6U
+#define FL_DRV_ERR_GET_SYS_TIME		7U
+#define FL_DRV_ERR_SYSCALL_WAIT		8U
+#define FL_DRV_ERR_STATUS_INCORRECT	9U
+
+/* sector size */
+#define SECTOR_SIZE			0x00040000U
+
+uint32_t qspi_hyper_flash_init(void);
+uint32_t qspi_hyper_flash_erase(uint32_t sector_addr);
+uint32_t qspi_hyper_flash_read(uint32_t flash_addr, uint8_t *buf,
+				size_t rsize);
+uint32_t qspi_hyper_flash_write(uint32_t flash_addr, const uint8_t *buf,
+				size_t wsize);
+
+#endif /* QSPI_HYPER_FLASH_H */
diff --git a/core/arch/arm/plat-rcar/include/drivers/swdt_driver.h b/core/arch/arm/plat-rcar/include/drivers/swdt_driver.h
new file mode 100644
index 0000000..9526fc5
--- /dev/null
+++ b/core/arch/arm/plat-rcar/include/drivers/swdt_driver.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SWDT_DRIVER_H_
+#define SWDT_DRIVER_H_
+
+#define	SWDT_FREQ_OSC_DIV_1_1		(0U)
+#define	SWDT_FREQ_OSC_DIV_1_4		(1U)
+#define	SWDT_FREQ_OSC_DIV_1_16		(2U)
+#define	SWDT_FREQ_OSC_DIV_1_32		(3U)
+#define	SWDT_FREQ_OSC_DIV_1_64		(4U)
+#define	SWDT_FREQ_OSC_DIV_1_128		(5U)
+#define	SWDT_FREQ_OSC_DIV_1_1024	(6U)
+#define	SWDT_FREQ_EXPANDED		(7U)
+
+#define	SWDT_SUCCESS			(0)
+#define	SWDT_ERR_PARAMETER		(-1)
+#define	SWDT_ERR_SEQUENCE		(-2)
+
+int32_t swdt_start(uint16_t count, uint8_t clk,
+		uint8_t expanded_clk, void (*cb)(void));
+int32_t swdt_stop(void);
+int32_t swdt_kick(void);
+
+#endif /* SWDT_DRIVER_H_ */
diff --git a/core/arch/arm/plat-rcar/kern.ld.S b/core/arch/arm/plat-rcar/kern.ld.S
new file mode 100644
index 0000000..1e4b979
--- /dev/null
+++ b/core/arch/arm/plat-rcar/kern.ld.S
@@ -0,0 +1,308 @@
+/*
+ * Copyright (c) 2014, Linaro Limited
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 2008-2010 Travis Geiselbrecht
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files
+ * (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <platform_config.h>
+
+OUTPUT_FORMAT(CFG_KERN_LINKER_FORMAT)
+OUTPUT_ARCH(CFG_KERN_LINKER_ARCH)
+
+ENTRY(_start)
+SECTIONS
+{
+	. = CFG_TEE_LOAD_ADDR;
+
+	/* text/read-only data */
+	.text : {
+		__text_start = .;
+		KEEP(*(.text.boot.vectab1))
+		KEEP(*(.text.boot.vectab2))
+		KEEP(*(.text.boot))
+
+		. = ALIGN(16);
+		KEEP(*(.version))
+
+		. = ALIGN(8);
+		__initcall_start = .;
+		KEEP(*(.initcall1))
+		KEEP(*(.initcall2))
+		__initcall_end = .;
+
+#ifdef CFG_WITH_PAGER
+		*(.text)
+/* Include list of sections needed for paging */
+#include <text_unpaged.ld.S>
+#else
+		*(.text .text.*)
+#endif
+		*(.sram.text.glue_7* .gnu.linkonce.t.*)
+		__text_end = .;
+	}
+
+	.interp : { *(.interp) }
+	.hash : { *(.hash) }
+	.dynsym : { *(.dynsym) }
+	.dynstr : { *(.dynstr) }
+	.rel.text : { *(.rel.text) *(.rel.gnu.linkonce.t*) }
+	.rela.text : { *(.rela.text) *(.rela.gnu.linkonce.t*) }
+	.rel.data : { *(.rel.data) *(.rel.gnu.linkonce.d*) }
+	.rela.data : { *(.rela.data) *(.rela.gnu.linkonce.d*) }
+	.rel.rodata : { *(.rel.rodata) *(.rel.gnu.linkonce.r*) }
+	.rela.rodata : { *(.rela.rodata) *(.rela.gnu.linkonce.r*) }
+	.rel.got : { *(.rel.got) }
+	.rela.got : { *(.rela.got) }
+	.rel.ctors : { *(.rel.ctors) }
+	.rela.ctors : { *(.rela.ctors) }
+	.rel.dtors : { *(.rel.dtors) }
+	.rela.dtors : { *(.rela.dtors) }
+	.rel.init : { *(.rel.init) }
+	.rela.init : { *(.rela.init) }
+	.rel.fini : { *(.rel.fini) }
+	.rela.fini : { *(.rela.fini) }
+	.rel.bss : { *(.rel.bss) }
+	.rela.bss : { *(.rela.bss) }
+	.rel.plt : { *(.rel.plt) }
+	.rela.plt : { *(.rela.plt) }
+	.init : { *(.init) } =0x9090
+	.plt : { *(.plt) }
+
+	/* .ARM.exidx is sorted, so has to go in its own output section.  */
+	.ARM.exidx : {
+		__exidx_start = .;
+		*(.ARM.exidx* .gnu.linkonce.armexidx.*)
+		__exidx_end = .;
+	}
+
+	.ARM.extab : {
+		__extab_start = .;
+		*(.ARM.extab*)
+		__extab_end = .;
+	}
+
+	.rodata : ALIGN(4) {
+		__rodata_start = .;
+		*(.gnu.linkonce.r.*)
+#ifdef CFG_WITH_PAGER
+		*(.rodata .rodata.__unpaged)
+#include <rodata_unpaged.ld.S>
+#else
+		*(.rodata .rodata.*)
+
+		/*
+		 * 8 to avoid unwanted padding between __start_ta_head_section
+		 * and the first structure in ta_head_section, in 64-bit
+		 * builds
+		 */
+		. = ALIGN(8);
+		__start_ta_head_section = . ;
+		KEEP(*(ta_head_section))
+		__stop_ta_head_section = . ;
+#endif
+		. = ALIGN(4);
+		__rodata_end = .;
+	}
+
+
+	.data : ALIGN(4) {
+		/* writable data  */
+		__data_start_rom = .;
+		/* in one segment binaries, the rom data address is on top
+		   of the ram data address */
+		__data_start = .;
+		*(.data .data.* .gnu.linkonce.d.*)
+		. = ALIGN(4);
+	}
+
+	.ctors : ALIGN(4) {
+		__ctor_list = .;
+		*(.ctors)
+		__ctor_end = .;
+	}
+	.dtors : ALIGN(4) {
+		__dtor_list = .;
+		*(.dtors)
+		__dtor_end = .;
+	}
+	.got : { *(.got.plt) *(.got) }
+	.dynamic : { *(.dynamic) }
+
+	__data_end = .;
+	/* unintialized data */
+	.bss : ALIGN(4) {
+		__bss_start = .;
+		*(.bss .bss.*)
+		*(.gnu.linkonce.b.*)
+		*(COMMON)
+		. = ALIGN(4);
+		__bss_end = .;
+	}
+
+	.heap1 (NOLOAD) : {
+		/*
+		 * We're keeping track of the padding added before the
+		 * .nozi section so we can do something useful with
+		 * this otherwise wasted memory.
+		 */
+		__heap1_start = .;
+#ifndef CFG_WITH_PAGER
+		. += HEAP_SIZE;
+#endif
+		. = ALIGN(16 * 1024);
+		__heap1_end = .;
+	}
+
+	/*
+	 * Uninitialized data that shouldn't be zero initialized at
+	 * runtime.
+	 *
+	 * L1 mmu table requires 16 KiB alignment
+	 */
+	.nozi (NOLOAD) : ALIGN(16 * 1024) {
+		KEEP(*(.nozi .nozi.*))
+	}
+
+#ifdef CFG_WITH_PAGER
+	.heap2 (NOLOAD) : {
+		__heap2_start = .;
+		/*
+		 * Reserve additional memory for heap, the total should
+		 * be at least HEAP_SIZE, but count what has already been
+		 * reserved in .heap1
+		 */
+		. += HEAP_SIZE - (__heap1_end - __heap1_start);
+		. = ALIGN(4 * 1024);
+		__heap2_end = .;
+	}
+
+	.text_init : ALIGN(4 * 1024) {
+		__text_init_start = .;
+/*
+ * Include list of sections needed for boot initialization, this list
+ * overlaps with unpaged.ld.S but since unpaged.ld.S is first all those
+ * sections will go into the unpaged area.
+ */
+#include <text_init.ld.S>
+		. = ALIGN(4);
+		__text_init_end = .;
+	}
+
+	.rodata_init : ALIGN(4) {
+		__rodata_init_start = .;
+#include <rodata_init.ld.S>
+		. = ALIGN(4);
+		__rodata_init_end = .;
+	}
+	__init_start = __text_init_start;
+	__init_end = .;
+	__init_size = __init_end - __text_init_start;
+
+	.text_pageable : ALIGN(4) {
+		__text_pageable_start = .;
+		*(.text*)
+		. = ALIGN(4);
+		__text_pageable_end = .;
+	}
+
+	.rodata_pageable : ALIGN(4) {
+		__rodata_pageable_start = .;
+		*(.rodata*)
+		. = ALIGN(4);
+		__start_ta_head_section = . ;
+		KEEP(*(ta_head_section))
+		__stop_ta_head_section = . ;
+		. = ALIGN(4 * 1024);
+		__rodata_pageable_end = .;
+	}
+
+	__pageable_part_start = __rodata_init_end;
+	__pageable_part_end = __rodata_pageable_end;
+	__pageable_start = __text_init_start;
+	__pageable_end = __pageable_part_end;
+
+	/*
+	 * Assign a safe spot to store the hashes of the pages before
+	 * heap is initialized.
+	 */
+	__tmp_hashes_start = __rodata_init_end;
+	__tmp_hashes_size = ((__pageable_end - __pageable_start) /
+				(4 * 1024)) * 32;
+	__tmp_hashes_end = __tmp_hashes_start + __tmp_hashes_size;
+
+	__init_mem_usage = __tmp_hashes_end - CFG_TEE_LOAD_ADDR;
+
+	ASSERT(CFG_TEE_LOAD_ADDR >= CFG_TEE_RAM_START,
+		"Load address before start of physical memory")
+	ASSERT(CFG_TEE_LOAD_ADDR < (CFG_TEE_RAM_START + CFG_TEE_RAM_PH_SIZE),
+		"Load address after end of physical memory")
+	ASSERT(__tmp_hashes_end < (CFG_TEE_RAM_START + CFG_TEE_RAM_PH_SIZE),
+		"OP-TEE can't fit init part into available physical memory")
+	ASSERT((CFG_TEE_RAM_START + CFG_TEE_RAM_PH_SIZE - __init_end) >
+		1 * 4096, "Too few free pages to initialize paging")
+
+
+#endif /*CFG_WITH_PAGER*/
+
+	_end = .;
+
+#ifndef CFG_WITH_PAGER
+	__init_size = __data_end - CFG_TEE_LOAD_ADDR;
+	__init_mem_usage = _end - CFG_TEE_LOAD_ADDR;
+#endif
+	. = CFG_TEE_RAM_START + CFG_TEE_RAM_VA_SIZE;
+	_end_of_ram = .;
+
+	/DISCARD/ : {
+		/* Strip unnecessary stuff */
+		*(.comment .note .eh_frame)
+		/* Strip meta variables */
+		*(__keep_meta_vars*)
+	}
+
+}
diff --git a/core/arch/arm/plat-rcar/link.mk b/core/arch/arm/plat-rcar/link.mk
new file mode 100644
index 0000000..412abab
--- /dev/null
+++ b/core/arch/arm/plat-rcar/link.mk
@@ -0,0 +1,195 @@
+link-out-dir = $(out-dir)/core
+
+link-script = $(platform-dir)/kern.ld.S
+link-script-pp = $(link-out-dir)/kern.ld
+link-script-dep = $(link-out-dir)/.kern.ld.d
+
+AWK	 = awk
+
+
+link-ldflags  = $(LDFLAGS)
+link-ldflags += -T $(link-script-pp) -Map=$(link-out-dir)/tee.map
+link-ldflags += --sort-section=alignment
+link-ldflags += --fatal-warnings
+link-ldflags += --gc-sections
+
+link-ldadd  = $(LDADD)
+link-ldadd += $(addprefix -L,$(libdirs))
+link-ldadd += $(addprefix -l,$(libnames))
+ldargs-tee.elf := $(link-ldflags) $(objs) $(link-out-dir)/version.o \
+	$(link-ldadd) $(libgcccore)
+
+link-script-cppflags := -DASM=1 \
+	$(filter-out $(CPPFLAGS_REMOVE) $(cppflags-remove), \
+		$(nostdinccore) $(CPPFLAGS) \
+		$(addprefix -I,$(incdirscore) $(link-out-dir)) \
+		$(cppflagscore))
+
+entries-unpaged += thread_init_vbar
+entries-unpaged += sm_init
+entries-unpaged += core_init_mmu_regs
+entries-unpaged += stack_tmp_top
+entries-unpaged += sem_cpu_sync
+entries-unpaged += generic_boot_get_handlers
+entries-unpaged += tee_pager_release_zi
+entries-unpaged += tee_pager_request_zi
+
+ldargs-all_objs := -i $(objs) $(link-ldadd) $(libgcccore)
+cleanfiles += $(link-out-dir)/all_objs.o
+$(link-out-dir)/all_objs.o: $(objs) $(libdeps) $(MAKEFILE_LIST)
+	@$(cmd-echo-silent) '  LD      $@'
+	$(q)$(LDcore) $(ldargs-all_objs) -o $@
+
+cleanfiles += $(link-out-dir)/unpaged_entries.txt
+$(link-out-dir)/unpaged_entries.txt: $(link-out-dir)/all_objs.o
+	@$(cmd-echo-silent) '  GEN     $@'
+	$(q)$(NMcore) $< | \
+		$(AWK) '/ ____keep_pager/ { printf "-u%s ", $$3 }' > $@
+
+objs-unpaged-rem += core/arch/arm/tee/entry_std.o
+objs-unpaged-rem += core/arch/arm/tee/arch_svc.o
+objs-unpaged := \
+	$(filter-out $(addprefix $(out-dir)/, $(objs-unpaged-rem)), $(objs))
+ldargs-unpaged = -i --gc-sections $(addprefix -u, $(entries-unpaged))
+ldargs-unpaged-objs := $(objs-unpaged) $(link-ldadd) $(libgcccore)
+cleanfiles += $(link-out-dir)/unpaged.o
+$(link-out-dir)/unpaged.o: $(link-out-dir)/unpaged_entries.txt
+	@$(cmd-echo-silent) '  LD      $@'
+	$(q)$(LDcore) $(ldargs-unpaged) \
+		`cat $(link-out-dir)/unpaged_entries.txt` \
+		$(ldargs-unpaged-objs) -o $@
+
+cleanfiles += $(link-out-dir)/text_unpaged.ld.S:
+$(link-out-dir)/text_unpaged.ld.S: $(link-out-dir)/unpaged.o
+	@$(cmd-echo-silent) '  GEN     $@'
+	$(q)$(READELFcore) -a -W $< | ${AWK} -f ./scripts/gen_ld_text_sects.awk > $@
+
+cleanfiles += $(link-out-dir)/rodata_unpaged.ld.S:
+$(link-out-dir)/rodata_unpaged.ld.S: $(link-out-dir)/unpaged.o
+	@$(cmd-echo-silent) '  GEN     $@'
+	$(q)$(READELFcore) -a -W $< | \
+		${AWK} -f ./scripts/gen_ld_rodata_sects.awk > $@
+
+
+cleanfiles += $(link-out-dir)/init_entries.txt
+$(link-out-dir)/init_entries.txt: $(link-out-dir)/all_objs.o
+	@$(cmd-echo-silent) '  GEN     $@'
+	$(q)$(NMcore) $< | \
+		$(AWK) '/ ____keep_init/ { printf "-u%s", $$3 }' > $@
+
+objs-init-rem += core/arch/arm/tee/arch_svc.o
+objs-init-rem += core/arch/arm/tee/arch_svc_asm.o
+objs-init-rem += core/arch/arm/tee/init.o
+objs-init-rem += core/arch/arm/tee/entry_std.o
+entries-init += _start
+objs-init := \
+	$(filter-out $(addprefix $(out-dir)/, $(objs-init-rem)), $(objs) \
+		$(link-out-dir)/version.o)
+ldargs-init := -i --gc-sections $(addprefix -u, $(entries-init))
+
+ldargs-init-objs := $(objs-init) $(link-ldadd) $(libgcccore)
+cleanfiles += $(link-out-dir)/init.o
+$(link-out-dir)/init.o: $(link-out-dir)/init_entries.txt
+	$(call gen-version-o)
+	@$(cmd-echo-silent) '  LD      $@'
+	$(q)$(LDcore) $(ldargs-init) \
+		`cat $(link-out-dir)/init_entries.txt` \
+		$(ldargs-init-objs) -o $@
+
+cleanfiles += $(link-out-dir)/text_init.ld.S:
+$(link-out-dir)/text_init.ld.S: $(link-out-dir)/init.o
+	@$(cmd-echo-silent) '  GEN     $@'
+	$(q)$(READELFcore) -a -W $< | ${AWK} -f ./scripts/gen_ld_text_sects.awk > $@
+
+cleanfiles += $(link-out-dir)/rodata_init.ld.S:
+$(link-out-dir)/rodata_init.ld.S: $(link-out-dir)/init.o
+	@$(cmd-echo-silent) '  GEN     $@'
+	$(q)$(READELFcore) -a -W $< | \
+		${AWK} -f ./scripts/gen_ld_rodata_sects.awk > $@
+
+-include $(link-script-dep)
+
+link-script-extra-deps += $(link-out-dir)/text_unpaged.ld.S
+link-script-extra-deps += $(link-out-dir)/rodata_unpaged.ld.S
+link-script-extra-deps += $(link-out-dir)/text_init.ld.S
+link-script-extra-deps += $(link-out-dir)/rodata_init.ld.S
+link-script-extra-deps += $(conf-file)
+cleanfiles += $(link-script-pp) $(link-script-dep)
+$(link-script-pp): $(link-script) $(link-script-extra-deps)
+	@$(cmd-echo-silent) '  CPP     $@'
+	@mkdir -p $(dir $@)
+	$(q)$(CPPcore) -Wp,-P,-MT,$@,-MD,$(link-script-dep) \
+		$(link-script-cppflags) $< > $@
+
+define update-buildcount
+	@$(cmd-echo-silent) '  UPD     $(1)'
+	$(q)if [ ! -f $(1) ]; then \
+		mkdir -p $(dir $(1)); \
+		echo 1 >$(1); \
+	else \
+		expr 0`cat $(1)` + 1 >$(1); \
+	fi
+endef
+
+version-o-cflags = $(filter-out -g3,$(core-platform-cflags) \
+			$(platform-cflags)) # Workaround objdump warning
+DATE_STR = `date -u`
+BUILD_COUNT_STR = `cat $(link-out-dir)/.buildcount`
+define gen-version-o
+	$(call update-buildcount,$(link-out-dir)/.buildcount)
+	@$(cmd-echo-silent) '  GEN     $(link-out-dir)/version.o'
+	$(q)echo -e "const char core_v_str[] =" \
+		"\"$(TEE_IMPL_VERSION) \"" \
+		"\"#$(BUILD_COUNT_STR) \"" \
+		"\"$(DATE_STR) \"" \
+		"\"$(CFG_KERN_LINKER_ARCH)\";\n" \
+		| $(CCcore) $(version-o-cflags) \
+			-xc - -c -o $(link-out-dir)/version.o
+endef
+$(link-out-dir)/version.o:
+	$(call gen-version-o)
+
+all: $(link-out-dir)/tee.elf
+cleanfiles += $(link-out-dir)/tee.elf $(link-out-dir)/tee.map
+cleanfiles += $(link-out-dir)/version.o
+cleanfiles += $(link-out-dir)/.buildcount
+$(link-out-dir)/tee.elf: $(objs) $(libdeps) $(link-script-pp)
+	@$(cmd-echo-silent) '  LD      $@'
+	$(q)$(LDcore) $(ldargs-tee.elf) -o $@
+
+all: $(link-out-dir)/tee.dmp
+cleanfiles += $(link-out-dir)/tee.dmp
+$(link-out-dir)/tee.dmp: $(link-out-dir)/tee.elf
+	@$(cmd-echo-silent) '  OBJDUMP $@'
+	$(q)$(OBJDUMPcore) -l -x -d $< > $@
+
+all: $(link-out-dir)/tee.bin
+cleanfiles += $(link-out-dir)/tee.bin
+$(link-out-dir)/tee.bin: $(link-out-dir)/tee.elf
+	@$(cmd-echo-silent) '  OBJCOPY $@'
+	$(q)$(OBJCOPYcore) -O binary $< $@
+
+all: $(link-out-dir)/tee.srec
+cleanfiles += $(link-out-dir)/tee.srec
+$(link-out-dir)/tee.srec: $(link-out-dir)/tee.elf
+	@$(cmd-echo-silent) '  SREC    $@'
+	$(q)$(OBJCOPYcore) -O srec $< $@
+
+all: $(link-out-dir)/tee.symb_sizes
+cleanfiles += $(link-out-dir)/tee.symb_sizes
+$(link-out-dir)/tee.symb_sizes: $(link-out-dir)/tee.elf
+	@$(cmd-echo-silent) '  GEN     $@'
+	$(q)$(NMcore) --print-size --reverse-sort --size-sort $< > $@
+	@$(cmd-echo-silent) '  ECHO    TEE_IMPL_VERSION        = "$(TEE_IMPL_VERSION)"'
+	@$(cmd-echo-silent) '  ECHO    CFG_TEE_MANUFACTURER    = "$(CFG_TEE_MANUFACTURER)"'
+	@$(cmd-echo-silent) '  ECHO    CFG_TEE_FW_IMPL_VERSION = "$(CFG_TEE_FW_IMPL_VERSION)"'
+	@$(cmd-echo-silent) '  ECHO    CFG_TEE_FW_MANUFACTURER = "$(CFG_TEE_FW_MANUFACTURER)"'
+
+cleanfiles += $(link-out-dir)/tee.mem_usage
+ifneq ($(filter mem_usage,$(MAKECMDGOALS)),)
+mem_usage: $(link-out-dir)/tee.mem_usage
+
+$(link-out-dir)/tee.mem_usage: $(link-out-dir)/tee.elf
+	@$(cmd-echo-silent) '  GEN     $@'
+	$(q)$(READELFcore) -a -W $< | ${AWK} -f ./scripts/mem_usage.awk > $@
+endif
diff --git a/core/arch/arm/plat-rcar/main.c b/core/arch/arm/plat-rcar/main.c
new file mode 100644
index 0000000..6cd2c82
--- /dev/null
+++ b/core/arch/arm/plat-rcar/main.c
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2014, STMicroelectronics International N.V.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <platform_config.h>
+
+#include <stdint.h>
+#include <string.h>
+
+#include <drivers/gic.h>
+
+#include <arm.h>
+#include <kernel/generic_boot.h>
+#include <kernel/pm_stubs.h>
+#include <trace.h>
+#include <kernel/misc.h>
+#include <kernel/tee_time.h>
+#include <tee/entry_fast.h>
+#include <tee/entry_std.h>
+#include <console.h>
+#include <keep.h>
+#include <initcall.h>
+
+#include <sm/optee_smc.h>
+#include "rcar_common.h"
+#include "rcar_log_func.h"
+#include "rcar_ddr_training.h"
+
+static void main_tee_entry_fast(struct thread_smc_args *args);
+static void main_fiq(void);
+static enum itr_return main_fiq_cb(struct itr_handler *h);
+static TEE_Result init_dev_itr(void);
+
+static void main_tee_entry_fast(struct thread_smc_args *args)
+{
+	if (args->a0 == OPTEE_SMC_GET_SHM_CONFIG) {
+		is_normal_world_initialized = 1;
+	}
+	tee_entry_fast(args);
+}
+
+static const struct thread_handlers handlers = {
+	.std_smc = tee_entry_std,
+	.fast_smc = main_tee_entry_fast,
+	.fiq = main_fiq,
+	.cpu_on = cpu_on_handler,
+	.cpu_off = pm_do_nothing,
+	.cpu_suspend = pm_do_nothing,
+	.cpu_resume = pm_do_nothing,
+	.system_off = pm_do_nothing,
+	.system_reset = pm_do_nothing,
+};
+
+static struct gic_data gic_data;
+
+const struct thread_handlers *generic_boot_get_handlers(void)
+{
+	return &handlers;
+}
+
+void main_init_gic(void)
+{
+	/* On ARMv8, GIC configuration is initialized in ARM-TF */
+	gic_init_base_addr(&gic_data, GIC_BASE + GICC_OFFSET,
+			   GIC_BASE + GICD_OFFSET);
+	itr_init(&gic_data.chip);
+}
+
+static void main_fiq(void)
+{
+	gic_it_handle(&gic_data);
+}
+
+static enum itr_return main_fiq_cb(struct itr_handler *h)
+{
+	DMSG("enter id=%zu", h->it);
+
+	switch (h->it) {
+	/* System Timer */
+	case INTID_SCMT:
+		ddr_training_execute();
+		break;
+
+		/* Crypto Engines */
+	case INTID_PKA:
+	case INTID_CC:
+		break;
+
+	default:
+		EMSG("Unexpected fiq. id=%zu", h->it);
+		panic();
+		break;
+	}
+
+	return ITRR_HANDLED;
+}
+
+void console_init(void)
+{
+	/* No Operation */
+}
+
+static struct itr_handler dev_itr[] = {
+	/* System Timer */
+	{
+	.it = INTID_SCMT,
+	.flags = ITRF_TRIGGER_LEVEL,
+	.handler = main_fiq_cb
+	}
+};
+KEEP_PAGER(dev_itr);
+static const size_t dev_itr_num = sizeof(dev_itr) / sizeof(struct itr_handler);
+
+static TEE_Result init_dev_itr(void)
+{
+	size_t i;
+	uint8_t cpu_mask;
+
+	cpu_mask = (uint8_t)(1U << get_core_pos());
+
+	/* Enable GIC */
+	for (i = 0U; i < dev_itr_num; i++) {
+		itr_add(&dev_itr[i]);
+		/* Set the CPU mask to deliver interrupts to primary CPU */
+		gic_it_set_cpu_mask(&gic_data, dev_itr[i].it, cpu_mask);
+
+		itr_enable(&dev_itr[i]);
+	}
+
+	return TEE_SUCCESS;
+}
+driver_init(init_dev_itr);
diff --git a/core/arch/arm/plat-rcar/platform_config.h b/core/arch/arm/plat-rcar/platform_config.h
new file mode 100644
index 0000000..f416171
--- /dev/null
+++ b/core/arch/arm/plat-rcar/platform_config.h
@@ -0,0 +1,252 @@
+/*
+ * Copyright (c) 2014, Linaro Limited
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef PLATFORM_CONFIG_H
+#define PLATFORM_CONFIG_H
+
+/* Make stacks aligned to data cache line length */
+#define STACK_ALIGNMENT		(64)
+
+#define GIC_BASE		(0xF1000000U)
+#define GIC_SIZE		(0x00100000U)
+
+#ifndef ENABLE_CRYPTOENGINE
+#define HEAP_SIZE		(24 * 1024)
+#else
+#define HEAP_SIZE		(24 * 1024 * 4)
+#endif
+
+#define DRAM0_BASE		(0x44000000U)
+#define DRAM0_SIZE		(0x04000000U)
+
+/*
+ * Last part of DRAM is reserved as secure dram, note that the last 2MiB
+ * of DRAM0 is used by SCP dor DDR retraining.
+ */
+#define TZDRAM_BASE		(0x44000000U)
+
+/*
+ * Should be
+ * #define TZDRAM_SIZE		0x00FF8000
+ * but is smaller due to SECTION_SIZE alignment, can be fixed once
+ * OP-TEE OS is mapped using small pages instead.
+ */
+#define TZDRAM_SIZE		(0x03E00000U)
+
+#define CFG_TEE_CORE_NB_CORE	(8)
+
+#define GICC_OFFSET		(0x20000)
+#define GICD_OFFSET		(0x10000)
+
+#ifndef ENABLE_CRYPTOENGINE
+#define CFG_TEE_RAM_VA_SIZE	(1024 * 1024)
+#else
+#define CFG_TEE_RAM_VA_SIZE	(1024 * 1024 * 3)
+#endif
+
+#ifndef CFG_TEE_LOAD_ADDR
+#define CFG_TEE_LOAD_ADDR	CFG_TEE_RAM_START
+#endif
+
+#define CFG_TEE_RAM_START	(0x44100000)	/* TEE RAM address	*/
+#ifndef ENABLE_CRYPTOENGINE
+#define CFG_TEE_RAM_PH_SIZE	(0x00100000U)	/* TEE RAM size		*/
+#else
+#define CFG_TEE_RAM_PH_SIZE	(0x00300000U)	/* TEE RAM size		*/
+#endif
+
+#ifndef ENABLE_CRYPTOENGINE
+#define CFG_TA_RAM_START	(0x44200000U)	/* TA RAM address	*/
+#define CFG_TA_RAM_SIZE		(0x02000000U)	/* TA RAM size		*/
+#else
+#define CFG_TA_RAM_START	(0x44400000U)	/* TA RAM address	*/
+#define CFG_TA_RAM_SIZE		(0x01E00000U)	/* TA RAM size		*/
+#endif
+
+#define CFG_SHMEM_START		(0x47E00000U)	/* Share Memory address	*/
+#define CFG_SHMEM_SIZE		(0x00100000U)	/* Share Memory size	*/
+
+#define OPTEE_LOG_BASE		(0x46400000U)	/* OP-TEE Log Area address */
+#define OPTEE_LOG_NS_BASE	(0x47FEC000U)	/* OP-TEE Log Area NS address */
+
+#define TA_VERIFICATION_BASE	(0x46200000U)	/* TA area for verification */
+#define TA_VERIFICATION_SIZE	(0x00100000U)	/* TA verification size */
+#define CRYPTOENGINE_WORK_BASE	(0x46300000U)	/* Crypto Enegine Work area */
+
+#define NONCACHE_WORK_BASE	(0x46500000U)	/* Non Cache Area address */
+#define NONCACHE_WORK_SIZE	(0x00100000U)	/* Non Cache Area Size */
+
+#define SYSWDT_BASE		(0xE6030000U)	/* System WDT address	*/
+#define SYSTIM_BASE		(0xE6040000U)	/* System Timer address	*/
+#define LIFEC_BASE		(0xE6110000U)	/* Life Cycle address	*/
+#define RST_BASE		(0xE6160000U)	/* Reset address	*/
+#define SYSUTC_BASE		(0xE61D0000U)	/* System Up Time Clock */
+#define MFIS_BASE		(0xE6260000U)	/* MFIS address		*/
+#define CE_BASE			(0xE6600000U)	/* Crypto Engine Secure address	*/
+#define PKA_BASE		(0xE6602000U)	/* Crypto Engine PKA address */
+#define DBSC_BASE		(0xE6790000U)	/* DBSC address		*/
+#define CPG_BASE		(0xE6B10000U)	/* CPG address		*/
+#define SYSDMAC2_BASE		(0xE7310000U)	/* SYS-DMAC2 address	*/
+#define SRAM_BASE		(0xE6300000U)	/* System RAM address	*/
+#define ROMAPI_BASE		(0xEB100000U)	/* MaskROM API address	*/
+#define RPC_BASE		(0xEE200000U)	/* RPC address		*/
+#define PRR_BASE		(0xFFF00000U)	/* Product Register address */
+#define RPC_ADDR_MAP_BASE	(0x08000000U)	/* RPC Internal address	*/
+#define RPC_ADDR_MAP_SIZE	(0x04000000U)	/* RPC Address Map size */
+
+#define MEM_SECTION_SIZE	(0x00100000U)
+
+#define MAX_MMAP_REGIONS	(17)
+
+#ifdef CFG_WITH_LPAE
+#define MAX_XLAT_TABLES		MAX_MMAP_REGIONS
+#endif
+
+#define DEVICE0_PA_BASE		ROUNDDOWN(SYSWDT_BASE, CORE_MMU_DEVICE_SIZE)
+#define DEVICE0_VA_BASE		DEVICE0_PA_BASE
+#define DEVICE0_SIZE		(MEM_SECTION_SIZE * 3)
+#define DEVICE0_TYPE		MEM_AREA_IO_NSEC
+
+#define DEVICE1_PA_BASE		ROUNDDOWN(CE_BASE, CORE_MMU_DEVICE_SIZE)
+#define DEVICE1_VA_BASE		DEVICE1_PA_BASE
+#define DEVICE1_SIZE		(MEM_SECTION_SIZE * 2)
+#define DEVICE1_TYPE		MEM_AREA_IO_NSEC
+
+#define DEVICE2_PA_BASE		ROUNDDOWN(CPG_BASE, CORE_MMU_DEVICE_SIZE)
+#define DEVICE2_VA_BASE		DEVICE2_PA_BASE
+#define DEVICE2_SIZE		(MEM_SECTION_SIZE * 9)
+#define DEVICE2_TYPE		MEM_AREA_IO_NSEC
+
+#define DEVICE3_PA_BASE		ROUNDDOWN(GIC_BASE, CORE_MMU_DEVICE_SIZE)
+#define DEVICE3_VA_BASE		DEVICE3_PA_BASE
+#define DEVICE3_SIZE		(MEM_SECTION_SIZE)
+#define DEVICE3_TYPE		MEM_AREA_IO_NSEC
+
+/* LOG Area for Secure World */
+#define MEMORY1_BASE		ROUNDDOWN(OPTEE_LOG_BASE, MEM_SECTION_SIZE)
+#define MEMORY1_SIZE		(MEM_SECTION_SIZE)
+#define MEMORY1_TYPE		MEM_AREA_IO_SEC
+#define MEMORY1_SECURE		true
+#define MEMORY1_CACHED		false
+#define MEMORY1_DEVICE		false
+#define MEMORY1_RW		true
+#define MEMORY1_EXEC		false
+
+/* LOG Area for Normal World */
+#define MEMORY2_BASE		ROUNDDOWN(OPTEE_LOG_NS_BASE, MEM_SECTION_SIZE)
+#define MEMORY2_SIZE		(MEM_SECTION_SIZE)
+#define MEMORY2_TYPE		MEM_AREA_IO_NSEC
+#define MEMORY2_SECURE		false
+#define MEMORY2_CACHED		false
+#define MEMORY2_DEVICE		false
+#define MEMORY2_RW		true
+#define MEMORY2_EXEC		false
+
+/* System RAM */
+#define MEMORY3_BASE		ROUNDDOWN(SRAM_BASE, MEM_SECTION_SIZE)
+#define MEMORY3_SIZE		(MEM_SECTION_SIZE)
+#define MEMORY3_TYPE		MEM_AREA_IO_SEC
+#define MEMORY3_SECURE		true
+#define MEMORY3_CACHED		false
+#define MEMORY3_DEVICE		false
+#define MEMORY3_RW		true
+#define MEMORY3_EXEC		true
+
+/* Crypto Engine Work area */
+#define MEMORY4_BASE		ROUNDDOWN(CRYPTOENGINE_WORK_BASE, \
+					MEM_SECTION_SIZE)
+#define MEMORY4_SIZE		(MEM_SECTION_SIZE)
+#define MEMORY4_TYPE		MEM_AREA_IO_SEC
+#define MEMORY4_SECURE		true
+#define MEMORY4_CACHED		true
+#define MEMORY4_DEVICE		false
+#define MEMORY4_RW		true
+#define MEMORY4_EXEC		false
+
+/* TA area for verification */
+#define MEMORY5_BASE		ROUNDDOWN(TA_VERIFICATION_BASE, \
+					MEM_SECTION_SIZE)
+#define MEMORY5_SIZE		(TA_VERIFICATION_SIZE)
+#define MEMORY5_TYPE		MEM_AREA_IO_SEC
+#define MEMORY5_SECURE		true
+#define MEMORY5_CACHED		false
+#define MEMORY5_DEVICE		false
+#define MEMORY5_RW		true
+#define MEMORY5_EXEC		false
+
+/* MaskROM API */
+#define MEMORY6_BASE		ROUNDDOWN(ROMAPI_BASE, MEM_SECTION_SIZE)
+#define MEMORY6_SIZE		(MEM_SECTION_SIZE)
+#define MEMORY6_TYPE		MEM_AREA_IO_SEC
+#define MEMORY6_SECURE		true
+#define MEMORY6_CACHED		false
+#define MEMORY6_DEVICE		false
+#define MEMORY6_RW		true
+#define MEMORY6_EXEC		true
+
+/* Product Register (PRR) */
+#define MEMORY7_BASE		ROUNDDOWN(PRR_BASE, MEM_SECTION_SIZE)
+#define MEMORY7_SIZE		(MEM_SECTION_SIZE)
+#define MEMORY7_TYPE		MEM_AREA_IO_SEC
+#define MEMORY7_SECURE		true
+#define MEMORY7_CACHED		false
+#define MEMORY7_DEVICE		true
+#define MEMORY7_RW		true
+#define MEMORY7_EXEC		false
+
+/* Non Cache Stack Area */
+#define MEMORY8_BASE		ROUNDDOWN(NONCACHE_WORK_BASE, NONCACHE_WORK_SIZE)
+#define MEMORY8_SIZE		(MEM_SECTION_SIZE)
+#define MEMORY8_TYPE		MEM_AREA_IO_SEC
+#define MEMORY8_SECURE		true
+#define MEMORY8_CACHED		false
+#define MEMORY8_DEVICE		true
+#define MEMORY8_RW		true
+#define MEMORY8_EXEC		false
+
+/* SPI Multi I/O Bus Controller (RPC) */
+#define MEMORY9_BASE		ROUNDDOWN(RPC_BASE, MEM_SECTION_SIZE)
+#define MEMORY9_SIZE		(MEM_SECTION_SIZE)
+#define MEMORY9_TYPE		MEM_AREA_IO_SEC
+#define MEMORY9_SECURE		true
+#define MEMORY9_CACHED		false
+#define MEMORY9_DEVICE		true
+#define MEMORY9_RW		true
+#define MEMORY9_EXEC		false
+
+/* RPC Address Map */
+#define MEMORY10_BASE		ROUNDDOWN(RPC_ADDR_MAP_BASE, MEM_SECTION_SIZE)
+#define MEMORY10_SIZE		(RPC_ADDR_MAP_SIZE)
+#define MEMORY10_TYPE		MEM_AREA_IO_SEC
+#define MEMORY10_SECURE		true
+#define MEMORY10_CACHED		true
+#define MEMORY10_DEVICE		true
+#define MEMORY10_RW		true
+#define MEMORY10_EXEC		false
+
+#endif /*PLATFORM_CONFIG_H*/
diff --git a/core/arch/arm/plat-rcar/rcar_call_maskrom_a32.S b/core/arch/arm/plat-rcar/rcar_call_maskrom_a32.S
new file mode 100644
index 0000000..8198e78
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_call_maskrom_a32.S
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <asm.S>
+
+.global asm_switch_stack_pointer
+
+/* R0 : Jump address */
+/* R1 : Stack address */
+/* R2 : arg */
+FUNC asm_switch_stack_pointer , :
+
+	mov	r0, #-1		/* not supported */
+	bx	lr
+END_FUNC asm_switch_stack_pointer
diff --git a/core/arch/arm/plat-rcar/rcar_call_maskrom_a64.S b/core/arch/arm/plat-rcar/rcar_call_maskrom_a64.S
new file mode 100644
index 0000000..9bb6267
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_call_maskrom_a64.S
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <asm.S>
+#include <arm64_macros.S>
+#include <arm64.h>
+
+.global asm_switch_stack_pointer
+
+/* X0 : Jump address */
+/* X1 : Stack address */
+/* X2 : arg */
+FUNC asm_switch_stack_pointer , :
+
+	/* lr to stack */
+	mov	x3, x2
+	mov	x2, x30
+	sub	sp, sp, #16
+	store_xregs sp, 0, 1, 2	/* x1 is dummy (sp is 16byte alignment) */
+
+	/* change stack pointer */
+	mov	x2, sp
+	mov	sp, x1
+
+	/* save stack pointer */
+	sub	sp, sp, #16
+	store_xregs sp, 0, 1, 2	/* x1 is dummy (sp is 16byte alignment) */
+
+	/* data synchronization barrier */
+	dsb	sy
+
+	/* jump to code */
+	mov	x1, x0
+	mov	x0, x3
+	blr	x1
+
+	/* load stack pointer */
+	load_xregs sp, 0, 1, 2	/* x1 is dummy (sp is 16byte alignment) */
+
+	/* change stack pointer */
+	add	sp, sp, #16
+	mov	sp, x2
+
+	/* return */
+	load_xregs sp, 0, 1, 2	/* x1 is dummy (sp is 16byte alignment) */
+	add	sp, sp, #16
+	mov	x30, x2
+	ret
+END_FUNC asm_switch_stack_pointer
diff --git a/core/arch/arm/plat-rcar/rcar_common.h b/core/arch/arm/plat-rcar/rcar_common.h
new file mode 100644
index 0000000..13e301f
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_common.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_COMMON_H
+#define RCAR_COMMON_H
+
+#include <string.h>
+#include <platform_config.h>
+#include <kernel/misc.h>
+#include <kernel/tz_proc.h>
+#include <kernel/panic.h>
+#include <drivers/gic.h>
+#include <arm.h>
+#include <kernel/tee_time.h>
+
+/* System Timer Register */
+#define CMSSTR			(SYSTIM_BASE + 0x000U)
+#define CMSCSR			(SYSTIM_BASE + 0x040U)
+#define CMSCNT			(SYSTIM_BASE + 0x044U)
+#define CMSCOR			(SYSTIM_BASE + 0x048U)
+
+#define CMSSTR_BIT_STR5		(0x0020U)	/* CMSSTR Bit 5   */
+
+#define CMSCSR_BIT_CMF		(0x8000U)	/* CMSCSR Bit 15  */
+#define CMSCSR_BIT_OVF		(0x4000U)	/* CMSCSR Bit 14  */
+#define CMSCSR_BIT_WRFLG	(0x2000U)	/* CMSCSR Bit 13  */
+#define CMSCSR_BIT_CMS		(0x0200U)	/* CMSCSR Bit 9   */
+#define CMSCSR_BIT_CMM		(0x0100U)	/* CMSCSR Bit 8   */
+#define CMSCSR_BIT_CMR		(0x0030U)	/* CMSCSR Bit 4-5 */
+#define CMSCSR_BIT_DBGIVD	(0x0008U)	/* CMSCSR Bit 3   */
+#define CMSCSR_BIT_CKS		(0x0007U)	/* CMSCSR Bit 0-2 */
+
+#define CKS_DIVISION_RATIO_1	(0x7U)		/* CKS clock/1    */
+#define CKS_DIVISION_RATIO_8	(0x4U)		/* CKS clock/8    */
+#define CKS_DIVISION_RATIO_32	(0x5U)		/* CKS clock/32   */
+#define CKS_DIVISION_RATIO_128	(0x6U)		/* CKS clock/128  */
+#define CMR_INTERRUPT_ENABLE	(0x20U)		/* CMR Interrupt Enable */
+#define CMM_FREE_RUN_OPERATION	(0x100U)	/* CMM Free-running operation */
+#define CMM_ONE_SHOT_OPERATION	(0x000U)	/* CMM One-shot operation     */
+
+#define SYSTIM_PRIORITY		(0x1U)
+
+/* Reset(RST) */
+#define MODEMR			(0xE6160060U)	/* Mode Monitor Register */
+
+#define CHECK_MD13_MD14		(0x6000U)
+#define MD14_L_MD13_H		(0x2000U)
+
+/* Interrupt ID */
+#define INTID_SCMT		(134U + 32U)	/* System Timer */
+#define INTID_PKA		(65U  + 32U)	/* Crypto Engine PKA sec */
+#define INTID_CC		(70U  + 32U)	/* Crypto Engine sec */
+
+/* RPC No specific to R-Car */
+#define TEE_RPC_DEBUG_LOG	(0x3F000000U)
+
+/* Product Register */
+#define PRR			(0xFFF00044U)
+#define PRR_PRODUCT_MASK	(0x00007F00U)
+#define PRR_PRODUCT_UNKNOWN	(0x000000FFU)
+#define PRR_PRODUCT_H3		(0x00004F00U)	/* R-Car H3 */
+#define PRR_PRODUCT_M3		(0x00005200U)	/* R-Car M3 */
+
+extern uint32_t product_type;
+extern const int8_t *product_name;
+
+/*
+ * Prototype declaration
+ */
+
+void cpu_spin_lock_irqsave(uint32_t *lock, uint32_t *flags);
+void cpu_spin_unlock_irqrestore(uint32_t *lock, uint32_t flags);
+
+uint32_t disable_interrupts(void);
+void enable_interrupts(uint32_t flags);
+void enable_abort(void);
+void enable_fiq(void);
+void enable_irq(void);
+
+#endif /* RCAR_COMMON_H */
diff --git a/core/arch/arm/plat-rcar/rcar_ddr_training.c b/core/arch/arm/plat-rcar/rcar_ddr_training.c
new file mode 100644
index 0000000..bdc6a79
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_ddr_training.c
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <io.h>
+#include <trace.h>
+#include "rcar_ddr_training.h"
+#include "rcar_common.h"
+
+void ddr_training_timer_init(void)
+{
+	uint16_t sr;
+	uint32_t interval_ms;
+	uint32_t count;
+	uint32_t mdpin_data;
+	uint32_t oscclk_hz;
+	const uint16_t clear_mask = (uint16_t)~(
+			CMSCSR_BIT_CMF | CMSCSR_BIT_CMM |
+			CMSCSR_BIT_CMR | CMSCSR_BIT_CKS);
+
+	/* Timer stop */
+	write16(0x0000U, CMSSTR);
+
+	/* Set clock select and compare match mode */
+	sr = read16(CMSCSR);
+	sr &= clear_mask;
+	sr |= (CMM_FREE_RUN_OPERATION
+		| CMR_INTERRUPT_ENABLE
+		| CKS_DIVISION_RATIO_1);
+	write16(sr, CMSCSR);
+
+	/* Set timer interval [ms] */
+	interval_ms = 20U;	/* T.B.D */
+
+	/* Set the frequency of OSCCLK */
+	mdpin_data = read32(MODEMR) & CHECK_MD13_MD14;
+	switch (mdpin_data) {
+	case MD14_L_MD13_H:
+		oscclk_hz = 131570U;	/* 131.57kHz */
+		break;
+	default:
+		oscclk_hz = 130200U;	/* 130.20kHz */
+		break;
+	}
+
+	/* Calculate the match count */
+	count = (interval_ms * oscclk_hz) / 1000U;
+
+	/* Set match count */
+	write32(count, CMSCOR);
+}
+
+void ddr_training_timer_start(void)
+{
+	/* Counter reset */
+	write32(0x00000000U, CMSCNT);
+
+	/* Timer start */
+	write16(CMSSTR_BIT_STR5, CMSSTR);
+}
+
+void ddr_training_execute(void)
+{
+	uint16_t sr;
+	const uint16_t clear_mask = (uint16_t)~(
+			CMSCSR_BIT_CMF | CMSCSR_BIT_OVF);
+
+	/* Clear an internal interrupt request */
+	sr = read16(CMSCSR);
+	sr &= clear_mask;
+	write16(sr, CMSCSR);
+
+	/* Dummy read */
+	(void)read16(CMSCSR);
+
+	/* T.B.D. */
+}
diff --git a/core/arch/arm/plat-rcar/rcar_ddr_training.h b/core/arch/arm/plat-rcar/rcar_ddr_training.h
new file mode 100644
index 0000000..c747feb
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_ddr_training.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_DDR_TRAINING_H
+#define RCAR_DDR_TRAINING_H
+
+void ddr_training_timer_init(void);
+void ddr_training_timer_start(void);
+void ddr_training_execute(void);
+
+#endif /*RCAR_DDR_TRAINING_H*/
diff --git a/core/arch/arm/plat-rcar/rcar_interruptflags_a32.S b/core/arch/arm/plat-rcar/rcar_interruptflags_a32.S
new file mode 100644
index 0000000..9e16aee
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_interruptflags_a32.S
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <asm.S>
+
+FUNC disable_interrupts , :
+	mrs	r0,	cpsr
+	cpsid	aif
+	bx	lr
+END_FUNC disable_interrupts
+
+FUNC enable_abort , :
+	cpsie	a
+	bx	lr
+END_FUNC enable_abort
+
+FUNC enable_fiq , :
+	cpsie	f
+	bx	lr
+END_FUNC enable_fiq
+
+FUNC enable_irq , :
+	cpsie	i
+	bx	lr
+END_FUNC enable_irq
diff --git a/core/arch/arm/plat-rcar/rcar_interruptflags_a64.S b/core/arch/arm/plat-rcar/rcar_interruptflags_a64.S
new file mode 100644
index 0000000..81b47e1
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_interruptflags_a64.S
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <asm.S>
+
+FUNC disable_interrupts , :
+	mrs	x0, daif
+	msr	daifset, #7
+	ret
+END_FUNC disable_interrupts
+
+FUNC enable_abort , :
+	msr	daifclr, #4
+	ret
+END_FUNC enable_abort
+
+FUNC enable_fiq , :
+	msr	daifclr, #1
+	ret
+END_FUNC enable_fiq
+
+FUNC enable_irq , :
+	msr	daifclr, #2
+	ret
+END_FUNC enable_irq
diff --git a/core/arch/arm/plat-rcar/rcar_lock.c b/core/arch/arm/plat-rcar/rcar_lock.c
new file mode 100644
index 0000000..6ba49d6
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_lock.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "rcar_common.h"
+
+void cpu_spin_lock_irqsave(uint32_t *lock, uint32_t *flags)
+{
+	*flags = disable_interrupts();
+	cpu_spin_lock(lock);
+}
+
+void cpu_spin_unlock_irqrestore(uint32_t *lock, uint32_t flags)
+{
+	cpu_spin_unlock(lock);
+	enable_interrupts(flags);
+}
+
+void enable_interrupts(uint32_t flags)
+{
+	if ((flags & ARM32_CPSR_A) == 0U) {
+		enable_abort();
+	}
+	if ((flags & ARM32_CPSR_F) == 0U) {
+		enable_fiq();
+	}
+	if ((flags & ARM32_CPSR_I) == 0U) {
+		enable_irq();
+	}
+}
diff --git a/core/arch/arm/plat-rcar/rcar_log_func.c b/core/arch/arm/plat-rcar/rcar_log_func.c
new file mode 100644
index 0000000..61973f0
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_log_func.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <string.h>
+#include <platform_config.h>
+#include <kernel/misc.h>
+#include <kernel/tee_ta_manager.h>
+#include <kernel/thread.h>
+#include <kernel/tz_proc_def.h>
+#include <optee_msg.h>
+#include <mm/core_mmu.h>
+#include "rcar_log_func.h"
+#include "rcar_common.h"
+#include "rcar_version.h"
+
+struct log_buf_header_t *log_secram_header;
+static int8_t *log_nonsec_ptr;
+uint32_t log_spin_lock;
+int32_t is_normal_world_initialized;
+const int8_t version_of_renesas[] __attribute__((__section__(".version"))) =
+	VERSION_OF_RENESAS;
+
+void log_buf_init(void)
+{
+	const int8_t secram_prefix[] = LOG_SEC_PREFIX;
+	int32_t i;
+
+	/* initialize global variable */
+	log_secram_header = (struct log_buf_header_t *)OPTEE_LOG_BASE;
+	log_nonsec_ptr = (int8_t *)OPTEE_LOG_NS_BASE;
+	log_spin_lock = (uint32_t)SPINLOCK_UNLOCK;
+	is_normal_world_initialized = 0;
+
+	/* initialize SDRAM area */
+	for (i = 0; i < LOG_SEC_PREFIX_LEN; i++) {
+		if (secram_prefix[i] != log_secram_header->prefix[i]) {
+			break;
+		}
+	}
+	if ((i < LOG_SEC_PREFIX_LEN) ||
+	    (log_secram_header->index >= LOG_AREA_MAX_SIZE)) {
+		(void)memset((int8_t *)log_secram_header,
+			0, sizeof(struct log_buf_header_t));
+		(void)memcpy(log_secram_header->prefix,
+			secram_prefix, sizeof(log_secram_header->prefix));
+	}
+}
+
+void log_buf_write(const struct msg_block_t *msg_block, int32_t msg_block_num)
+{
+	int8_t *log_area = NULL;
+	uint32_t end_index;
+	size_t ram_wsize;
+	size_t total_wsize = 0U;
+	size_t index_wsize;
+	size_t head_wsize;
+	int32_t i;
+
+	for (i = 0; i < msg_block_num; i++) {
+		if ((log_secram_header == NULL) ||
+		    (total_wsize >= LOG_AREA_MAX_SIZE)) {
+			break;
+		}
+		if (log_area == NULL) {
+			log_area = (int8_t *)(&log_secram_header[1]);
+		}
+		ram_wsize = msg_block[i].size;
+		if ((total_wsize + ram_wsize) > LOG_AREA_MAX_SIZE) {
+			ram_wsize = LOG_AREA_MAX_SIZE - total_wsize;
+		}
+
+		end_index = log_secram_header->index + ram_wsize;
+		head_wsize = 0U;
+
+		if (end_index > LOG_AREA_MAX_SIZE) {
+			head_wsize = end_index - LOG_AREA_MAX_SIZE;
+		}
+		index_wsize = ram_wsize - head_wsize;
+
+		(void)memcpy(&log_area[log_secram_header->index],
+			&msg_block[i].addr[0], index_wsize);
+		total_wsize += index_wsize;
+
+		if (0U < head_wsize) {
+			(void)memcpy(&log_area[0],
+				&msg_block[i].addr[index_wsize], head_wsize);
+			total_wsize += head_wsize;
+			log_secram_header->index = head_wsize;
+		} else {
+			log_secram_header->index += index_wsize;
+			if (log_secram_header->index == LOG_AREA_MAX_SIZE) {
+				log_secram_header->index = 0U;
+			}
+		}
+
+		if (log_secram_header->size < LOG_AREA_MAX_SIZE) {
+			log_secram_header->size += index_wsize;
+		}
+	}
+}
+
+#ifdef RCAR_DEBUG_LOG
+void log_debug_send(const struct msg_block_t *msg_block, int32_t msg_block_num)
+{
+	struct tee_ta_session *sess = NULL;
+	struct optee_msg_param params;
+	uint32_t cpu_id;
+	int8_t *log_area;
+	size_t log_offs = 0U;
+	size_t memcpy_size;
+	int32_t i;
+
+	if (log_nonsec_ptr != NULL) {
+		cpu_id = get_core_pos();
+		log_area = &log_nonsec_ptr[cpu_id * LOG_NS_CPU_AREA_SIZE];
+
+		for (i = 0; i < msg_block_num; i++) {
+			memcpy_size = msg_block[i].size;
+			if ((log_offs + memcpy_size) > LOG_SEND_MAX_SIZE) {
+				memcpy_size = LOG_SEND_MAX_SIZE - log_offs;
+			}
+			(void)memcpy(&log_area[log_offs],
+				msg_block[i].addr, memcpy_size);
+			log_offs += memcpy_size;
+		}
+		log_area[log_offs] = (int8_t)'\0';
+
+		tee_ta_get_current_session(&sess);
+		if (sess != NULL) {
+			tee_ta_set_current_session(NULL);
+		}
+
+		memset(&params, 0, sizeof(params));
+		params.attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT;
+		params.u.value.a = cpu_id;
+		params.u.value.b = 0U;
+
+		thread_rpc_cmd(TEE_RPC_DEBUG_LOG, 1, &params);
+
+		if (sess != NULL) {
+			tee_ta_set_current_session(sess);
+		}
+	}
+}
+#endif
diff --git a/core/arch/arm/plat-rcar/rcar_log_func.h b/core/arch/arm/plat-rcar/rcar_log_func.h
new file mode 100644
index 0000000..f95505f
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_log_func.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_LOG_FUNC_H
+#define RCAR_LOG_FUNC_H
+
+#include <types_ext.h>
+#include <kernel/mutex.h>
+#include <platform_config.h>
+
+/*
+ * Constant definition
+ */
+
+#define LOG_RAM_MAX_SIZE	(81920U)
+#define LOG_RAM_HEADER_SIZE	(16U)
+#define LOG_RAM_RESERVE_SIZE	(64U)
+#define LOG_AREA_MAX_SIZE	(LOG_RAM_MAX_SIZE - \
+				(LOG_RAM_HEADER_SIZE + LOG_RAM_RESERVE_SIZE))
+#define LOG_TIME_BUF_MAX_SIZE	(31)
+#define LOG_NS_CPU_AREA_SIZE	(1024U)
+#define LOG_SEC_PREFIX		"SLOG"
+#define LOG_SEC_PREFIX_LEN	(4)
+#define LOG_SEND_MAX_SIZE	(256U)
+
+#define SECRAM_MSG_BLK_NUM	(2)
+#define SECRAM_IDX_TIME		(0)
+#define SECRAM_IDX_MESG		(1)
+
+#define TRMLOG_MSG_BLK_NUM	(3)
+#define TRMLOG_IDX_PRFX		(0)
+#define TRMLOG_IDX_TIME		(1)
+#define TRMLOG_IDX_MESG		(2)
+
+#ifdef RCAR_DEBUG_LOG
+#define MSG_BLK_MAX_NUM		TRMLOG_MSG_BLK_NUM
+#else
+#define MSG_BLK_MAX_NUM		SECRAM_MSG_BLK_NUM
+#endif  /* RCAR_DEBUG_LOG */
+
+#define INTCTX_LOG_NOT_OUTPUT	(0U)
+#define INTCTX_LOG_OUTPUT	(1U)
+
+#ifndef RCAR_INTCTX_LOG
+#define INTCTX_LOG_DEFAULT	INTCTX_LOG_NOT_OUTPUT
+#else
+#define INTCTX_LOG_DEFAULT	INTCTX_LOG_OUTPUT
+#endif /* RCAR_INTCTX_LOG */
+
+/*
+ * Struct definition
+ */
+
+struct log_buf_header_t {
+	int8_t prefix[LOG_SEC_PREFIX_LEN];
+	uint32_t index;
+	uint32_t size;
+	uint32_t reserve;
+};
+
+struct msg_block_t {
+	const int8_t *addr;
+	size_t size;
+};
+
+/*
+ * Global variable declaration
+ */
+
+extern struct log_buf_header_t *log_secram_header;
+extern uint32_t log_spin_lock;
+extern int32_t is_normal_world_initialized;
+
+/*
+ * Prototype declaration
+ */
+
+void log_buf_init(void);
+void log_buf_write(const struct msg_block_t *msg_block, int32_t msg_block_num);
+#ifdef RCAR_DEBUG_LOG
+void log_debug_send(const struct msg_block_t *msg_block, int32_t msg_block_num);
+#endif /* RCAR_DEBUG_LOG */
+
+#endif /* RCAR_LOG_FUNC_H */
diff --git a/core/arch/arm/plat-rcar/rcar_maskrom.c b/core/arch/arm/plat-rcar/rcar_maskrom.c
new file mode 100644
index 0000000..6c25fb3
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_maskrom.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <string.h>
+#include <io.h>
+#include <tee_api_types.h>
+#include <trace.h>
+#include "platform_config.h"
+#include "rcar_common.h"
+#include "rcar_maskrom.h"
+
+/* Definitions */
+
+#ifdef ARM32
+/* H3 */
+#define ADDR_ROM_SECURE_API_H3		(0xeb101f54U)
+#define ADDR_ROM_GETLCS_API_H3		(0xeb1021b4U)
+/* M3 */
+#define ADDR_ROM_SECURE_API_M3		(0xeb103efcU)
+#define ADDR_ROM_GETLCS_API_M3		(0xeb10415cU)
+#else /* ARM64 */
+/* H3 */
+#define ADDR_ROM_SECURE_API_H3		(0xeb10dd64U)
+#define ADDR_ROM_GETLCS_API_H3		(0xeb10dfe0U)
+/* M3 */
+#define ADDR_ROM_SECURE_API_M3		(0xeb1102fcU)
+#define ADDR_ROM_GETLCS_API_M3		(0xeb110578U)
+#endif
+
+/* default value : R-Car H3 */
+uint32_t product_type = PRR_PRODUCT_H3;
+const int8_t *product_name = (const int8_t *)"H3";
+ROM_SECURE_API ROM_SecureBootAPI = (ROM_SECURE_API)ADDR_ROM_SECURE_API_H3;
+ROM_GETLCS_API ROM_GetLcs = (ROM_GETLCS_API)ADDR_ROM_GETLCS_API_H3;
+
+void product_setup(void)
+{
+	uint32_t reg;
+	uint32_t type;
+
+	reg = read32(PRR);
+	type = reg & PRR_PRODUCT_MASK;
+
+	switch (type) {
+	case PRR_PRODUCT_H3:
+		/* No Operation */
+		break;
+	case PRR_PRODUCT_M3:
+		product_type = PRR_PRODUCT_M3;
+		product_name = (const int8_t *)"M3";
+		ROM_SecureBootAPI = (ROM_SECURE_API)ADDR_ROM_SECURE_API_M3;
+		ROM_GetLcs = (ROM_GETLCS_API)ADDR_ROM_GETLCS_API_M3;
+		break;
+	default:
+		EMSG("Unknown product. PRR=0x%x", reg);
+		product_type = type | PRR_PRODUCT_UNKNOWN;
+		product_name = (const int8_t *)"unknown";
+		break;
+	}
+}
+
+uint32_t get_PRR_type(void)
+{
+	uint32_t reg;
+	uint32_t type;
+
+	reg = read32(PRR);
+	type = reg & PRR_PRODUCT_MASK;
+	return type;
+}
+
+uint32_t switch_stack_pointer(void *func, uint8_t *data)
+{
+	return asm_switch_stack_pointer((uintptr_t)func,
+			NONCACHE_STACK_AREA, data);
+}
+
diff --git a/core/arch/arm/plat-rcar/rcar_maskrom.h b/core/arch/arm/plat-rcar/rcar_maskrom.h
new file mode 100644
index 0000000..19faf8c
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_maskrom.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_MASKROM_H_
+#define RCAR_MASKROM_H_
+
+#define MASKROM_CRYPTO_ENGINE_BASE_ADDRESS	(0xE6600000U)
+
+#define NONCACHE_STACK_AREA		(NONCACHE_WORK_BASE + \
+					NONCACHE_WORK_SIZE)
+
+typedef uint32_t (*ROM_FuncReadFlash) (
+			uint64_t srcAddr,
+			uint8_t *pDest,
+			uint32_t sizeToRead);
+
+typedef uint32_t (*ROM_SECURE_API)(uint32_t *pKeyCert,
+			uint32_t *pContentCert,
+			ROM_FuncReadFlash pFuncReadFlash);
+
+typedef uint32_t(*ROM_GETLCS_API)(uint32_t *pLcs);
+
+extern ROM_SECURE_API ROM_SecureBootAPI;
+extern ROM_GETLCS_API ROM_GetLcs;
+
+void product_setup(void);
+uint32_t asm_switch_stack_pointer(uintptr_t jump, uint32_t stack, void *arg);
+uint32_t switch_stack_pointer(void *func, uint8_t *data);
+uint32_t get_PRR_type(void);
+
+#endif /* RCAR_MASKROM_H_ */
diff --git a/core/arch/arm/plat-rcar/rcar_ta_auth.c b/core/arch/arm/plat-rcar/rcar_ta_auth.c
new file mode 100644
index 0000000..1ec2966
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_ta_auth.c
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <string.h>
+#include <io.h>
+#include <trace.h>
+
+#include "rcar_common.h"
+#include "rcar_maskrom.h"
+#include "rcar_ta_auth.h"
+#include "platform_config.h"
+
+#define TA_KEY_CERT_AREA_SIZE		(4096U)
+#define TA_CONTENT_CERT_AREA_SIZE	(4096U)
+#define TA_NONCACHE_STACK_AREA_SIZE	(4096U)
+#define TA_NONCACHE_STACK_ADDR		(TA_VERIFICATION_BASE + \
+					TA_VERIFICATION_SIZE)
+#define TA_CONTENT_CERT_ADDR		(TA_NONCACHE_STACK_ADDR - \
+					TA_NONCACHE_STACK_AREA_SIZE - \
+					TA_CONTENT_CERT_AREA_SIZE)
+#define TA_KEY_CERT_ADDR		(TA_CONTENT_CERT_ADDR - \
+					TA_KEY_CERT_AREA_SIZE)
+#define CERT_SIGNATURE_SIZE		(256U)
+#define CERT_STORE_ADDR_SIZE		(8U)
+#define CERT_REC_LEN_SIZE		(4U)
+#define CERT_ADD_DATA_SIZE		(CERT_STORE_ADDR_SIZE + \
+					CERT_REC_LEN_SIZE)
+#define CERT_OFS_BIT_SIZE		(0xffffU)
+#define CERT_BLOCK_SIZE			(4U)
+#define CERT_IDX_MAGIC			(0)
+#define CERT_IDX_VER			(1)
+#define CERT_IDX_SIZE			(2)
+#define CERT_IDX_FLAG			(3)
+#define KEY_CERT_DEFAULT_SIZE		(0x24cU)
+#define CONTENT_CERT_DEFAULT_SIZE	(0x268U)
+#define RST_MODEMR			(RST_BASE + 0x0060U)
+#define MFIS_SOFTMDR			(MFIS_BASE + 0x0600U)
+#define LCS_CM				(0x0U)
+#define LCS_DM				(0x1U)
+#define LCS_SD				(0x3U)
+#define LCS_SE				(0x5U)
+#define LCS_FA				(0x7U)
+#define SECURE_BOOT_MODE		(0U)
+#define NORMAL_BOOT_MODE		(1U)
+
+/* Declaration of internal function */
+static uint32_t get_key_cert_size(const uint32_t *cert_header);
+static uint32_t get_content_cert_size(const uint32_t *cert_header);
+static uint32_t get_object_size(const void *content_cert);
+static uint32_t get_auth_mode(void);
+static uint32_t call_maskrom_api(void);
+
+static uint32_t get_key_cert_size(const uint32_t *cert_header)
+{
+	uint32_t cert_size;
+
+	cert_size = ((cert_header[CERT_IDX_SIZE] & CERT_OFS_BIT_SIZE) *
+		CERT_BLOCK_SIZE) + CERT_SIGNATURE_SIZE;
+
+	return cert_size;
+}
+
+static uint32_t get_content_cert_size(const uint32_t *cert_header)
+{
+	uint32_t cert_size;
+
+	cert_size = get_key_cert_size(cert_header) + CERT_ADD_DATA_SIZE;
+
+	return cert_size;
+}
+
+static uint32_t get_object_size(const void *content_cert)
+{
+	uint32_t obj_size;
+	const uint32_t *cert_header;
+	uint32_t offset;
+	const void *obj_len;
+
+	cert_header = (const uint32_t *)content_cert;
+	offset = ((cert_header[CERT_IDX_SIZE] & CERT_OFS_BIT_SIZE) *
+		CERT_BLOCK_SIZE) + CERT_SIGNATURE_SIZE +
+		CERT_STORE_ADDR_SIZE;
+	obj_len = (const uint8_t *)content_cert + offset;
+	obj_size = *(const uint32_t *)obj_len;
+	obj_size *= CERT_BLOCK_SIZE;
+
+	return obj_size;
+}
+
+static uint32_t get_auth_mode(void)
+{
+	uint32_t ret;
+	uint32_t lcs;
+	uint32_t md;
+	uint32_t softmd;
+	uint32_t auth_mode;
+
+	/* default is Secure boot */
+	auth_mode = SECURE_BOOT_MODE;
+
+	ret = ROM_GetLcs(&lcs);
+	if (ret == 0U) {
+		if (lcs == LCS_SE) {
+			softmd = (read32(MFIS_SOFTMDR) & 0x00000001U);
+			if (softmd == 0x1U) {
+				/* LCS=Secure + Normal boot (temp setting) */
+				auth_mode = NORMAL_BOOT_MODE;
+			} else {
+				/* LCS=Secure + Secure boot */
+			}
+		} else {
+			md = (read32(RST_MODEMR) & 0x00000020U) >> 5;
+			if (md != 0U) {
+				/* MD5=1 => LCS=CM/DM + Normal boot */
+				auth_mode = NORMAL_BOOT_MODE;
+			} else {
+				/* MD5=0 => LCS=CM/DM + Secure boot */
+			}
+		}
+	} else {
+		EMSG("lcs read error.");
+	}
+
+	return auth_mode;
+}
+
+/* This function operates in a non-cached stack. */
+static uint32_t call_maskrom_api(void)
+{
+	uint32_t ret;
+	uint32_t *key_cert = (uint32_t *)TA_KEY_CERT_ADDR;
+	uint32_t *content_cert = (uint32_t *)TA_CONTENT_CERT_ADDR;
+
+	ret = ROM_SecureBootAPI(key_cert, content_cert, NULL);
+
+	return ret;
+}
+
+TEE_Result rcar_auth_ta_certificate(const void *key_cert,
+				struct shdr **secmem_ta)
+{
+	TEE_Result res = TEE_ERROR_SECURITY;
+	uint32_t ret;
+	uint32_t key_cert_size;
+	uint32_t content_cert_size;
+	uint32_t object_size;
+	uint32_t auth_mode;
+	const void *content_cert;
+	struct shdr *fixed_ta = (struct shdr *)TA_VERIFICATION_BASE;
+	uint8_t *fixed_base = (uint8_t *)TA_VERIFICATION_BASE;
+	uint8_t *fixed_key_cert = (uint8_t *)TA_KEY_CERT_ADDR;
+	uint8_t *fixed_content_cert = (uint8_t *)TA_CONTENT_CERT_ADDR;
+
+	key_cert_size = get_key_cert_size((const uint32_t *)key_cert);
+	if (key_cert_size > TA_KEY_CERT_AREA_SIZE) {
+		key_cert_size = KEY_CERT_DEFAULT_SIZE;
+	}
+	content_cert = (const uint8_t *)key_cert + key_cert_size;
+	content_cert_size = get_content_cert_size(
+				(const uint32_t *)content_cert);
+	if (content_cert_size > TA_CONTENT_CERT_AREA_SIZE) {
+		content_cert_size = CONTENT_CERT_DEFAULT_SIZE;
+	}
+	object_size = get_object_size(content_cert);
+
+	DMSG("TA size: key_cert=0x%x content_cert=0x%x shdr+bin=0x%x",
+		key_cert_size, content_cert_size, object_size);
+
+	/*
+	 *   Fixed memory map          | TotalSize=TA_VERIFICATION_SIZE
+	 * ---------------------------------------------------------------
+	 * | TA object data area       | TotalSize - [1] - [2] - [3]     |
+	 * | (signed header + binary)  |                                 |
+	 * ---------------------------------------------------------------
+	 * | Key Certificate area      | [1]=TA_KEY_CERT_AREA_SIZE       |
+	 * ---------------------------------------------------------------
+	 * | Content Certificate area  | [2]=TA_CONTENT_CERT_AREA_SIZE   |
+	 * ---------------------------------------------------------------
+	 * | Non-cache Stack area      | [3]=TA_NONCACHE_STACK_AREA_SIZE |
+	 * ---------------------------------------------------------------
+	 */
+	if ((product_type & PRR_PRODUCT_UNKNOWN) != 0U) {
+		EMSG("Unknown product error. product=0x%x r=0x%x",
+			product_type & PRR_PRODUCT_MASK, res);
+	} else if ((fixed_base + object_size) <= fixed_key_cert) {
+
+		/* copy to fixed memory */
+		(void)memcpy(fixed_base,
+			(const uint8_t *)content_cert + content_cert_size,
+			object_size);
+		(void)memcpy(fixed_key_cert,
+			(const uint8_t *)key_cert,
+			key_cert_size);
+		(void)memcpy(fixed_content_cert,
+			(const uint8_t *)content_cert,
+			content_cert_size);
+
+		auth_mode = get_auth_mode();
+		if (auth_mode == SECURE_BOOT_MODE) {
+
+			/* call the MaskROM API */
+			ret = asm_switch_stack_pointer(
+				(uintptr_t)call_maskrom_api,
+				TA_NONCACHE_STACK_ADDR, NULL);
+			if (ret == 0U) {
+				DMSG("[%s] Secure boot success!", product_name);
+				*secmem_ta = fixed_ta;
+				res = TEE_SUCCESS;
+			} else {
+				EMSG("[%s] Secure boot error. 0x%x",
+					product_name, ret);
+			}
+		} else {
+			DMSG("[%s] Normal boot", product_name);
+			*secmem_ta = fixed_ta;
+			res = TEE_SUCCESS;
+		}
+	} else {
+		EMSG("Overflow error. r=0x%x", res);
+	}
+
+	return res;
+}
diff --git a/core/arch/arm/plat-rcar/rcar_ta_auth.h b/core/arch/arm/plat-rcar/rcar_ta_auth.h
new file mode 100644
index 0000000..be77284
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_ta_auth.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_TA_AUTH_H
+#define RCAR_TA_AUTH_H
+
+#include <stdint.h>
+#include <signed_hdr.h>
+#include "tee_api_types.h"
+
+TEE_Result rcar_auth_ta_certificate(const void *key_cert,
+				struct shdr **secmem_ta);
+
+#endif /* RCAR_TA_AUTH_H */
diff --git a/core/arch/arm/plat-rcar/rcar_version.h b/core/arch/arm/plat-rcar/rcar_version.h
new file mode 100644
index 0000000..8e62247
--- /dev/null
+++ b/core/arch/arm/plat-rcar/rcar_version.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef RCAR_VERSION_H
+#define RCAR_VERSION_H
+
+#include <stdint.h>
+
+#define VERSION_OF_RENESAS	"1.0.5"
+
+extern const int8_t version_of_renesas[];
+
+#endif /* RCAR_VERSION_H */
diff --git a/core/arch/arm/plat-rcar/sub.mk b/core/arch/arm/plat-rcar/sub.mk
new file mode 100644
index 0000000..4c1b85c
--- /dev/null
+++ b/core/arch/arm/plat-rcar/sub.mk
@@ -0,0 +1,19 @@
+global-incdirs-y += .
+global-incdirs-y += include
+srcs-y += main.c
+srcs-$(CFG_OTP_SUPPORT) += tee_common_otp.c
+srcs-y += rcar_lock.c
+srcs-y += rcar_log_func.c
+srcs-y += rcar_ddr_training.c
+srcs-$(CFG_ARM32_core) += rcar_interruptflags_a32.S
+srcs-$(CFG_ARM64_core) += rcar_interruptflags_a64.S
+srcs-$(CFG_DYNAMIC_TA_AUTH_BY_HWENGINE) += rcar_ta_auth.c
+srcs-$(CFG_ARM32_core) += rcar_call_maskrom_a32.S
+srcs-$(CFG_ARM64_core) += rcar_call_maskrom_a64.S
+srcs-y += rcar_maskrom.c
+
+# Copy the base file - /core/arch/arm/kernel/
+srcs-y += trace_ext.c
+
+subdirs-y += drivers
+subdirs-y += tee
diff --git a/core/arch/arm/plat-rcar/tee/sub.mk b/core/arch/arm/plat-rcar/tee/sub.mk
new file mode 100644
index 0000000..ef88c85
--- /dev/null
+++ b/core/arch/arm/plat-rcar/tee/sub.mk
@@ -0,0 +1,3 @@
+global-incdirs-y += .
+srcs-$(CFG_STANDALONE_FS) += tee_standalone_fs.c
+srcs-$(CFG_STANDALONE_FS) += tee_standalone_fs_key_manager.c
diff --git a/core/arch/arm/plat-rcar/tee/tee_standalone_fs.c b/core/arch/arm/plat-rcar/tee/tee_standalone_fs.c
new file mode 100644
index 0000000..b1f213e
--- /dev/null
+++ b/core/arch/arm/plat-rcar/tee/tee_standalone_fs.c
@@ -0,0 +1,2538 @@
+/*
+ * Copyright (c) 2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <string_ext.h>
+#include <assert.h>
+#include <tee/tee_fs.h>
+#include <tee/tee_fs_defs.h>
+#include <tee/tee_cryp_provider.h>
+#include <kernel/tee_common_unpg.h>
+#include <kernel/handle.h>
+#include <kernel/mutex.h>
+#include <trace.h>
+#include <initcall.h>
+
+#include "tee_standalone_fs.h"
+#include "platform_config.h"
+
+static struct spim_sector_info g_sector[SURFACE_NUM][SAVE_SECTOR_NUM];
+static int32_t g_current_surface[SAVE_SECTOR_NUM];
+static struct handle_db g_fd_handle_db = HANDLE_DB_INITIALIZER;
+static struct handle_db g_rd_handle_db = HANDLE_DB_INITIALIZER;
+static struct mutex g_standalone_fs_mutex = MUTEX_INITIALIZER;
+static TEE_Result g_standalone_fs_status = TEE_ERROR_STORAGE_NOT_AVAILABLE;
+static uint8_t *g_work_buf;
+static uint8_t *g_record_data_buf;
+
+static TEE_Result tee_standalone_fs_init(void);
+static TEE_Result spi_init_sector_info(void);
+static TEE_Result spi_get_status(void);
+static TEE_Result spi_get_status_and_check_file(const char **pfile,
+			size_t *len_out);
+static TEE_Result spi_get_status_and_check_dir(const char **pdir,
+			size_t *len_out);
+static TEE_Result spi_check_file(const char **pfile, size_t *len_out);
+static TEE_Result spi_check_path(const char **ppath, size_t *len_out,
+			uint16_t ftype);
+static void spi_lock(void);
+static void spi_unlock(void);
+static TEE_Result spi_encrypt_term_info(const struct spif_term_info *term_info,
+			uint8_t *encrypt_buf);
+static TEE_Result spi_read_term_info(uint32_t sector_addr,
+			struct spif_term_info *term_info);
+static void spi_update_write_count(uint8_t *write_count);
+static uint32_t spi_ceil_ek_size(uint32_t not_align_size);
+static uint32_t spi_get_record_info_size(
+			const struct spim_record_descriptor *rdesc);
+static TEE_Result spi_assign_record_info(uint32_t assign_size,
+			int32_t *sector_idx_out,
+			uint32_t *record_offset_out);
+static TEE_Result spi_write_record_info(struct spim_record_descriptor *rdesc,
+			uint32_t new_size, uint32_t old_size);
+static struct spim_record_descriptor *spi_create_record_info(
+			const char *path, size_t path_len,
+			uint16_t attr, TEE_Result *res_out);
+static TEE_Result spi_update_record_info(struct spim_record_descriptor *rdesc,
+			uint32_t old_size);
+static TEE_Result spi_delete_record_info(struct spim_record_descriptor *rdesc);
+static TEE_Result spi_encrypt_record_info(
+			const struct spif_record_info *record_info,
+			uint8_t *encrypt_buf);
+static TEE_Result spi_read_record_head(uint32_t flash_addr,
+			struct spif_record_head *record_head);
+static TEE_Result spi_read_record_meta(uint32_t flash_addr,
+			const struct spif_record_head *record_head,
+			struct spif_record_meta *record_meta);
+static TEE_Result spi_read_record_data(struct spim_record_descriptor *rdesc);
+static void spi_get_parent_dir(const char *path, size_t path_len,
+			const char **parent_dir, size_t *parent_dir_len);
+static void spi_get_filename(const char *path, size_t path_len,
+			const char **filename);
+static TEE_Result spi_get_hod_from_path(const char *path, size_t path_len,
+			uint32_t *hod);
+static TEE_Result spi_get_hod(const char *dir, size_t dir_len, uint32_t *hod);
+static TEE_Result spi_find_file(const char *file, size_t file_len);
+static TEE_Result spi_find_dir(const char *dir, size_t dir_len);
+static TEE_Result spi_find_file_under_dir(const char *dir, size_t dir_len);
+static struct spim_record_descriptor *spi_find_file_and_generate_rdesc(
+			const char *file, size_t file_len);
+static struct spim_record_descriptor *spi_find_dir_and_generate_rdesc(
+			const char *dir, size_t dir_len);
+static struct spim_record_descriptor *spi_find_path_and_generate_rdesc(
+			const struct spio_find_info *f);
+static TEE_Result spi_find_path(const struct spio_find_info *f);
+static TEE_Result spi_search_flash_for_record_info(
+			const struct spio_find_info *f,
+			int32_t *search_sector_idx,
+			uint32_t *search_record_offset,
+			struct spif_record_info *record_info);
+static TEE_Result spi_match_record_info(const struct spio_find_info *f,
+			uint32_t flash_addr,
+			struct spif_record_info *record_info,
+			uint32_t *next_addr);
+static struct spim_sector_info *spi_get_current_sector(int32_t sector_idx);
+static struct spim_sector_info *spi_get_next_sector(int32_t sector_idx);
+static void spi_commit_sector(int32_t sector_idx,
+			const struct spif_term_info *new_term_info);
+static struct spim_file_descriptor *spi_alloc_fdp(int32_t flags,
+			struct spim_record_descriptor *rdesc);
+static void spi_free_fdp(struct spim_file_descriptor *fdp);
+static struct spim_file_descriptor *spi_get_fdp(int32_t fd);
+static struct spim_record_descriptor *spi_alloc_rdesc(
+			const struct spif_record_head *record_head,
+			const struct spif_record_meta *record_meta);
+static void spi_free_rdesc(struct spim_record_descriptor *rdesc);
+static struct spim_record_descriptor *spi_get_rdesc(int32_t rd);
+static TEE_Result spi_find_rdesc(const struct spio_find_info *f,
+			struct spim_record_descriptor **rdesc_out);
+static void spi_update_rdesc(const struct spim_record_descriptor *update_rdesc,
+			int32_t difference, uint32_t update_size);
+static struct tee_fs_dir *spi_alloc_dirst(const char *dir, size_t dir_len);
+static void spi_free_dirst(struct tee_fs_dir *dirst);
+static TEE_Result spi_read_flash(uint32_t flash_addr, uint8_t *buf,
+			size_t rsize);
+static TEE_Result spi_erase_and_write_sector(uint32_t sector_addr,
+			const uint8_t *encrypted_record_buf,
+			uint32_t record_buf_size,
+			const uint8_t *encrypted_term_info);
+
+static TEE_Result tee_standalone_open(const char *file, size_t file_len,
+			int flags, int *fd_out);
+static TEE_Result tee_standalone_close(struct spim_file_descriptor *fdp);
+static TEE_Result tee_standalone_read(struct spim_file_descriptor *fdp,
+			void *buf, size_t buf_len, int *read_size);
+static TEE_Result tee_standalone_write(struct spim_file_descriptor *fdp,
+			const void *buf, size_t buf_len, int *write_size);
+static TEE_Result tee_standalone_lseek(struct spim_file_descriptor *fdp,
+			tee_fs_off_t offset, int whence, tee_fs_off_t *new_pos);
+static TEE_Result tee_standalone_rename(const char *old_file, size_t old_len,
+			const char *new_file, size_t new_len);
+static TEE_Result tee_standalone_unlink(const char *file, size_t file_len);
+static TEE_Result tee_standalone_ftruncate(struct spim_file_descriptor *fdp,
+			tee_fs_off_t length);
+static TEE_Result tee_standalone_mkdir(const char *path, size_t path_len,
+			tee_fs_mode_t mode);
+static struct tee_fs_dir *tee_standalone_opendir(const char *name,
+			size_t name_len);
+static TEE_Result tee_standalone_closedir(struct tee_fs_dir *dirst);
+static struct tee_fs_dirent *tee_standalone_readdir(
+			struct tee_fs_dir *dirst);
+static TEE_Result tee_standalone_rmdir(const char *path, size_t path_len);
+static TEE_Result tee_standalone_access(const char *name, size_t name_len,
+			int mode);
+
+static int standalone_fs_open(TEE_Result *errno, const char *file,
+			int flags, ...);
+static int standalone_fs_close(int fd);
+static int standalone_fs_read(TEE_Result *errno, int fd, void *buf, size_t len);
+static int standalone_fs_write(TEE_Result *errno, int fd, const void *buf,
+			size_t len);
+static tee_fs_off_t standalone_fs_lseek(TEE_Result *errno, int fd,
+			tee_fs_off_t offset, int whence);
+static int standalone_fs_rename(const char *old, const char *new);
+static int standalone_fs_unlink(const char *file);
+static int standalone_fs_ftruncate(TEE_Result *errno, int fd,
+			tee_fs_off_t length);
+static int standalone_fs_mkdir(const char *path, tee_fs_mode_t mode);
+static struct tee_fs_dir *standalone_fs_opendir(const char *name);
+static int standalone_fs_closedir(struct tee_fs_dir *d);
+static struct tee_fs_dirent *standalone_fs_readdir(struct tee_fs_dir *d);
+static int standalone_fs_rmdir(const char *pathname);
+static int standalone_fs_access(const char *name, int mode);
+
+static TEE_Result tee_standalone_fs_init(void)
+{
+	TEE_Result res;
+	uint32_t ret;
+
+	res = tee_sfkm_init_key_manager();
+
+	if (res == TEE_SUCCESS) {
+		ret = qspi_hyper_flash_init();
+		if (ret != FL_DRV_OK) {
+			res = TEE_ERROR_TARGET_DEAD;
+		}
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = spi_init_sector_info();
+	}
+
+	if (res == TEE_SUCCESS) {
+		g_standalone_fs_status = res;
+	}
+
+	return res;
+}
+
+driver_init(tee_standalone_fs_init);
+
+static TEE_Result spi_init_sector_info(void)
+{
+	TEE_Result res;
+	int32_t i;
+	int32_t j;
+	uint32_t lsector_addr;
+	struct spim_sector_info *sector;
+	struct spim_sector_info *sector_curr;
+	struct spim_sector_info *sector_next;
+	uint8_t wcnt1;
+	uint8_t wcnt2;
+	uint8_t wcnt_match;
+
+	(void)memset(g_sector, 0, sizeof(g_sector));
+	(void)memset(g_current_surface, 0, sizeof(g_current_surface));
+	g_work_buf = (uint8_t *)OPTEE_LOG_BASE + 204800U;
+	g_record_data_buf = g_work_buf + SECTOR_SIZE; /* RECORD_DATA_BUF_SIZE */
+	lsector_addr = STANDALONE_FS_SECTOR_ADDR;
+
+	for (i = 0; i < SURFACE_NUM; i++) {
+		for (j = 0; j < SAVE_SECTOR_NUM; j++) {
+			sector = &g_sector[i][j];
+			res = spi_read_term_info(lsector_addr,
+					&sector->term_info);
+			if (res != TEE_SUCCESS) {
+				if (res != TEE_ERROR_MAC_INVALID) {
+					EMSG("term info read error!");
+				}
+				(void)memset(&sector->term_info, 0,
+					sizeof(struct spif_term_info));
+				sector->term_info.write_count =
+					WRITE_CNT_DEFAULT;
+				res = TEE_SUCCESS;
+			}
+			sector->sector_addr = lsector_addr;
+			lsector_addr += SECTOR_SIZE;
+		}
+	}
+
+	for (i = 0; i < SAVE_SECTOR_NUM; i++) {
+		wcnt1 = g_sector[0][i].term_info.write_count;
+		wcnt2 = g_sector[1][i].term_info.write_count;
+		if (wcnt1 == wcnt2) {
+			g_current_surface[i] = 1;
+		} else if (wcnt1 > wcnt2) {
+			if ((wcnt1 == WRITE_CNT_MAX) &&
+			    (wcnt2 == WRITE_CNT_MIN)) {
+				g_current_surface[i] = 0;
+			} else {
+				g_current_surface[i] = 1;
+			}
+		} else {
+			if ((wcnt2 == WRITE_CNT_MAX) &&
+			    (wcnt1 == WRITE_CNT_MIN)) {
+				g_current_surface[i] = 1;
+			} else {
+				g_current_surface[i] = 0;
+			}
+		}
+
+		if ((wcnt1 != WRITE_CNT_DEFAULT) &&
+		    (wcnt2 != WRITE_CNT_DEFAULT)) {
+			sector_curr = spi_get_current_sector(i);
+			sector_next = spi_get_next_sector(i);
+			wcnt_match = sector_next->term_info.write_count;
+			spi_update_write_count(&wcnt_match);
+			if (wcnt_match != sector_curr->term_info.write_count) {
+				/* Write Count does not match */
+				(void)memset(&sector_curr->term_info, 0,
+					sizeof(struct spif_term_info));
+				sector_curr->term_info.write_count =
+					WRITE_CNT_DEFAULT;
+				(void)memcpy(&sector_next->term_info,
+					&sector_curr->term_info,
+					sizeof(struct spif_term_info));
+				g_current_surface[i] = 1;
+				EMSG("reinit sector info");
+			}
+		}
+	}
+
+	return res;
+}
+
+static TEE_Result spi_get_status(void)
+{
+	return g_standalone_fs_status;
+}
+
+static TEE_Result spi_get_status_and_check_file(const char **pfile,
+			size_t *len_out)
+{
+	TEE_Result res;
+
+	res = spi_get_status();
+	if (res == TEE_SUCCESS) {
+		res = spi_check_file(pfile, len_out);
+	}
+
+	return res;
+}
+
+static TEE_Result spi_get_status_and_check_dir(const char **pdir,
+			size_t *len_out)
+{
+	TEE_Result res;
+
+	res = spi_get_status();
+	if (res == TEE_SUCCESS) {
+		res = spi_check_path(pdir, len_out, SAFS_ATTR_DATA_DIR);
+	}
+
+	return res;
+}
+
+static TEE_Result spi_check_file(const char **pfile, size_t *len_out)
+{
+	return spi_check_path(pfile, len_out, SAFS_ATTR_DATA_FILE);
+}
+
+static TEE_Result spi_check_path(const char **ppath, size_t *len_out,
+			uint16_t ftype)
+{
+	TEE_Result res;
+	size_t lpath_len;
+	const char *lpath;
+	uint32_t i;
+
+	lpath = *ppath;
+	lpath_len = strlen(lpath);
+
+	if (lpath_len <= PATH_MAX_LEN) {
+		if ((ftype == SAFS_ATTR_DATA_FILE) &&
+		    (lpath[lpath_len - 1] == '/')) {
+			res = TEE_ERROR_BAD_PARAMETERS;
+		} else {
+			res = TEE_SUCCESS;
+			for (i = 0; i < lpath_len; i++) {
+				if (lpath[i] == '/') {
+					if ((i + 1) == lpath_len) {
+						lpath_len--;
+					} else if (lpath[i + 1] == '/') {
+						res = TEE_ERROR_BAD_PARAMETERS;
+						break;
+					} else {
+						/* no operation */
+					}
+					if (i == 0) {
+						if (lpath_len > 0) {
+							lpath_len--;
+						}
+						lpath++;
+					}
+				}
+			}
+			if (res == TEE_SUCCESS) {
+				*len_out = lpath_len;
+			}
+		}
+	} else {
+		res = TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	return res;
+}
+
+static void spi_lock(void)
+{
+	mutex_lock(&g_standalone_fs_mutex);
+}
+
+static void spi_unlock(void)
+{
+	mutex_unlock(&g_standalone_fs_mutex);
+}
+
+static TEE_Result spi_encrypt_term_info(const struct spif_term_info *term_info,
+			uint8_t *encrypt_buf)
+{
+	TEE_Result res;
+	struct tee_sfkm_crypt_info c;
+
+	c.data_in	= (const uint8_t *)&term_info->record_num;
+	c.data_size	= TERM_INFO_ENC_SIZE;
+	c.iv		= term_info->iv;
+	c.iv_size	= SAFS_IV_LEN;
+
+	res = tee_sfkm_encrypt_suk(&c,
+			encrypt_buf + TERM_INFO_ENC_OFFSET,
+			encrypt_buf + SAFS_IV_LEN,	/* Tag */
+			encrypt_buf);			/* Encrypted IV */
+
+	return res;
+}
+
+static TEE_Result spi_read_term_info(uint32_t sector_addr,
+			struct spif_term_info *term_info)
+{
+	TEE_Result res;
+	uint8_t encrypted_data[TERM_INFO_SIZE];
+	struct tee_sfkm_crypt_info c;
+
+	res = spi_read_flash(sector_addr + TERM_INFO_OFFSET,
+			encrypted_data, sizeof(encrypted_data));
+
+	if (res == TEE_SUCCESS) {
+		c.data_in	= encrypted_data + TERM_INFO_ENC_OFFSET;
+		c.data_size	= TERM_INFO_ENC_SIZE;
+		c.iv		= encrypted_data;	/* Encrypted IV */
+		c.iv_size	= SAFS_IV_LEN;
+
+		res = tee_sfkm_decrypt_suk(&c,
+				encrypted_data + SAFS_IV_LEN,	/* Tag */
+				(uint8_t *)&term_info->record_num,
+				term_info->iv);
+
+		if (res == TEE_SUCCESS) {
+			(void)memcpy(term_info->tag,
+				encrypted_data + SAFS_IV_LEN,
+				SAFS_TAG_LEN);
+		}
+	}
+
+	return res;
+}
+
+static void spi_update_write_count(uint8_t *write_count)
+{
+	uint8_t new_count;
+
+	new_count = *write_count;
+
+	new_count--;
+	if (new_count < WRITE_CNT_MIN) {
+		new_count = WRITE_CNT_MAX;
+	}
+
+	*write_count = new_count;
+}
+
+static uint32_t spi_ceil_ek_size(uint32_t not_align_size)
+{
+	uint32_t ceil_size; /* ceil encryption key size */
+	uint32_t mod_size;
+
+	mod_size = not_align_size % SAFS_EK_SIZE;
+
+	if (mod_size == 0U) {
+		ceil_size = not_align_size;
+	} else {
+		ceil_size = not_align_size + (SAFS_EK_SIZE - mod_size);
+	}
+
+	return ceil_size;
+}
+
+static uint32_t spi_get_record_info_size(
+			const struct spim_record_descriptor *rdesc)
+{
+	uint32_t rinfo_size;
+
+	/* Record Head + Record Meta */
+	rinfo_size = RECORD_HEAD_SIZE + RECORD_META_FIXED_SIZE +
+		spi_ceil_ek_size(rdesc->record_info.record_head.path_len);
+
+	if (rdesc->record_info.record_head.data_len > 0U) {
+		/* Record Data */
+		rinfo_size += RECORD_DATA_FIXED_SIZE + spi_ceil_ek_size(
+			rdesc->record_info.record_head.data_len);
+	}
+
+	return rinfo_size;
+}
+
+static TEE_Result spi_assign_record_info(uint32_t assign_size,
+			int32_t *sector_idx_out,
+			uint32_t *record_offset_out)
+{
+	TEE_Result res;
+	struct spim_sector_info *sector;
+	int32_t lsector_idx;
+	uint32_t empty_size;
+	uint32_t max_empty_size = 0U;
+	int32_t assign_sector_idx = 0;
+	uint32_t assign_record_offset = 0U;
+
+	for (lsector_idx = 0; lsector_idx < SAVE_SECTOR_NUM; lsector_idx++) {
+		sector = spi_get_current_sector(lsector_idx);
+		empty_size = TERM_INFO_OFFSET - sector->term_info.empty_offset;
+		if ((assign_size <= empty_size) &&
+		    (empty_size > max_empty_size)) {
+			assign_sector_idx = lsector_idx;
+			assign_record_offset = sector->term_info.empty_offset;
+			max_empty_size = empty_size;
+		}
+	}
+
+	if (max_empty_size > 0) {
+		*sector_idx_out = assign_sector_idx;
+		*record_offset_out = assign_record_offset;
+		res = TEE_SUCCESS;
+	} else {
+		res = TEE_ERROR_STORAGE_NO_SPACE;
+	}
+
+	return res;
+}
+
+static TEE_Result spi_write_record_info(struct spim_record_descriptor *rdesc,
+			uint32_t new_size, uint32_t old_size)
+{
+	TEE_Result res = TEE_SUCCESS;
+	struct spim_sector_info *sector_current;
+	struct spim_sector_info *sector_next;
+	struct spif_term_info eterm_info; /* entity */
+	uint32_t total_record_size;
+	uint32_t upper_half_size;
+	uint32_t bottom_half_size;
+	uint32_t buf_offset = 0U;
+	int32_t difference;
+	uint8_t *enc_buf;
+	uint8_t *enc_record_buf = NULL;
+	const uint8_t uninit_iv[SAFS_IV_LEN] = {0};
+
+	sector_current = spi_get_current_sector(rdesc->sector_idx);
+	sector_next = spi_get_next_sector(rdesc->sector_idx);
+	enc_buf = g_work_buf;
+
+	difference = new_size - old_size;
+	upper_half_size = rdesc->record_offset;
+	bottom_half_size = sector_current->term_info.empty_offset -
+			rdesc->record_offset - old_size;
+	total_record_size = upper_half_size + new_size + bottom_half_size;
+
+	if (total_record_size <= TERM_INFO_OFFSET) {
+		if (upper_half_size > 0U) {
+			res = spi_read_flash(
+					sector_current->sector_addr,
+					enc_buf,
+					upper_half_size);
+			if (res == TEE_SUCCESS) {
+				buf_offset = upper_half_size;
+			}
+		}
+		if ((res == TEE_SUCCESS) && (new_size > 0U)) {
+			res = spi_encrypt_record_info(
+					&rdesc->record_info,
+					enc_buf + buf_offset);
+			if (res == TEE_SUCCESS) {
+				buf_offset += new_size;
+			}
+		}
+		if ((res == TEE_SUCCESS) && (bottom_half_size > 0U)) {
+			res = spi_read_flash(
+					sector_current->sector_addr +
+					upper_half_size + old_size,
+					enc_buf + buf_offset,
+					bottom_half_size);
+			if (res == TEE_SUCCESS) {
+				buf_offset += bottom_half_size;
+			}
+		}
+
+		if (res == TEE_SUCCESS) {
+			(void)memcpy(&eterm_info, &sector_current->term_info,
+				sizeof(struct spif_term_info));
+			if ((new_size > 0U) && (old_size == 0U)) {
+				eterm_info.record_num++;
+			} else if ((new_size == 0U) && (old_size > 0U)) {
+				eterm_info.record_num--;
+			} else {
+				/* no operation */
+			}
+			eterm_info.empty_offset = buf_offset;
+			spi_update_write_count(&eterm_info.write_count);
+			if (memcmp(eterm_info.iv, uninit_iv, SAFS_IV_LEN)
+			    == 0) {
+				res = tee_sfkm_generate_random(eterm_info.iv,
+						SAFS_IV_LEN);
+			}
+		}
+		if (res == TEE_SUCCESS) {
+			res = spi_encrypt_term_info(&eterm_info,
+					&enc_buf[TERM_INFO_OFFSET]);
+		}
+		if (res == TEE_SUCCESS) {
+			if (eterm_info.record_num > 0) {
+				enc_record_buf = enc_buf;
+			}
+			res = spi_erase_and_write_sector(
+					sector_next->sector_addr,
+					enc_record_buf, buf_offset,
+					&enc_buf[TERM_INFO_OFFSET]);
+		}
+		if (res == TEE_SUCCESS) {
+			if ((bottom_half_size > 0U) && (difference != 0)) {
+				spi_update_rdesc(rdesc, difference, new_size);
+			}
+			spi_commit_sector(rdesc->sector_idx, &eterm_info);
+		}
+	} else {
+		res = TEE_ERROR_STORAGE_NO_SPACE;
+	}
+
+	return res;
+}
+
+static struct spim_record_descriptor *spi_create_record_info(
+			const char *path, size_t path_len,
+			uint16_t attr, TEE_Result *res_out)
+{
+	struct spim_record_descriptor *rdesc;
+	struct spif_record_info *lrecord_info;
+	TEE_Result res = TEE_SUCCESS;
+	uint32_t assign_size;
+
+	rdesc = spi_alloc_rdesc(NULL, NULL);
+	if (rdesc != NULL) {
+		lrecord_info = &rdesc->record_info;
+		lrecord_info->record_head.attr = attr;
+		lrecord_info->record_head.path_len = path_len;
+		lrecord_info->record_head.data_len = 0U;
+		(void)memcpy(lrecord_info->record_meta.path, path, path_len);
+		assign_size = spi_get_record_info_size(rdesc);
+
+		res = tee_sfkm_generate_random(
+				lrecord_info->record_head.iv,
+				SAFS_IV_LEN);
+		if (res == TEE_SUCCESS) {
+			res = tee_sfkm_generate_random(
+					lrecord_info->record_head.mek,
+					SAFS_EK_SIZE);
+		}
+		if (res == TEE_SUCCESS) {
+			res = tee_sfkm_generate_random(
+					lrecord_info->record_meta.dek,
+					SAFS_EK_SIZE);
+		}
+		if (res == TEE_SUCCESS) {
+			res = spi_get_hod_from_path(path, path_len,
+					&lrecord_info->record_head.hod);
+		}
+		if (res == TEE_SUCCESS) {
+			res = spi_assign_record_info(assign_size,
+					&rdesc->sector_idx,
+					&rdesc->record_offset);
+		}
+		if (res == TEE_SUCCESS) {
+			res = spi_write_record_info(rdesc, assign_size, 0U);
+		}
+		if (res != TEE_SUCCESS) {
+			spi_free_rdesc(rdesc);
+			rdesc = NULL;
+		}
+	} else {
+		res = TEE_ERROR_OUT_OF_MEMORY;
+	}
+
+	*res_out = res;
+
+	return rdesc;
+}
+
+static TEE_Result spi_update_record_info(struct spim_record_descriptor *rdesc,
+			uint32_t old_size)
+{
+	TEE_Result res;
+	uint32_t new_size;
+
+	new_size = spi_get_record_info_size(rdesc);
+
+	res = spi_write_record_info(rdesc, new_size, old_size);
+
+	return res;
+}
+
+static TEE_Result spi_delete_record_info(struct spim_record_descriptor *rdesc)
+{
+	TEE_Result res;
+	uint32_t old_size;
+
+	old_size = spi_get_record_info_size(rdesc);
+
+	res = spi_write_record_info(rdesc, 0U, old_size);
+	if (res == TEE_SUCCESS) {
+		rdesc->sector_idx = RDESC_SECTOR_IDX_UNASSIGNED;
+		rdesc->record_offset = 0U;
+	}
+
+	return res;
+}
+
+static TEE_Result spi_encrypt_record_info(
+			const struct spif_record_info *record_info,
+			uint8_t *encrypt_buf)
+{
+	TEE_Result res;
+	uint32_t meta_enc_size;
+	uint32_t data_enc_size;
+	struct tee_sfkm_crypt_info c;
+
+	/* Record Head */
+	c.data_in	= record_info->record_head.mek;
+	c.data_size	= RECORD_HEAD_ENC_SIZE;
+	c.iv		= record_info->record_head.iv;
+	c.iv_size	= SAFS_IV_LEN;
+
+	res = tee_sfkm_encrypt_suk(&c,
+			encrypt_buf + RECORD_HEAD_ENC_OFFSET,
+			encrypt_buf + SAFS_IV_LEN,	/* Tag */
+			encrypt_buf);			/* Encrypted IV */
+
+	/* Record Meta */
+	if (res == TEE_SUCCESS) {
+		encrypt_buf += RECORD_HEAD_SIZE;
+		meta_enc_size = SAFS_EK_SIZE + spi_ceil_ek_size(
+				record_info->record_head.path_len);
+
+		c.data_in	= record_info->record_meta.dek;
+		c.data_size	= meta_enc_size;
+		c.iv		= record_info->record_head.iv;
+		c.iv_size	= SAFS_IV_LEN;
+		c.key		= record_info->record_head.mek;
+		c.key_size	= SAFS_EK_SIZE;
+
+		res = tee_sfkm_encrypt(&c,
+				encrypt_buf + RECORD_META_ENC_OFFSET,
+				encrypt_buf);		/* Tag */
+	}
+
+	/* Record Data */
+	if ((res == TEE_SUCCESS) && (record_info->record_head.data_len > 0U)) {
+		encrypt_buf += RECORD_META_ENC_OFFSET + meta_enc_size;
+		data_enc_size = spi_ceil_ek_size(
+				record_info->record_head.data_len);
+
+		c.data_in	= &record_info->record_data->data[0];
+		c.data_size	= data_enc_size;
+		c.iv		= record_info->record_head.iv;
+		c.iv_size	= SAFS_IV_LEN;
+		c.key		= record_info->record_meta.dek;
+		c.key_size	= SAFS_EK_SIZE;
+
+		res = tee_sfkm_encrypt(&c,
+				encrypt_buf + RECORD_DATA_ENC_OFFSET,
+				encrypt_buf);		/* Tag */
+	}
+
+	return res;
+}
+
+static TEE_Result spi_read_record_head(uint32_t flash_addr,
+			struct spif_record_head *record_head)
+{
+	TEE_Result res;
+	uint8_t encrypted_data[RECORD_HEAD_SIZE];
+	struct tee_sfkm_crypt_info c;
+
+	res = spi_read_flash(flash_addr, encrypted_data,
+			sizeof(encrypted_data));
+
+	if (res == TEE_SUCCESS) {
+		c.data_in	= encrypted_data + RECORD_HEAD_ENC_OFFSET;
+		c.data_size	= RECORD_HEAD_ENC_SIZE;
+		c.iv		= encrypted_data;	/* Encrypted IV */
+		c.iv_size	= SAFS_IV_LEN;
+
+		res = tee_sfkm_decrypt_suk(&c,
+				encrypted_data + SAFS_IV_LEN,	/* Tag */
+				record_head->mek,
+				record_head->iv);
+
+		if (res == TEE_SUCCESS) {
+			(void)memcpy(record_head->tag,
+				encrypted_data + SAFS_IV_LEN,
+				SAFS_TAG_LEN);
+		}
+	}
+
+	return res;
+}
+
+static TEE_Result spi_read_record_meta(uint32_t flash_addr,
+			const struct spif_record_head *record_head,
+			struct spif_record_meta *record_meta)
+{
+	TEE_Result res;
+	uint32_t buf_size;
+	uint8_t encrypted_data[RECORD_META_MAX_SIZE];
+	struct tee_sfkm_crypt_info c;
+
+	buf_size = RECORD_META_FIXED_SIZE + spi_ceil_ek_size(
+			record_head->path_len);
+
+	res = spi_read_flash(flash_addr, encrypted_data, buf_size);
+
+	if (res == TEE_SUCCESS) {
+		(void)memset(record_meta->path, 0, sizeof(record_meta->path));
+
+		c.data_in	= encrypted_data + RECORD_META_ENC_OFFSET;
+		c.data_size	= buf_size - RECORD_META_ENC_OFFSET;
+		c.iv		= record_head->iv;
+		c.iv_size	= SAFS_IV_LEN;
+		c.key		= record_head->mek;
+		c.key_size	= SAFS_EK_SIZE;
+
+		res = tee_sfkm_decrypt(&c,
+				encrypted_data,		/* Tag */
+				record_meta->dek);
+
+		if (res == TEE_SUCCESS) {
+			(void)memcpy(record_meta->tag, encrypted_data,
+				SAFS_TAG_LEN);
+		}
+	}
+
+	return res;
+}
+
+static TEE_Result spi_read_record_data(struct spim_record_descriptor *rdesc)
+{
+	TEE_Result res;
+	struct spif_record_info *lrecord_info;
+	struct spim_sector_info *sector;
+	struct tee_sfkm_crypt_info c;
+	uint32_t flash_addr;
+	uint32_t buf_size;
+	uint8_t *encrypted_data;
+	const uint32_t enc_offset = RECORD_DATA_ENC_OFFSET;
+
+	if (rdesc->record_info.record_head.data_len > 0U) {
+		lrecord_info = &rdesc->record_info;
+		sector = spi_get_current_sector(rdesc->sector_idx);
+		flash_addr = sector->sector_addr + rdesc->record_offset +
+			RECORD_HEAD_SIZE + RECORD_META_FIXED_SIZE +
+			spi_ceil_ek_size(lrecord_info->record_head.path_len);
+		encrypted_data = g_work_buf;
+		buf_size = enc_offset +
+			spi_ceil_ek_size(lrecord_info->record_head.data_len);
+
+		res = spi_read_flash(flash_addr, encrypted_data, buf_size);
+
+		if (res == TEE_SUCCESS) {
+			c.data_in	= encrypted_data + enc_offset;
+			c.data_size	= buf_size - enc_offset;
+			c.iv		= lrecord_info->record_head.iv;
+			c.iv_size	= SAFS_IV_LEN;
+			c.key		= lrecord_info->record_meta.dek;
+			c.key_size	= SAFS_EK_SIZE;
+
+			res = tee_sfkm_decrypt(&c,
+					encrypted_data,	/* Tag */
+					&lrecord_info->record_data->data[0]);
+
+			if (res == TEE_SUCCESS) {
+				(void)memcpy(lrecord_info->record_data->tag,
+					encrypted_data,
+					SAFS_TAG_LEN);
+			}
+		}
+	} else {
+		res = TEE_ERROR_NO_DATA;
+	}
+
+	return res;
+}
+
+static void spi_get_parent_dir(const char *path, size_t path_len,
+			const char **parent_dir, size_t *parent_dir_len)
+{
+	int32_t pos;
+
+	for (pos = (int32_t)path_len - 1; pos >= 0; pos--) {
+		if (path[pos] == '/') {
+			/* e.g. path = "foo/bar" --> parent_dir = "foo"
+			 */
+			*parent_dir = path;
+			*parent_dir_len = pos;
+			break;
+		}
+	}
+
+	if (pos < 0) {
+		/* parent directory is root.
+		 * e.g. path = "baz" --> parent_dir = "/"
+		 */
+		*parent_dir = "/";
+		*parent_dir_len = 1;
+	}
+}
+
+static void spi_get_filename(const char *path, size_t path_len,
+			const char **filename)
+{
+	int32_t pos;
+
+	for (pos = (int32_t)path_len - 1; pos >= 0; pos--) {
+		if (path[pos] == '/') {
+			/* e.g. path = "foo/bar" --> filename = "bar"
+			 */
+			*filename = path + pos + 1;
+			break;
+		}
+	}
+
+	if (pos < 0) {
+		/* parent directory is root.
+		 * e.g. path = "baz" --> filename = "baz"
+		 */
+		*filename = path;
+	}
+}
+
+static TEE_Result spi_get_hod_from_path(const char *path, size_t path_len,
+			uint32_t *hod)
+{
+	TEE_Result res;
+	const char *dir_str;
+	size_t dir_len;
+
+	spi_get_parent_dir(path, path_len, &dir_str, &dir_len);
+
+	res = spi_get_hod(dir_str, dir_len, hod);
+
+	return res;
+}
+
+static TEE_Result spi_get_hod(const char *dir, size_t dir_len, uint32_t *hod)
+{
+	TEE_Result res;
+	uint8_t hash_buf[TEE_SHA256_HASH_SIZE];
+	uint8_t *byte_ptr;
+
+	res = tee_sfkm_generate_sha256((const uint8_t *)dir, dir_len, hash_buf);
+	if (res == TEE_SUCCESS) {
+		byte_ptr = (uint8_t *)hod;
+		(void)memcpy(byte_ptr, hash_buf, sizeof(uint32_t));
+	}
+
+	return res;
+}
+
+static TEE_Result spi_find_file(const char *file, size_t file_len)
+{
+	TEE_Result res;
+	struct spio_find_info f;
+
+	res = spi_get_hod_from_path(file, file_len, &f.hod);
+	if (res == TEE_SUCCESS) {
+		f.path		= file;
+		f.path_len	= file_len;
+		f.attr_mask	= SAFS_ATTR_MASK_FTYPE;
+		f.attr		= SAFS_ATTR_DATA_FILE;
+		f.match_flag	= PERFECT_MATCHING;
+
+		res = spi_find_path(&f);
+	}
+
+	return res;
+}
+
+static TEE_Result spi_find_dir(const char *dir, size_t dir_len)
+{
+	TEE_Result res;
+	struct spio_find_info f;
+
+	res = spi_get_hod_from_path(dir, dir_len, &f.hod);
+	if (res == TEE_SUCCESS) {
+		f.path		= dir;
+		f.path_len	= dir_len;
+		f.attr_mask	= SAFS_ATTR_MASK_FTYPE;
+		f.attr		= SAFS_ATTR_DATA_DIR;
+		f.match_flag	= PERFECT_MATCHING;
+
+		res = spi_find_path(&f);
+	}
+
+	return res;
+}
+
+static TEE_Result spi_find_file_under_dir(const char *dir, size_t dir_len)
+{
+	TEE_Result res;
+	struct spio_find_info f;
+
+	res = spi_get_hod(dir, dir_len, &f.hod);
+	if (res == TEE_SUCCESS) {
+		f.path		= dir;
+		f.path_len	= dir_len;
+		f.attr_mask	= 0;	/* file and directory */
+		f.attr		= 0;
+		f.match_flag	= FORWARD_MATCHING;
+
+		res = spi_find_path(&f);
+	}
+
+	return res;
+}
+
+static struct spim_record_descriptor *spi_find_file_and_generate_rdesc(
+			const char *file, size_t file_len)
+{
+	struct spim_record_descriptor *rdesc = NULL;
+	TEE_Result res;
+	struct spio_find_info f;
+
+	res = spi_get_hod_from_path(file, file_len, &f.hod);
+	if (res == TEE_SUCCESS) {
+		f.path		= file;
+		f.path_len	= file_len;
+		f.attr_mask	= SAFS_ATTR_MASK_FTYPE;
+		f.attr		= SAFS_ATTR_DATA_FILE;
+		f.match_flag	= PERFECT_MATCHING;
+
+		rdesc = spi_find_path_and_generate_rdesc(&f);
+	}
+
+	return rdesc;
+}
+
+static struct spim_record_descriptor *spi_find_dir_and_generate_rdesc(
+			const char *dir, size_t dir_len)
+{
+	struct spim_record_descriptor *rdesc = NULL;
+	TEE_Result res;
+	struct spio_find_info f;
+
+	res = spi_get_hod_from_path(dir, dir_len, &f.hod);
+	if (res == TEE_SUCCESS) {
+		f.path		= dir;
+		f.path_len	= dir_len;
+		f.attr_mask	= SAFS_ATTR_MASK_FTYPE;
+		f.attr		= SAFS_ATTR_DATA_DIR;
+		f.match_flag	= PERFECT_MATCHING;
+
+		rdesc = spi_find_path_and_generate_rdesc(&f);
+	}
+
+	return rdesc;
+}
+
+static struct spim_record_descriptor *spi_find_path_and_generate_rdesc(
+			const struct spio_find_info *f)
+{
+	struct spim_record_descriptor *rdesc = NULL;
+	TEE_Result res;
+	int32_t lsector_idx = 0;
+	uint32_t lrecord_offset = 0U;
+	struct spif_record_info lrecord_info;
+
+	res = spi_find_rdesc(f, &rdesc);
+	if (res == TEE_SUCCESS) {
+		rdesc->ref_count++;
+	} else if (res == TEE_ERROR_ITEM_NOT_FOUND) {
+		res = spi_search_flash_for_record_info(f, &lsector_idx,
+				&lrecord_offset, &lrecord_info);
+
+		if (res == TEE_SUCCESS) {
+			rdesc = spi_alloc_rdesc(&lrecord_info.record_head,
+					&lrecord_info.record_meta);
+			if (rdesc != NULL) {
+				rdesc->sector_idx = lsector_idx;
+				rdesc->record_offset = lrecord_offset;
+			} else {
+				EMSG("out of memory");
+			}
+		}
+	} else { /* (res == TEE_ERROR_ACCESS_CONFLICT) */
+		/* no operation */
+	}
+
+	return rdesc;
+}
+
+static TEE_Result spi_find_path(const struct spio_find_info *f)
+{
+	TEE_Result res = TEE_ERROR_ITEM_NOT_FOUND;
+	int32_t lsector_idx = 0;
+	uint32_t lrecord_offset = 0U;
+	struct spif_record_info erecord_info; /* entity */
+	struct spim_record_descriptor *rdesc = NULL;
+
+	if (f->match_flag == PERFECT_MATCHING) {
+		res = spi_find_rdesc(f, &rdesc);
+	}
+	if (res == TEE_ERROR_ITEM_NOT_FOUND) {
+		res = spi_search_flash_for_record_info(f, &lsector_idx,
+				&lrecord_offset, &erecord_info);
+	}
+
+	return res;
+}
+
+static TEE_Result spi_search_flash_for_record_info(
+			const struct spio_find_info *f,
+			int32_t *search_sector_idx,
+			uint32_t *search_record_offset,
+			struct spif_record_info *record_info)
+{
+	TEE_Result res;
+	TEE_Result resi = TEE_ERROR_ITEM_NOT_FOUND; /* Internal error code */
+	struct spim_sector_info *sector = NULL;
+	uint32_t flash_addr = 0U;
+	uint32_t next_addr = 0U;
+	int32_t lsector_idx;
+	uint32_t first_record_offset;
+	enum search_state {
+		RINFO_NOT_FOUND = 1,
+		RINFO_EXIST,
+		RINFO_END_OF_SEARCH	/* error case */
+	};
+	enum search_state search_flag = RINFO_NOT_FOUND;
+
+	first_record_offset = *search_record_offset;
+	lsector_idx = *search_sector_idx;
+
+	for (; (lsector_idx < SAVE_SECTOR_NUM) &&
+	       (search_flag == RINFO_NOT_FOUND); lsector_idx++) {
+		sector = spi_get_current_sector(lsector_idx);
+		flash_addr = sector->sector_addr;
+		if (first_record_offset > 0U) {
+			flash_addr += first_record_offset;
+			first_record_offset = 0;
+		}
+		while ((search_flag == RINFO_NOT_FOUND) &&
+		       ((flash_addr - sector->sector_addr) <
+		        sector->term_info.empty_offset)) {
+			resi = spi_match_record_info(f, flash_addr,
+					record_info, &next_addr);
+			if (resi == TEE_SUCCESS) {
+				search_flag = RINFO_EXIST;
+			} else if (resi == TEE_ERROR_ITEM_NOT_FOUND) {
+				/* Find the next Record Information */
+				flash_addr = next_addr;
+			} else if (resi == TEE_ERROR_MAC_INVALID) {
+				/* Skip the search for the sector */
+				flash_addr = sector->term_info.empty_offset;
+			} else {
+				search_flag = RINFO_END_OF_SEARCH;
+			}
+		}
+		if (search_flag == RINFO_EXIST) {
+			break;
+		}
+	}
+
+	if (search_flag == RINFO_EXIST) {
+		if (((record_info->record_head.attr & f->attr_mask) ==
+		     f->attr)) {
+			res = TEE_SUCCESS;
+		} else {
+			res = TEE_ERROR_ACCESS_CONFLICT;
+			EMSG("tee file has no access rights");
+		}
+	} else if (search_flag == RINFO_END_OF_SEARCH) {
+		flash_addr = sector->term_info.empty_offset;
+		lsector_idx = SAVE_SECTOR_NUM;
+		res = resi;
+	} else {
+		res = TEE_ERROR_ITEM_NOT_FOUND;
+	}
+
+	if (sector != NULL) {
+		*search_sector_idx = lsector_idx;
+		*search_record_offset = flash_addr - sector->sector_addr;
+	}
+
+	return res;
+}
+
+static TEE_Result spi_match_record_info(const struct spio_find_info *f,
+			uint32_t flash_addr,
+			struct spif_record_info *record_info,
+			uint32_t *next_addr)
+{
+	TEE_Result res;
+	struct spif_record_head *lrecord_head;
+	struct spif_record_meta *lrecord_meta;
+	uint16_t ftype_mask;
+	uint16_t filetype;
+
+	lrecord_head = &record_info->record_head;
+	lrecord_meta = &record_info->record_meta;
+	ftype_mask = f->attr_mask & SAFS_ATTR_MASK_FTYPE;
+	filetype = f->attr & SAFS_ATTR_MASK_FTYPE;
+
+	/* Read the Record Head */
+	res = spi_read_record_head(flash_addr, lrecord_head);
+
+	if (res == TEE_SUCCESS) {
+		flash_addr += RECORD_HEAD_SIZE;
+		if (((lrecord_head->attr & ftype_mask) == filetype) &&
+		    (((f->match_flag == PERFECT_MATCHING) &&
+		      (f->path_len == lrecord_head->path_len)) ||
+		     ((f->match_flag == FORWARD_MATCHING) &&
+		      (f->path_len < lrecord_head->path_len))) &&
+		    ((f->hod == lrecord_head->hod))) {
+
+			/* Read the Record Meta */
+			res = spi_read_record_meta(flash_addr, lrecord_head,
+					lrecord_meta);
+		} else {
+			res = TEE_ERROR_ITEM_NOT_FOUND;
+		}
+
+		/* If successful the reading of Record Meta */
+		if (res == TEE_SUCCESS) {
+			if (strncmp(f->path, lrecord_meta->path, f->path_len)
+			    == 0) {
+				res = TEE_SUCCESS;
+			} else {
+				res = TEE_ERROR_ITEM_NOT_FOUND;
+			}
+		}
+
+		flash_addr += (RECORD_META_FIXED_SIZE +
+				spi_ceil_ek_size(lrecord_head->path_len));
+		if (lrecord_head->data_len > 0U) {
+			flash_addr += (RECORD_DATA_FIXED_SIZE +
+				spi_ceil_ek_size(lrecord_head->data_len));
+		}
+		*next_addr = flash_addr;
+	}
+
+	return res;
+}
+
+static struct spim_sector_info *spi_get_current_sector(int32_t sector_idx)
+{
+	assert(sector_idx < SAVE_SECTOR_NUM);
+
+	return &g_sector[g_current_surface[sector_idx]][sector_idx];
+}
+
+static struct spim_sector_info *spi_get_next_sector(int32_t sector_idx)
+{
+	int32_t next_surface;
+
+	assert(sector_idx < SAVE_SECTOR_NUM);
+
+	if (g_current_surface[sector_idx] == 0) {
+		next_surface = 1;
+	} else {
+		next_surface = 0;
+	}
+
+	return &g_sector[next_surface][sector_idx];
+}
+
+static void spi_commit_sector(int32_t sector_idx,
+			const struct spif_term_info *new_term_info)
+{
+	int32_t next_surface;
+
+	assert(sector_idx < SAVE_SECTOR_NUM);
+
+	if (g_current_surface[sector_idx] == 0) {
+		next_surface = 1;
+	} else {
+		next_surface = 0;
+	}
+	(void)memcpy(&g_sector[next_surface][sector_idx].term_info,
+		new_term_info, sizeof(struct spif_term_info));
+	g_current_surface[sector_idx] = next_surface;
+}
+
+static struct spim_file_descriptor *spi_alloc_fdp(int32_t flags,
+			struct spim_record_descriptor *rdesc)
+{
+	struct spim_file_descriptor *fdp;
+	int32_t descriptor;
+
+	fdp = malloc(sizeof(struct spim_file_descriptor));
+
+	if (fdp != NULL) {
+		fdp->fpos = 0;
+		fdp->flags = flags;
+		fdp->ag_rdesc = rdesc;
+		descriptor = handle_get(&g_fd_handle_db, fdp);
+		if (descriptor >= 0) {
+			fdp->fd = descriptor;
+		} else {
+			free(fdp);
+			fdp = NULL;
+		}
+	}
+
+	return fdp;
+}
+
+static void spi_free_fdp(struct spim_file_descriptor *fdp)
+{
+	spi_free_rdesc(fdp->ag_rdesc);
+	(void)handle_put(&g_fd_handle_db, fdp->fd);
+	free(fdp);
+}
+
+static struct spim_file_descriptor *spi_get_fdp(int32_t fd)
+{
+	return (struct spim_file_descriptor *)handle_lookup(
+			&g_fd_handle_db, fd);
+}
+
+static struct spim_record_descriptor *spi_alloc_rdesc(
+			const struct spif_record_head *record_head,
+			const struct spif_record_meta *record_meta)
+{
+	struct spim_record_descriptor *rdesc;
+	int32_t descriptor;
+	void *buf;
+
+	rdesc = malloc(sizeof(struct spim_record_descriptor));
+
+	if (rdesc != NULL) {
+		(void)memset(rdesc, 0, sizeof(struct spim_record_descriptor));
+		if (record_head != NULL) {
+			(void)memcpy(&rdesc->record_info.record_head,
+				record_head, sizeof(struct spif_record_head));
+		}
+		if (record_meta != NULL) {
+			(void)memcpy(&rdesc->record_info.record_meta,
+				record_meta, sizeof(struct spif_record_meta));
+		}
+		buf = (void *)g_record_data_buf;
+		rdesc->record_info.record_data = (struct spif_record_data *)buf;
+		rdesc->sector_idx = RDESC_SECTOR_IDX_UNASSIGNED;
+		rdesc->record_offset = 0;
+		rdesc->ref_count = 1;
+		rdesc->ctrl_flag = 0;
+		descriptor = handle_get(&g_rd_handle_db, rdesc);
+		if (descriptor >= 0) {
+			rdesc->rd = descriptor;
+		} else {
+			free(rdesc);
+			rdesc = NULL;
+		}
+	}
+
+	return rdesc;
+}
+
+static void spi_free_rdesc(struct spim_record_descriptor *rdesc)
+{
+	TEE_Result res;
+
+	rdesc->ref_count--;
+
+	if (rdesc->ref_count == 0) {
+		if ((rdesc->ctrl_flag & RDESC_CTRL_UNLINK) != 0) {
+			res = spi_delete_record_info(rdesc);
+			if (res == TEE_SUCCESS) {
+				DMSG("tee file unlink success.");
+			} else {
+				EMSG("tee file unlink failure. r=%d", res);
+			}
+		}
+		(void)handle_put(&g_rd_handle_db, rdesc->rd);
+		free(rdesc);
+	}
+}
+
+static struct spim_record_descriptor *spi_get_rdesc(int32_t rd)
+{
+	return (struct spim_record_descriptor *)handle_lookup(
+			&g_rd_handle_db, rd);
+}
+
+static TEE_Result spi_find_rdesc(const struct spio_find_info *f,
+			struct spim_record_descriptor **rdesc_out)
+{
+	TEE_Result res = TEE_ERROR_ITEM_NOT_FOUND;
+	struct spim_record_descriptor *rdesc;
+	struct spif_record_head *lrecord_head;
+	struct spif_record_meta *lrecord_meta;
+	int32_t i;
+	int32_t cmpret;
+	int32_t exist_flag = 0;
+
+	for (i = 0; i < (int32_t)g_rd_handle_db.max_ptrs; i++) {
+		rdesc = spi_get_rdesc(i);
+		if (rdesc != NULL) {
+			lrecord_head = &rdesc->record_info.record_head;
+			lrecord_meta = &rdesc->record_info.record_meta;
+			if (((rdesc->ctrl_flag & RDESC_CTRL_DIRSTREAM) == 0) &&
+			    (f->path_len == lrecord_head->path_len) &&
+			    (f->hod == lrecord_head->hod)) {
+				cmpret = strcmp(f->path, lrecord_meta->path);
+				if (cmpret == 0) {
+					/* Record Information is found */
+					exist_flag = 1;
+					break;
+				}
+			}
+		}
+	}
+
+	if (exist_flag == 1) {
+		if ((lrecord_head->attr & f->attr_mask) == f->attr) {
+			*rdesc_out = rdesc;
+			res = TEE_SUCCESS;
+		} else {
+			res = TEE_ERROR_ACCESS_CONFLICT;
+			EMSG("record has no access rights");
+		}
+	}
+
+	return res;
+}
+
+static void spi_update_rdesc(const struct spim_record_descriptor *update_rdesc,
+			int32_t difference, uint32_t update_size)
+{
+	int32_t lsector_idx;
+	uint32_t lrecord_offset;
+	int32_t i;
+	struct spim_record_descriptor *rdesc;
+	const struct spif_record_head *new_head;
+	struct spif_record_head *cur_h;
+
+	lsector_idx = update_rdesc->sector_idx;
+	lrecord_offset = update_rdesc->record_offset;
+	new_head = &update_rdesc->record_info.record_head;
+
+	for (i = 0; i < (int32_t)g_rd_handle_db.max_ptrs; i++) {
+		rdesc = spi_get_rdesc(i);
+		if ((rdesc != NULL) &&
+		    (rdesc->sector_idx == lsector_idx)) {
+			if (lrecord_offset < rdesc->record_offset) {
+				rdesc->record_offset += difference;
+			} else if (((rdesc->ctrl_flag & RDESC_CTRL_DIRSTREAM)
+			  != 0) && (lrecord_offset == rdesc->record_offset)) {
+				if (update_size == 0) {
+					/* delete the record info */
+					rdesc->ctrl_flag |= RDESC_CTRL_DELETE;
+				} else {
+					/* update the record info size */
+					cur_h = &rdesc->record_info.record_head;
+					cur_h->path_len = new_head->path_len;
+					cur_h->data_len = new_head->data_len;
+				}
+			} else {
+				/* no operation */
+			}
+		}
+	}
+}
+
+static struct tee_fs_dir *spi_alloc_dirst(const char *dir, size_t dir_len)
+{
+	struct tee_fs_dir *dirst;
+	struct spim_record_descriptor *rdesc;
+	TEE_Result res;
+
+	dirst = malloc(sizeof(struct tee_fs_dir));
+	if (dirst != NULL) {
+		(void)memset(dirst, 0, sizeof(struct tee_fs_dir));
+		(void)memcpy(dirst->dir, dir, dir_len);
+		dirst->finfo.path	= dirst->dir;
+		dirst->finfo.path_len	= dir_len;
+		dirst->finfo.attr_mask	= 0;	/* file and directory */
+		dirst->finfo.attr	= 0;
+		dirst->finfo.match_flag	= FORWARD_MATCHING;
+
+		res = spi_get_hod(dir, dir_len, &dirst->finfo.hod);
+		if (res == TEE_SUCCESS) {
+			/* rdesc of the Directory Stream */
+			rdesc = spi_alloc_rdesc(NULL, NULL);
+			if (rdesc != NULL) {
+				rdesc->ctrl_flag |= RDESC_CTRL_DIRSTREAM;
+				dirst->dirent.d_name = NULL;
+				dirst->search_rdesc = rdesc;
+			} else {
+				free(dirst);
+				dirst = NULL;
+			}
+		} else {
+			free(dirst);
+			dirst = NULL;
+		}
+	}
+
+	return dirst;
+}
+
+static void spi_free_dirst(struct tee_fs_dir *dirst)
+{
+	spi_free_rdesc(dirst->search_rdesc);
+	free(dirst);
+}
+
+static TEE_Result spi_read_flash(uint32_t flash_addr, uint8_t *buf,
+			size_t rsize)
+{
+	TEE_Result res;
+	uint32_t ret;
+
+	ret = qspi_hyper_flash_read(flash_addr, buf, rsize);
+
+	if (ret == FL_DRV_OK) {
+		res = TEE_SUCCESS;
+	} else {
+		res = TEE_ERROR_TARGET_DEAD;
+	}
+
+	return res;
+}
+
+static TEE_Result spi_erase_and_write_sector(uint32_t sector_addr,
+			const uint8_t *encrypted_record_buf,
+			uint32_t record_buf_size,
+			const uint8_t *encrypted_term_info)
+{
+	TEE_Result res;
+	uint32_t ret;
+
+	ret = qspi_hyper_flash_erase(sector_addr);
+	if (ret == FL_DRV_OK) {
+		if (encrypted_record_buf != NULL) {
+			ret = qspi_hyper_flash_write(sector_addr,
+					encrypted_record_buf,
+					record_buf_size);
+		}
+		if (ret == FL_DRV_OK) {
+			ret = qspi_hyper_flash_write(
+					sector_addr + TERM_INFO_OFFSET,
+					encrypted_term_info,
+					TERM_INFO_SIZE);
+		}
+		if (ret == FL_DRV_OK) {
+			res = TEE_SUCCESS;
+		} else {
+			res = TEE_ERROR_TARGET_DEAD;
+		}
+	} else {
+		res = TEE_ERROR_TARGET_DEAD;
+	}
+
+	return res;
+}
+
+static TEE_Result tee_standalone_open(const char *file, size_t file_len,
+			int flags, int *fd_out)
+{
+	TEE_Result res;
+	struct spim_record_descriptor *rdesc;
+	struct spim_file_descriptor *fdp;
+	uint16_t lattr = SAFS_ATTR_DATA_FILE;
+	enum exist_state {
+		FILE_NOT_EXIST = 1,
+		FILE_EXIST,
+		PARENT_DIR_NOT_EXIST,
+		SAME_NAME_DIR_EXIST
+	};
+	enum exist_state status;
+	const char *parent_dir;
+	size_t dir_len;
+
+	rdesc = spi_find_file_and_generate_rdesc(file, file_len);
+	if (rdesc != NULL) {
+		status = FILE_EXIST;
+	} else {
+		spi_get_parent_dir(file, file_len, &parent_dir, &dir_len);
+		if (parent_dir[0] != '/') {
+			res = spi_find_dir(parent_dir, dir_len);
+			if (res != TEE_SUCCESS) {
+				status = PARENT_DIR_NOT_EXIST;
+			} else {
+				status = FILE_NOT_EXIST;
+			}
+		} else {
+			/* parent directory is root */
+			status = FILE_NOT_EXIST;
+		}
+		if (status == FILE_NOT_EXIST) {
+			res = spi_find_dir(file, file_len);
+			if (res == TEE_SUCCESS) {
+				/* same name directory already exists */
+				res = TEE_ERROR_ACCESS_CONFLICT;
+				status = SAME_NAME_DIR_EXIST;
+			}
+		}
+	}
+
+	if (status == FILE_NOT_EXIST) {
+		if ((flags & TEE_FS_O_CREATE) == 0) {
+			res = TEE_ERROR_ITEM_NOT_FOUND;
+			EMSG("tee file not exists");
+		} else {
+			lattr |= SAFS_ATTR_DATA_IRUSR | SAFS_ATTR_DATA_IWUSR;
+			rdesc = spi_create_record_info(file, file_len, lattr,
+					&res);
+			if (rdesc != NULL) {
+				res = TEE_SUCCESS;
+			} else {
+				EMSG("tee file create failure");
+			}
+		}
+	} else if (status == FILE_EXIST) {
+		if (((flags & TEE_FS_O_CREATE) != 0) &&
+		    ((flags & TEE_FS_O_EXCL) != 0)) {
+			spi_free_rdesc(rdesc);
+			res = TEE_ERROR_ACCESS_CONFLICT;
+			EMSG("tee file already exists");
+		} else {
+			res = TEE_SUCCESS;
+		}
+	} else if (status == PARENT_DIR_NOT_EXIST) {
+		EMSG("parent directory not exists");
+	} else { /* (status == SAME_NAME_DIR_EXIST) */
+		EMSG("is a directory");
+	}
+
+	if (res == TEE_SUCCESS) {
+		fdp = spi_alloc_fdp(flags, rdesc);
+		if (fdp != NULL) {
+			res = TEE_SUCCESS;
+			if (((flags & TEE_FS_O_TRUNC) != 0) &&
+			    (((flags & TEE_FS_O_WRONLY) != 0) ||
+			     (((flags & TEE_FS_O_RDWR)) != 0))) {
+				res = tee_standalone_ftruncate(fdp, 0);
+				if (res != TEE_SUCCESS) {
+					spi_free_fdp(fdp);
+					EMSG("Unable to truncate file");
+				}
+			}
+		} else {
+			spi_free_rdesc(rdesc);
+			res = TEE_ERROR_OUT_OF_MEMORY;
+		}
+
+		if (res == TEE_SUCCESS) {
+			*fd_out = fdp->fd;
+		}
+	}
+
+	return res;
+}
+
+static TEE_Result tee_standalone_close(struct spim_file_descriptor *fdp)
+{
+	spi_free_fdp(fdp);
+
+	return TEE_SUCCESS;
+}
+
+static TEE_Result tee_standalone_read(struct spim_file_descriptor *fdp,
+			void *buf, size_t buf_len, int *read_size)
+{
+	TEE_Result res;
+	struct spim_record_descriptor *rdesc;
+	struct spif_record_data *lrecord_data;
+	uint32_t rdata_len;
+
+	if ((fdp->flags & TEE_FS_O_WRONLY) == 0) {
+		rdesc = fdp->ag_rdesc;
+		lrecord_data = rdesc->record_info.record_data;
+		res = spi_read_record_data(rdesc);
+		if (res == TEE_SUCCESS) {
+			rdata_len = rdesc->record_info.record_head.data_len;
+			if (rdata_len < (fdp->fpos + buf_len)) {
+				if (fdp->fpos < rdata_len) {
+					buf_len = rdata_len - fdp->fpos;
+				} else {
+					buf_len = 0;
+				}
+				DMSG("reached EOF, update read length to %zu",
+					buf_len);
+			}
+			(void)memcpy(buf, &lrecord_data->data[fdp->fpos],
+				buf_len);
+			fdp->fpos += buf_len;
+			*read_size = buf_len;
+		} else if (res == TEE_ERROR_NO_DATA) {
+			*read_size = 0;
+			DMSG("no data, read length to 0");
+		} else {
+			EMSG("record data read error!");
+		}
+	} else {
+		res = TEE_ERROR_ACCESS_CONFLICT;
+		EMSG("Read to a write-only file, denied");
+	}
+
+	return res;
+}
+
+static TEE_Result tee_standalone_write(struct spim_file_descriptor *fdp,
+			const void *buf, size_t buf_len, int *write_size)
+{
+	TEE_Result res;
+	struct spim_record_descriptor *rdesc;
+	struct spif_record_head *lrecord_head;
+	struct spif_record_data *lrecord_data;
+	uint32_t old_size;
+	uint32_t old_data_len;
+	uint32_t new_data_len;
+	uint32_t new_pos;
+	uint32_t pos;
+
+	if ((fdp->flags & TEE_FS_O_RDONLY) == 0) {
+		rdesc = fdp->ag_rdesc;
+		lrecord_head = &rdesc->record_info.record_head;
+		lrecord_data = rdesc->record_info.record_data;
+		old_size = spi_get_record_info_size(rdesc);
+		old_data_len = lrecord_head->data_len;
+		pos = fdp->fpos;
+		if ((fdp->flags & TEE_FS_O_APPEND) != 0) {
+			pos = old_data_len;
+		}
+		new_pos = pos + buf_len;
+		if (new_pos < old_data_len) {
+			new_data_len = old_data_len;
+		} else {
+			new_data_len = new_pos;
+		}
+		if (old_data_len > 0U) {
+			res = spi_read_record_data(rdesc);
+		} else {
+			res = TEE_SUCCESS;
+		}
+		if (res == TEE_SUCCESS) {
+			if (old_data_len < pos) {
+				/* hole area */
+				(void)memset(&lrecord_data->data[old_data_len],
+					0, pos - old_data_len);
+			}
+			(void)memcpy(&lrecord_data->data[pos], buf, buf_len);
+			lrecord_head->data_len = new_data_len;
+
+			res = spi_update_record_info(rdesc, old_size);
+			if (res == TEE_SUCCESS) {
+				fdp->fpos = new_pos;
+				*write_size = buf_len;
+			} else {
+				/* rollback */
+				lrecord_head->data_len = old_data_len;
+			}
+		}
+	} else {
+		EMSG("Write to a read-only file, denied");
+		res = TEE_ERROR_ACCESS_CONFLICT;
+	}
+
+	return res;
+}
+
+static TEE_Result tee_standalone_lseek(struct spim_file_descriptor *fdp,
+			tee_fs_off_t offset, int whence, tee_fs_off_t *new_pos)
+{
+	TEE_Result res = TEE_SUCCESS;
+	tee_fs_off_t pos;
+
+	switch (whence) {
+	case TEE_FS_SEEK_SET:
+		pos = offset;
+		break;
+
+	case TEE_FS_SEEK_CUR:
+		pos = fdp->fpos + offset;
+		break;
+
+	case TEE_FS_SEEK_END:
+		pos = fdp->ag_rdesc->record_info.record_head.data_len + offset;
+		break;
+
+	default:
+		res = TEE_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	if (res == TEE_SUCCESS) {
+		if (pos >= 0) {
+			fdp->fpos = (uint32_t)pos;
+			*new_pos = pos;
+		} else {
+			res = TEE_ERROR_BAD_PARAMETERS;
+			EMSG("file position is a negative value");
+		}
+	}
+
+	return res;
+}
+
+static TEE_Result tee_standalone_rename(const char *old_file, size_t old_len,
+			const char *new_file, size_t new_len)
+{
+	TEE_Result res;
+	struct spim_record_descriptor *rdesc;
+	struct spif_record_info *lrecord_info;
+	uint32_t old_size;
+	const char *parent_dir;
+	size_t dir_len;
+
+	rdesc = spi_find_file_and_generate_rdesc(old_file, old_len);
+	if (rdesc != NULL) {
+		spi_get_parent_dir(new_file, new_len, &parent_dir, &dir_len);
+		if (parent_dir[0] != '/') {
+			res = spi_find_dir(parent_dir, dir_len);
+			if (res != TEE_SUCCESS) {
+				res = TEE_ERROR_ITEM_NOT_FOUND;
+				EMSG("new directory not exists");
+			}
+		} else {
+			/* parent directory is root */
+			res = TEE_SUCCESS;
+		}
+		if (res == TEE_SUCCESS) {
+			res = spi_find_file(new_file, new_len);
+			if (res == TEE_SUCCESS) {
+				res = TEE_ERROR_ACCESS_CONFLICT;
+				EMSG("new file exists");
+			} else if (res == TEE_ERROR_ITEM_NOT_FOUND) {
+				res = spi_find_dir(new_file, new_len);
+				if (res == TEE_SUCCESS) {
+					res = TEE_ERROR_ACCESS_CONFLICT;
+					EMSG("is a directory");
+				} else {
+					/* Normal case: new file not exists */
+					res = TEE_SUCCESS;
+				}
+			} else {
+				EMSG("find file error!");
+			}
+		}
+
+		if (res == TEE_SUCCESS) {
+			lrecord_info = &rdesc->record_info;
+			old_size = spi_get_record_info_size(rdesc);
+			if (lrecord_info->record_head.data_len > 0U) {
+				res = spi_read_record_data(rdesc);
+			}
+		}
+		if (res == TEE_SUCCESS) {
+			lrecord_info->record_head.path_len = new_len;
+			(void)memcpy(lrecord_info->record_meta.path,
+				new_file, new_len + 1);
+
+			res = spi_update_record_info(rdesc, old_size);
+			if (res != TEE_SUCCESS) {
+				/* rollback */
+				lrecord_info->record_head.path_len = old_len;
+				(void)memcpy(lrecord_info->record_meta.path,
+					old_file, old_len + 1);
+			}
+		}
+		spi_free_rdesc(rdesc);
+	} else {
+		res = TEE_ERROR_ITEM_NOT_FOUND;
+		EMSG("tee file not exists");
+	}
+
+	return res;
+}
+
+static TEE_Result tee_standalone_unlink(const char *file, size_t file_len)
+{
+	TEE_Result res;
+	struct spim_record_descriptor *rdesc;
+
+	rdesc = spi_find_file_and_generate_rdesc(file, file_len);
+	if (rdesc != NULL) {
+		rdesc->ctrl_flag |= RDESC_CTRL_UNLINK;
+		spi_free_rdesc(rdesc);
+		res = TEE_SUCCESS;
+	} else {
+		res = TEE_ERROR_ITEM_NOT_FOUND;
+		EMSG("tee file not exists");
+	}
+
+	return res;
+}
+
+static TEE_Result tee_standalone_ftruncate(struct spim_file_descriptor *fdp,
+			tee_fs_off_t length)
+{
+	TEE_Result res;
+	struct spim_record_descriptor *rdesc;
+	struct spif_record_head *lrecord_head;
+	struct spif_record_data *lrecord_data;
+	uint32_t old_size;
+	uint32_t old_dlen;
+
+	if ((fdp->flags & TEE_FS_O_RDONLY) == 0) {
+		rdesc = fdp->ag_rdesc;
+		lrecord_head = &rdesc->record_info.record_head;
+		lrecord_data = rdesc->record_info.record_data;
+		if (length != lrecord_head->data_len) {
+			old_size = spi_get_record_info_size(rdesc);
+			old_dlen = lrecord_head->data_len;
+			if (length > 0) {
+				if (old_dlen > 0U) {
+					res = spi_read_record_data(rdesc);
+				} else {
+					res = TEE_SUCCESS;
+				}
+				if ((res == TEE_SUCCESS) &&
+				    (old_dlen < length)) {
+					/* hole area */
+					(void)memset(
+						&lrecord_data->data[old_dlen],
+						0, length - old_dlen);
+				}
+			} else {
+				res = TEE_SUCCESS;
+			}
+			if (res == TEE_SUCCESS) {
+				lrecord_head->data_len = length;
+
+				res = spi_update_record_info(rdesc, old_size);
+				if (res != TEE_SUCCESS) {
+					/* rollback */
+					lrecord_head->data_len = old_dlen;
+				}
+			}
+		} else {
+			/* no operation */
+			res = TEE_SUCCESS;
+		}
+	} else {
+		EMSG("Write to a read-only file, denied");
+		res = TEE_ERROR_ACCESS_CONFLICT;
+	}
+
+	return res;
+}
+
+static TEE_Result tee_standalone_mkdir(const char *path, size_t path_len,
+			tee_fs_mode_t mode)
+{
+	TEE_Result res;
+	struct spim_record_descriptor *rdesc;
+	uint16_t lattr = SAFS_ATTR_DATA_DIR;
+	const char *parent_dir;
+	size_t dir_len;
+
+	res = spi_find_dir(path, path_len);
+	if (res != TEE_SUCCESS) {
+		spi_get_parent_dir(path, path_len, &parent_dir, &dir_len);
+		if (parent_dir[0] != '/') {
+			res = spi_find_dir(parent_dir, dir_len);
+			if (res != TEE_SUCCESS) {
+				res = TEE_ERROR_ITEM_NOT_FOUND;
+				EMSG("parent directory not exists");
+			}
+		} else {
+			/* parent directory is root */
+			res = TEE_SUCCESS;
+		}
+		if (res == TEE_SUCCESS) {
+			res = spi_find_file(path, path_len);
+			if (res == TEE_SUCCESS) {
+				res = TEE_ERROR_ACCESS_CONFLICT;
+				EMSG("file exists");
+			} else if (res == TEE_ERROR_ITEM_NOT_FOUND) {
+				/* Normal case: directory not exists */
+				res = TEE_SUCCESS;
+			} else {
+				EMSG("find file error!");
+			}
+		}
+
+		if (res == TEE_SUCCESS) {
+			if (((mode & TEE_FS_S_IWUSR) != 0)) {
+				lattr |= SAFS_ATTR_DATA_IWUSR;
+			} else if (((mode & TEE_FS_S_IRUSR) != 0)) {
+				lattr |= SAFS_ATTR_DATA_IRUSR;
+			} else {
+				/* no operation */
+			}
+			rdesc = spi_create_record_info(path, path_len, lattr,
+					&res);
+			if (rdesc != NULL) {
+				res = TEE_SUCCESS;
+				spi_free_rdesc(rdesc);
+			}
+		}
+	} else {
+		DMSG("tee directory already exists");
+	}
+
+	return res;
+}
+
+static struct tee_fs_dir *tee_standalone_opendir(const char *name,
+			size_t name_len)
+{
+	struct tee_fs_dir *dirst = NULL;
+	TEE_Result res;
+
+	res = spi_find_dir(name, name_len);
+	if (res == TEE_SUCCESS) {
+		dirst = spi_alloc_dirst(name, name_len);
+		if (dirst == NULL) {
+			EMSG("out of memory");
+		}
+	} else {
+		EMSG("tee directory not exists");
+	}
+
+	return dirst;
+}
+
+static TEE_Result tee_standalone_closedir(struct tee_fs_dir *dirst)
+{
+	spi_free_dirst(dirst);
+
+	return TEE_SUCCESS;
+}
+
+static struct tee_fs_dirent *tee_standalone_readdir(
+			struct tee_fs_dir *dirst)
+{
+	struct tee_fs_dirent *ret_dirent = NULL;
+	TEE_Result res = TEE_ERROR_ITEM_NOT_FOUND;
+	struct spim_record_descriptor *rdesc;
+	const char *parent_dir;
+	size_t dir_len;
+	const char *filename;
+
+	rdesc = dirst->search_rdesc;
+
+	while ((rdesc->sector_idx < SAVE_SECTOR_NUM) && (res != TEE_SUCCESS)) {
+		if (rdesc->sector_idx == RDESC_SECTOR_IDX_UNASSIGNED) {
+			rdesc->sector_idx = 0;
+		} else if ((rdesc->ctrl_flag & RDESC_CTRL_DELETE) == 0) {
+			rdesc->record_offset += spi_get_record_info_size(rdesc);
+		} else {
+			rdesc->ctrl_flag &= ~RDESC_CTRL_DELETE;
+		}
+
+		res = spi_search_flash_for_record_info(&dirst->finfo,
+				&rdesc->sector_idx, &rdesc->record_offset,
+				&rdesc->record_info);
+
+		if (res == TEE_SUCCESS) {
+			spi_get_parent_dir(rdesc->record_info.record_meta.path,
+					rdesc->record_info.record_head.path_len,
+					&parent_dir, &dir_len);
+
+			if (dirst->finfo.path_len == dir_len) {
+				spi_get_filename(
+					rdesc->record_info.record_meta.path,
+					rdesc->record_info.record_head.path_len,
+					&filename);
+				/* file or directory exist */
+				dirst->dirent.d_name = (char *)filename;
+				ret_dirent = &dirst->dirent;
+			} else {
+				res = TEE_ERROR_ITEM_NOT_FOUND;
+				DMSG("collision hod!");
+			}
+		}
+	}
+
+	return ret_dirent;
+}
+
+static TEE_Result tee_standalone_rmdir(const char *path, size_t path_len)
+{
+	TEE_Result res;
+	struct spim_record_descriptor *rdesc;
+
+	rdesc = spi_find_dir_and_generate_rdesc(path, path_len);
+	if (rdesc != NULL) {
+		res = spi_find_file_under_dir(path, path_len);
+		if (res == TEE_SUCCESS) {
+			res = TEE_ERROR_ACCESS_CONFLICT;
+			EMSG("tee file exists under directory");
+		} else {
+			res = spi_delete_record_info(rdesc);
+		}
+		spi_free_rdesc(rdesc);
+	} else {
+		res = TEE_ERROR_ITEM_NOT_FOUND;
+		EMSG("tee directory not exists");
+	}
+
+	return res;
+}
+
+static TEE_Result tee_standalone_access(const char *name, size_t name_len,
+			int mode __unused)
+{
+	TEE_Result res;
+	struct spio_find_info f;
+
+	if (name_len > 0U) {
+		res = spi_get_hod_from_path(name, name_len, &f.hod);
+		if (res == TEE_SUCCESS) {
+			f.path		= name;
+			f.path_len	= name_len;
+			f.attr_mask	= 0;	/* file and directory */
+			f.attr		= 0;
+			f.match_flag	= PERFECT_MATCHING;
+
+			res = spi_find_path(&f);
+		}
+	} else {
+		/* root directory exists */
+		res = TEE_SUCCESS;
+	}
+
+	return res;
+}
+
+static int standalone_fs_open(TEE_Result *errno, const char *file,
+			int flags, ...)
+{
+	int ret_fd = -1;
+	TEE_Result res;
+	size_t len;
+
+	DMSG("IN  file=%s , flags=%d", file, flags);
+
+	if ((errno != NULL) && (file != NULL)) {
+		res = spi_get_status_and_check_file(&file, &len);
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			res = tee_standalone_open(file, len, flags, &ret_fd);
+			spi_unlock();
+		}
+		*errno = res;
+	} else {
+		if (errno != NULL) {
+			*errno = TEE_ERROR_BAD_PARAMETERS;
+		}
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT fd=%d errno=0x%x", ret_fd, (errno != NULL) ? *errno : 0);
+	return ret_fd;
+}
+
+static int standalone_fs_close(int fd)
+{
+	int rc = -1;
+	TEE_Result res;
+	struct spim_file_descriptor *fdp;
+
+	DMSG("IN  fd=%d", fd);
+
+	res = spi_get_status();
+	if (res == TEE_SUCCESS) {
+		spi_lock();
+		fdp = spi_get_fdp(fd);
+		if (fdp != NULL) {
+			res = tee_standalone_close(fdp);
+			if (res == TEE_SUCCESS) {
+				rc = 0;
+			}
+		} else {
+			EMSG("Invalid file descriptor.");
+		}
+		spi_unlock();
+	}
+
+	DMSG("OUT rc=%d", rc);
+	return rc;
+}
+
+static int standalone_fs_read(TEE_Result *errno, int fd, void *buf, size_t len)
+{
+	int rc = -1;
+	TEE_Result res;
+	struct spim_file_descriptor *fdp;
+
+	DMSG("IN  fd=%d, buf=%p, len=%zu", fd, buf, len);
+
+	if ((errno != NULL) && (buf != NULL)) {
+		res = spi_get_status();
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			fdp = spi_get_fdp(fd);
+			if (fdp != NULL) {
+				res = tee_standalone_read(fdp, buf, len, &rc);
+			} else {
+				res = TEE_ERROR_BAD_PARAMETERS;
+				EMSG("Invalid file descriptor.");
+			}
+			spi_unlock();
+		}
+		*errno = res;
+	} else {
+		if (errno != NULL) {
+			*errno = TEE_ERROR_BAD_PARAMETERS;
+		}
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT rc=%d errno=0x%x", rc, (errno != NULL) ? *errno : 0);
+	return rc;
+}
+
+static int standalone_fs_write(TEE_Result *errno, int fd, const void *buf,
+			size_t len)
+{
+	int rc = -1;
+	TEE_Result res;
+	struct spim_file_descriptor *fdp;
+
+	DMSG("IN  fd=%d, buf=%p, len=%zu", fd, buf, len);
+
+	if ((errno != NULL) && ((len == 0) || (buf != NULL))) {
+		res = spi_get_status();
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			fdp = spi_get_fdp(fd);
+			if (fdp != NULL) {
+				if (len > 0) {
+					res = tee_standalone_write(fdp, buf,
+							len, &rc);
+				} else {
+					res = TEE_SUCCESS;
+					rc = 0; /* write size zero */
+				}
+			} else {
+				res = TEE_ERROR_BAD_PARAMETERS;
+				EMSG("Invalid file descriptor.");
+			}
+			spi_unlock();
+		}
+		*errno = res;
+	} else {
+		if (errno != NULL) {
+			*errno = TEE_ERROR_BAD_PARAMETERS;
+		}
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT rc=%d errno=0x%x", rc, (errno != NULL) ? *errno : 0);
+	return rc;
+}
+
+static tee_fs_off_t standalone_fs_lseek(TEE_Result *errno, int fd,
+			tee_fs_off_t offset, int whence)
+{
+	tee_fs_off_t new_pos = -1;
+	TEE_Result res;
+	struct spim_file_descriptor *fdp;
+
+	DMSG("IN  fd=%d, offset=%ld, whence=%d", fd, offset, whence);
+
+	if (errno != NULL) {
+		res = spi_get_status();
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			fdp = spi_get_fdp(fd);
+			if (fdp != NULL) {
+				res = tee_standalone_lseek(fdp, offset,
+						whence, &new_pos);
+			} else {
+				res = TEE_ERROR_BAD_PARAMETERS;
+				EMSG("Invalid file descriptor.");
+			}
+			spi_unlock();
+		}
+		*errno = res;
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT new_pos=%ld errno=0x%x", new_pos,
+		(errno != NULL) ? *errno : 0);
+	return new_pos;
+}
+
+static int standalone_fs_rename(const char *old, const char *new)
+{
+	int rc = -1;
+	TEE_Result res;
+	size_t old_len;
+	size_t new_len;
+
+	DMSG("IN  old=%s , new=%s", old, new);
+
+	if ((old != NULL) && (new != NULL)) {
+		res = spi_get_status_and_check_file(&old, &old_len);
+		if (res == TEE_SUCCESS) {
+			res = spi_check_file(&new, &new_len);
+			if (res == TEE_SUCCESS) {
+				spi_lock();
+				res = tee_standalone_rename(old, old_len,
+						new, new_len);
+				spi_unlock();
+				if (res == TEE_SUCCESS) {
+					rc = 0;
+				}
+			}
+		}
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT rc=%d", rc);
+	return rc;
+}
+
+static int standalone_fs_unlink(const char *file)
+{
+	int rc = -1;
+	TEE_Result res;
+	size_t len;
+
+	DMSG("IN  file=%s", file);
+
+	if (file != NULL) {
+		res = spi_get_status_and_check_file(&file, &len);
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			res = tee_standalone_unlink(file, len);
+			spi_unlock();
+			if (res == TEE_SUCCESS) {
+				rc = 0;
+			}
+		}
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT rc=%d", rc);
+	return rc;
+}
+
+static int standalone_fs_ftruncate(TEE_Result *errno, int fd,
+			tee_fs_off_t length)
+{
+	int rc = -1;
+	TEE_Result res;
+	struct spim_file_descriptor *fdp;
+
+	DMSG("IN  fd=%d, length=%zu", fd, length);
+
+	if (errno != NULL) {
+		res = spi_get_status();
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			fdp = spi_get_fdp(fd);
+			if (fdp != NULL) {
+				res = tee_standalone_ftruncate(fdp, length);
+				if (res == TEE_SUCCESS) {
+					rc = 0;
+				}
+			} else {
+				res = TEE_ERROR_BAD_PARAMETERS;
+				EMSG("Invalid file descriptor.");
+			}
+			spi_unlock();
+		}
+		*errno = res;
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT rc=%d errno=0x%x", rc, (errno != NULL) ? *errno : 0);
+	return rc;
+}
+
+static int standalone_fs_mkdir(const char *path, tee_fs_mode_t mode)
+{
+	int rc = -1;
+	TEE_Result res;
+	size_t len;
+
+	DMSG("IN  path=%s , mode=%d", path, mode);
+
+	if (path != NULL) {
+		res = spi_get_status_and_check_dir(&path, &len);
+		if ((res == TEE_SUCCESS) && (len > 0U)) {
+			spi_lock();
+			res = tee_standalone_mkdir(path, len, mode);
+			spi_unlock();
+			if (res == TEE_SUCCESS) {
+				rc = 0;
+			}
+		}
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT rc=%d", rc);
+	return rc;
+}
+
+static struct tee_fs_dir *standalone_fs_opendir(const char *name)
+{
+	struct tee_fs_dir *dirst = NULL;
+	TEE_Result res;
+	size_t len;
+
+	DMSG("IN  name=%s", name);
+
+	if (name != NULL) {
+		res = spi_get_status_and_check_dir(&name, &len);
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			dirst = tee_standalone_opendir(name, len);
+			spi_unlock();
+		}
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT d=%p", (void *)dirst);
+	return dirst;
+}
+
+static int standalone_fs_closedir(struct tee_fs_dir *d)
+{
+	int rc = -1;
+	TEE_Result res;
+
+	DMSG("IN  d=%p", (void *)d);
+
+	if (d != NULL) {
+		res = spi_get_status();
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			res = tee_standalone_closedir(d);
+			spi_unlock();
+			if (res == TEE_SUCCESS) {
+				rc = 0;
+			}
+		}
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT rc=%d", rc);
+	return rc;
+}
+
+static struct tee_fs_dirent *standalone_fs_readdir(struct tee_fs_dir *d)
+{
+	struct tee_fs_dirent *ret_dirent = NULL;
+	TEE_Result res;
+
+	DMSG("IN  d=%p", (void *)d);
+
+	if (d != NULL) {
+		res = spi_get_status();
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			ret_dirent = tee_standalone_readdir(d);
+			spi_unlock();
+		}
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT dirent=%p d_name=%s", (void *)ret_dirent,
+		(ret_dirent != NULL) ? ret_dirent->d_name : NULL);
+	return ret_dirent;
+}
+
+static int standalone_fs_rmdir(const char *pathname)
+{
+	int rc = -1;
+	TEE_Result res;
+	size_t len;
+
+	DMSG("IN  pathname=%s", pathname);
+
+	if (pathname != NULL) {
+		res = spi_get_status_and_check_dir(&pathname, &len);
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			res = tee_standalone_rmdir(pathname, len);
+			spi_unlock();
+			if (res == TEE_SUCCESS) {
+				rc = 0;
+			}
+		}
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT rc=%d", rc);
+	return rc;
+}
+
+static int standalone_fs_access(const char *name, int mode)
+{
+	int rc = -1;
+	TEE_Result res;
+	size_t len;
+
+	DMSG("IN  name=%s , mode=%d", name, mode);
+
+	if (name != NULL) {
+		res = spi_get_status_and_check_dir(&name, &len);
+		if (res == TEE_SUCCESS) {
+			spi_lock();
+			res = tee_standalone_access(name, len, mode);
+			spi_unlock();
+			if (res == TEE_SUCCESS) {
+				/* file or directory exists */
+				rc = 0;
+			}
+		}
+	} else {
+		EMSG("Invalid argument provided.");
+	}
+
+	DMSG("OUT rc=%d", rc);
+	return rc;
+}
+
+const struct tee_file_operations standalone_fs_ops = {
+	.open = standalone_fs_open,
+	.close = standalone_fs_close,
+	.read = standalone_fs_read,
+	.write = standalone_fs_write,
+	.lseek = standalone_fs_lseek,
+	.ftruncate = standalone_fs_ftruncate,
+	.rename = standalone_fs_rename,
+	.unlink = standalone_fs_unlink,
+	.mkdir = standalone_fs_mkdir,
+	.opendir = standalone_fs_opendir,
+	.closedir = standalone_fs_closedir,
+	.readdir = standalone_fs_readdir,
+	.rmdir = standalone_fs_rmdir,
+	.access = standalone_fs_access
+};
diff --git a/core/arch/arm/plat-rcar/tee/tee_standalone_fs.h b/core/arch/arm/plat-rcar/tee/tee_standalone_fs.h
new file mode 100644
index 0000000..1efdeec
--- /dev/null
+++ b/core/arch/arm/plat-rcar/tee/tee_standalone_fs.h
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef TEE_STANDALONE_FS_H
+#define TEE_STANDALONE_FS_H
+
+#include <drivers/qspi_hyper_flash.h>
+#include "tee_standalone_fs_key_manager.h"
+
+#if ((STANDALONE_FS_SECTOR_ADDR % SECTOR_SIZE) != 0)
+#error STANDALONE_FS_SECTOR_ADDR is not a multiple of SECTOR_SIZE.
+#endif
+#if ((STANDALONE_FS_SECTOR_NUM % 2) != 0)
+#error STANDALONE_FS_SECTOR_NUM is not a multiple of 2.
+#endif
+
+#define SAVE_SECTOR_NUM			(STANDALONE_FS_SECTOR_NUM / 2)
+#define SURFACE_NUM			(2)
+
+#define PATH_MAX_LEN			(256)
+#define PATH_MAX_SIZE			(PATH_MAX_LEN + 1)
+
+#define RECORD_HEAD_SIZE		(64U)
+#define RECORD_HEAD_ENC_OFFSET		(SAFS_IV_LEN + SAFS_TAG_LEN)
+#define RECORD_HEAD_ENC_SIZE		(32U)
+#define RECORD_META_MIN_SIZE		(48U)
+#define RECORD_META_MAX_SIZE		(288U)
+#define RECORD_META_ENC_OFFSET		(SAFS_TAG_LEN)
+#define RECORD_META_FIXED_SIZE		(SAFS_TAG_LEN + SAFS_EK_SIZE)
+#define RECORD_DATA_ENC_OFFSET		(SAFS_TAG_LEN)
+#define RECORD_DATA_FIXED_SIZE		(SAFS_TAG_LEN)
+#define TERM_INFO_SIZE			(48U)
+#define TERM_INFO_ENC_OFFSET		(SAFS_IV_LEN + SAFS_TAG_LEN)
+#define TERM_INFO_ENC_SIZE		(16U)
+#define TERM_INFO_OFFSET		(SECTOR_SIZE - TERM_INFO_SIZE)
+
+#define RECORD_DATA_BUF_SIZE		(SECTOR_SIZE - TERM_INFO_SIZE - \
+					RECORD_HEAD_SIZE - RECORD_META_MIN_SIZE)
+
+#define WRITE_CNT_DEFAULT		(255U)
+#define WRITE_CNT_MIN			(1U)
+#define WRITE_CNT_MAX			(254U)
+
+#define SAFS_ATTR_MASK_FTYPE		(0x0001U)
+#define SAFS_ATTR_MASK_IWUSR		(0x0002U)
+#define SAFS_ATTR_MASK_IRUSR		(0x0004U)
+
+#define SAFS_ATTR_DATA_FILE		(0x0000U)
+#define SAFS_ATTR_DATA_DIR		(0x0001U)
+#define SAFS_ATTR_DATA_IWUSR		(0x0002U)
+#define SAFS_ATTR_DATA_IRUSR		(0x0004U)
+
+#define PERFECT_MATCHING		(0U)
+#define FORWARD_MATCHING		(1U)
+
+#define RDESC_SECTOR_IDX_UNASSIGNED	(-1)
+
+#define RDESC_CTRL_UNLINK		(0x00000001U)
+#define RDESC_CTRL_DIRSTREAM		(0x00000002U)
+#define RDESC_CTRL_DELETE		(0x00000004U)
+
+/**
+ * Non-volatile information. 'Record Head'
+ */
+struct spif_record_head {
+	uint8_t iv[SAFS_IV_LEN];		/* Initial Vector */
+	uint8_t tag[SAFS_TAG_LEN];		/* MAC */
+	uint8_t mek[SAFS_EK_SIZE];		/* Meta Encryption Key */
+	uint16_t attr;				/* Attribute */
+	uint16_t path_len;			/* Path Length */
+	uint32_t data_len;			/* Data Length */
+	uint32_t hod;				/* Hash of Directory */
+	uint32_t reserved;			/* Reserved */
+};
+
+/**
+ * Non-volatile information. 'Record Meta'
+ */
+struct spif_record_meta {
+	uint8_t tag[SAFS_TAG_LEN];		/* MAC */
+	uint8_t dek[SAFS_EK_SIZE];		/* Data Encryption Key */
+	char path[PATH_MAX_SIZE];		/* Path String */
+};
+
+/**
+ * Non-volatile information. 'Record Data'
+ */
+struct spif_record_data {
+	uint8_t tag[SAFS_TAG_LEN];		/* MAC */
+	uint8_t data[];				/* Data Area */
+};
+
+/**
+ * Non-volatile information. 'Record Information'
+ */
+struct spif_record_info {
+	struct spif_record_head record_head;	/* Record Head */
+	struct spif_record_meta record_meta;	/* Record Meta */
+	struct spif_record_data *record_data;	/* Record Data */
+};
+
+/**
+ * Non-volatile information. 'Termination Information'
+ */
+struct spif_term_info {
+	uint8_t iv[SAFS_IV_LEN];		/* Initial Vector */
+	uint8_t tag[SAFS_TAG_LEN];		/* MAC */
+	uint32_t record_num;			/* Record Number */
+	uint32_t empty_offset;			/* Empty Offset */
+	uint8_t write_count;			/* Write Count */
+	uint8_t reserved1[3];			/* Reserved 1 */
+	uint32_t reserved2;			/* Reserved 2 */
+};
+
+/**
+ * Other information. 'Find Information'
+ */
+struct spio_find_info {
+	const char *path;
+	size_t path_len;
+	uint16_t attr_mask;
+	uint16_t attr;
+	uint32_t hod;
+	uint32_t match_flag;
+};
+
+/**
+ * Volatile information. 'Sector Information'
+ */
+struct spim_sector_info {
+	uint32_t sector_addr;
+	struct spif_term_info term_info;
+};
+
+/**
+ * Volatile information. 'Record Descriptor Information'
+ */
+struct spim_record_descriptor {
+	struct spif_record_info record_info;
+	int32_t sector_idx;
+	uint32_t record_offset;
+	uint32_t ref_count;
+	uint32_t ctrl_flag;
+	int32_t rd;
+};
+
+/**
+ * Volatile information. 'File Descriptor Information'
+ */
+struct spim_file_descriptor {
+	uint32_t fpos;
+	int32_t flags;
+	struct spim_record_descriptor *ag_rdesc; 	/* aggregation */
+	int32_t fd;
+};
+
+/**
+ * Volatile information. 'Directory Stream Information'
+ */
+struct tee_fs_dir {
+	char dir[PATH_MAX_SIZE];
+	struct spio_find_info finfo;
+	struct spim_record_descriptor *search_rdesc;	/* composition */
+	struct tee_fs_dirent dirent;
+};
+
+#endif /* TEE_STANDALONE_FS_H */
diff --git a/core/arch/arm/plat-rcar/tee/tee_standalone_fs_key_manager.c b/core/arch/arm/plat-rcar/tee/tee_standalone_fs_key_manager.c
new file mode 100644
index 0000000..f6cca08
--- /dev/null
+++ b/core/arch/arm/plat-rcar/tee/tee_standalone_fs_key_manager.c
@@ -0,0 +1,434 @@
+/*
+ * Copyright (c) 2015, Linaro Limited
+ * Copyright (c) 2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/* Acronyms:
+ *
+ * SST - Secure Storage
+ * SSK - Secure Storage Key
+ * IV  - Initial vector
+ * HUK - Hardware Unique Key
+ * RNG - Random Number Generator
+ *
+ * SUK - Soc Unique encryption Key
+ * IVEK- IV Encryption Key
+ *
+ */
+
+#include <initcall.h>
+#include <stdlib.h>
+#include <string.h>
+#include <kernel/tee_common_otp.h>
+#include <kernel/tee_common_unpg.h>
+#include <tee/tee_cryp_utl.h>
+#include <tee/tee_cryp_provider.h>
+#include <tee/tee_fs_key_manager.h>
+#include <compiler.h>
+#include <trace.h>
+#include <util.h>
+
+#include "tee_standalone_fs_key_manager.h"
+
+static const uint8_t string_for_ssk_gen[] = "ONLY_FOR_tee_fs_ssk";
+static uint8_t g_safs_suk[SAFS_EK_SIZE];
+static uint8_t g_safs_ivek[TEE_SHA256_HASH_SIZE];
+
+static TEE_Result generate_ssk(uint8_t *ssk, uint32_t ssk_size,
+			uint8_t *huk, uint32_t huk_size,
+			uint8_t *message, uint32_t message_size);
+#ifdef CFG_ENC_FS
+static TEE_Result crypt_aes(uint32_t algo, TEE_OperationMode mode,
+			const struct tee_sfkm_crypt_info *c,
+			uint8_t *data_out);
+#endif
+static TEE_Result generate_cmac(const uint8_t *data_in, size_t data_size,
+			uint8_t *mac_out, const uint8_t *key, size_t key_size);
+
+TEE_Result tee_sfkm_generate_random(uint8_t *buf, uint8_t len)
+{
+	return crypto_ops.prng.read(buf, len);
+}
+
+static TEE_Result generate_ssk(uint8_t *ssk, uint32_t ssk_size,
+			uint8_t *huk, uint32_t huk_size,
+			uint8_t *message, uint32_t message_size)
+{
+	TEE_Result res = TEE_SUCCESS;
+	uint8_t *ctx = NULL;
+	size_t hash_ctx_size = 0;
+	const uint32_t algo = TEE_FS_KM_HMAC_ALG;
+
+	if ((ssk == NULL) || (huk == NULL) || (message == NULL)) {
+		res = TEE_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.mac.get_ctx_size(algo, &hash_ctx_size);
+	}
+
+	if (res == TEE_SUCCESS) {
+		ctx = malloc(hash_ctx_size);
+		if (ctx == NULL) {
+			res = TEE_ERROR_OUT_OF_MEMORY;
+		}
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.mac.init(ctx, algo, huk, huk_size);
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.mac.update(ctx, algo, message, message_size);
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.mac.final(ctx, algo, ssk, ssk_size);
+	}
+
+	if (ctx != NULL) {
+		free(ctx);
+	}
+
+	return res;
+}
+
+TEE_Result tee_sfkm_init_key_manager(void)
+{
+	int res;
+	struct tee_hw_unique_key huk;
+	uint8_t chip_id[TEE_FS_KM_CHIP_ID_LENGTH];
+	uint8_t message[sizeof(chip_id) + sizeof(string_for_ssk_gen)];
+	uint8_t ssk[TEE_FS_KM_SSK_SIZE];
+
+	/* Secure Storage Key Generation:
+	 *
+	 *     SSK = HMAC(HUK, message)
+	 *     message := concatenate(chip_id, static string)
+	 * */
+	tee_otp_get_hw_unique_key(&huk);
+	(void)tee_otp_get_die_id(chip_id, sizeof(chip_id));
+
+	(void)memcpy(message, chip_id, sizeof(chip_id));
+	(void)memcpy(message + sizeof(chip_id), string_for_ssk_gen,
+			sizeof(string_for_ssk_gen));
+
+	res = generate_ssk(ssk, sizeof(ssk),
+			huk.data, sizeof(huk.data),
+			message, sizeof(message));
+
+	/* Soc Unique encryption Key Generation:
+	 *
+	 *     SUK = CMAC(SSK, chip_id)
+	 */
+	if (res == TEE_SUCCESS) {
+		res = generate_cmac(chip_id, sizeof(chip_id),
+				g_safs_suk, ssk, sizeof(ssk));
+	}
+
+	/* IV Encryption Key Generation:
+	 *
+	 *     IVEK = SHA-256(SUK)
+	 */
+	if (res == TEE_SUCCESS) {
+		res = tee_sfkm_generate_sha256(g_safs_suk,
+			sizeof(g_safs_suk), g_safs_ivek);
+	}
+
+	return res;
+}
+
+TEE_Result tee_sfkm_encrypt_suk(struct tee_sfkm_crypt_info *c,
+			uint8_t *data_out, uint8_t *tag,
+			uint8_t *encrypted_iv)
+{
+	TEE_Result res;
+#ifdef CFG_ENC_FS
+	struct tee_sfkm_crypt_info iv_enc_info;
+#endif
+
+	c->key = g_safs_suk;
+	c->key_size = sizeof(g_safs_suk);
+
+	res = tee_sfkm_encrypt(c, data_out, tag);
+
+#ifdef CFG_ENC_FS
+	if (res == TEE_SUCCESS) {
+		iv_enc_info.data_in	= c->iv;
+		iv_enc_info.data_size	= c->key_size;
+		iv_enc_info.iv		= NULL;
+		iv_enc_info.iv_size	= 0U;
+		iv_enc_info.key		= g_safs_ivek;
+		iv_enc_info.key_size	= sizeof(g_safs_ivek);
+
+		res = crypt_aes(TEE_ALG_AES_ECB_NOPAD, TEE_MODE_ENCRYPT,
+				&iv_enc_info, encrypted_iv);
+	}
+#else
+	if (res == TEE_SUCCESS) {
+		(void)memcpy(encrypted_iv, c->iv, c->iv_size);
+	}
+#endif
+
+	return res;
+}
+
+TEE_Result tee_sfkm_encrypt(const struct tee_sfkm_crypt_info *c,
+			uint8_t *data_out, uint8_t *tag)
+{
+	TEE_Result res;
+
+#ifdef CFG_ENC_FS
+	res = crypt_aes(TEE_ALG_AES_CBC_NOPAD, TEE_MODE_ENCRYPT,
+			c, data_out);
+#else
+	(void)memcpy(data_out, c->data_in, c->data_size);
+	res = TEE_SUCCESS;
+#endif
+
+	if (res == TEE_SUCCESS) {
+		/* Encrypt-then-MAC */
+		res = generate_cmac(data_out, c->data_size,
+				tag, c->key, c->key_size);
+	}
+
+	return res;
+}
+
+TEE_Result tee_sfkm_decrypt_suk(struct tee_sfkm_crypt_info *c,
+			const uint8_t *tag, uint8_t *data_out,
+			uint8_t *decrypted_iv)
+{
+	TEE_Result res;
+	uint8_t mac_buf[SAFS_TAG_LEN];
+#ifdef CFG_ENC_FS
+	struct tee_sfkm_crypt_info iv_dec_info;
+#endif
+
+	c->key = g_safs_suk;
+	c->key_size = sizeof(g_safs_suk);
+
+	/* Encrypt-then-MAC */
+	res = generate_cmac(c->data_in, c->data_size,
+			mac_buf, c->key, c->key_size);
+
+	if (res == TEE_SUCCESS) {
+		if (memcmp(mac_buf, tag, SAFS_TAG_LEN) != 0) {
+			res = TEE_ERROR_MAC_INVALID;
+			DMSG("MAC mismatched");
+		}
+	}
+
+	if (res == TEE_SUCCESS) {
+#ifdef CFG_ENC_FS
+		iv_dec_info.data_in	= c->iv; /* Encrypted IV */
+		iv_dec_info.data_size	= c->key_size;
+		iv_dec_info.iv		= NULL;
+		iv_dec_info.iv_size	= 0U;
+		iv_dec_info.key		= g_safs_ivek;
+		iv_dec_info.key_size	= sizeof(g_safs_ivek);
+
+		res = crypt_aes(TEE_ALG_AES_ECB_NOPAD, TEE_MODE_DECRYPT,
+				&iv_dec_info, decrypted_iv);
+
+		if (res == TEE_SUCCESS) {
+			c->iv = decrypted_iv;
+			c->key = g_safs_suk;
+			c->key_size = sizeof(g_safs_suk);
+
+			res = crypt_aes(TEE_ALG_AES_CBC_NOPAD, TEE_MODE_DECRYPT,
+					c, data_out);
+		}
+#else
+		(void)memcpy(decrypted_iv, c->iv, c->iv_size);
+		(void)memcpy(data_out, c->data_in, c->data_size);
+		res = TEE_SUCCESS;
+#endif
+	}
+
+	return res;
+}
+
+TEE_Result tee_sfkm_decrypt(const struct tee_sfkm_crypt_info *c,
+			const uint8_t *tag, uint8_t *data_out)
+{
+	TEE_Result res;
+	uint8_t mac_buf[SAFS_TAG_LEN];
+
+	/* Encrypt-then-MAC */
+	res = generate_cmac(c->data_in, c->data_size,
+			mac_buf, c->key, c->key_size);
+
+	if (res == TEE_SUCCESS) {
+		if (memcmp(mac_buf, tag, SAFS_TAG_LEN) != 0) {
+			res = TEE_ERROR_MAC_INVALID;
+			DMSG("MAC mismatched");
+		}
+	}
+
+	if (res == TEE_SUCCESS) {
+#ifdef CFG_ENC_FS
+		res = crypt_aes(TEE_ALG_AES_CBC_NOPAD, TEE_MODE_DECRYPT,
+				c, data_out);
+#else
+		(void)memcpy(data_out, c->data_in, c->data_size);
+		res = TEE_SUCCESS;
+#endif
+	}
+
+	return res;
+}
+
+TEE_Result tee_sfkm_generate_sha256(const uint8_t *data_in, size_t data_size,
+			uint8_t *hash_out)
+{
+	TEE_Result res;
+	uint8_t *ctx = NULL;
+	size_t ctx_size;
+	const uint32_t algo = TEE_ALG_SHA256;
+
+	res = crypto_ops.hash.get_ctx_size(algo, &ctx_size);
+
+	if (res == TEE_SUCCESS) {
+		ctx = malloc(ctx_size);
+		if (ctx == NULL) {
+			res = TEE_ERROR_OUT_OF_MEMORY;
+		}
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.hash.init(ctx, algo);
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.hash.update(ctx, algo, data_in, data_size);
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.hash.final(ctx, algo, hash_out,
+				TEE_SHA256_HASH_SIZE);
+	}
+
+	if (ctx != NULL) {
+		free(ctx);
+	}
+
+	if ((res != TEE_SUCCESS) && (res != TEE_ERROR_OUT_OF_MEMORY)) {
+		EMSG("crypto_provider hash error. 0x%x", res);
+		res = TEE_ERROR_SECURITY;
+	}
+
+	return res;
+}
+
+#ifdef CFG_ENC_FS
+static TEE_Result crypt_aes(uint32_t algo, TEE_OperationMode mode,
+			const struct tee_sfkm_crypt_info *c,
+			uint8_t *data_out)
+{
+	TEE_Result res;
+	uint8_t *ctx = NULL;
+	size_t ctx_size;
+
+	res = crypto_ops.cipher.get_ctx_size(algo, &ctx_size);
+
+	if (res == TEE_SUCCESS) {
+		ctx = malloc(ctx_size);
+		if (ctx == NULL) {
+			res = TEE_ERROR_OUT_OF_MEMORY;
+		}
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.cipher.init(ctx, algo, mode, c->key,
+				c->key_size, NULL, 0, c->iv, c->iv_size);
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.cipher.update(ctx, algo, mode, true,
+				c->data_in, c->data_size, data_out);
+	}
+
+	if (res == TEE_SUCCESS) {
+		crypto_ops.cipher.final(ctx, algo);
+		res = TEE_SUCCESS;
+	}
+
+	if (ctx != NULL) {
+		free(ctx);
+	}
+
+	if ((res != TEE_SUCCESS) && (res != TEE_ERROR_OUT_OF_MEMORY)) {
+		EMSG("crypto_provider cipher error. 0x%x", res);
+		res = TEE_ERROR_SECURITY;
+	}
+
+	return res;
+}
+#endif
+
+static TEE_Result generate_cmac(const uint8_t *data_in, size_t data_size,
+			uint8_t *mac_out, const uint8_t *key, size_t key_size)
+{
+	TEE_Result res;
+	uint8_t *ctx = NULL;
+	size_t ctx_size;
+	const uint32_t algo = TEE_ALG_AES_CMAC;
+	const size_t mac_size = TEE_AES_BLOCK_SIZE;
+
+	res = crypto_ops.mac.get_ctx_size(algo, &ctx_size);
+
+	if (res == TEE_SUCCESS) {
+		ctx = malloc(ctx_size);
+		if (ctx == NULL) {
+			res = TEE_ERROR_OUT_OF_MEMORY;
+		}
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.mac.init(ctx, algo, key, key_size);
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.mac.update(ctx, algo, data_in, data_size);
+	}
+
+	if (res == TEE_SUCCESS) {
+		res = crypto_ops.mac.final(ctx, algo, mac_out, mac_size);
+	}
+
+	if (ctx != NULL) {
+		free(ctx);
+	}
+
+	if ((res != TEE_SUCCESS) && (res != TEE_ERROR_OUT_OF_MEMORY)) {
+		EMSG("crypto_provider mac error. 0x%x", res);
+		res = TEE_ERROR_SECURITY;
+	}
+
+	return res;
+}
diff --git a/core/arch/arm/plat-rcar/tee/tee_standalone_fs_key_manager.h b/core/arch/arm/plat-rcar/tee/tee_standalone_fs_key_manager.h
new file mode 100644
index 0000000..4f4a4a6
--- /dev/null
+++ b/core/arch/arm/plat-rcar/tee/tee_standalone_fs_key_manager.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef TEE_STANDALONE_FS_KEY_MANAGER_H
+#define TEE_STANDALONE_FS_KEY_MANAGER_H
+
+#include <utee_defines.h>
+#include <tee/tee_fs_key_manager.h>
+
+#define SAFS_EK_SIZE		(16)		/* Encryption Key Size */
+#define SAFS_IV_LEN		(16)		/* Initial Vector Length */
+#define SAFS_TAG_LEN		(16)		/* MAC Length */
+
+struct tee_sfkm_crypt_info {
+	const uint8_t *data_in;
+	size_t data_size;
+	const uint8_t *iv;
+	size_t iv_size;
+	const uint8_t *key;
+	size_t key_size;
+};
+
+TEE_Result tee_sfkm_init_key_manager(void);
+
+TEE_Result tee_sfkm_generate_random(uint8_t *buf, uint8_t len);
+
+TEE_Result tee_sfkm_encrypt_suk(struct tee_sfkm_crypt_info *c,
+			uint8_t *data_out, uint8_t *tag,
+			uint8_t *encrypted_iv);
+
+TEE_Result tee_sfkm_encrypt(const struct tee_sfkm_crypt_info *c,
+			uint8_t *data_out, uint8_t *tag);
+
+TEE_Result tee_sfkm_decrypt_suk(struct tee_sfkm_crypt_info *c,
+			const uint8_t *tag, uint8_t *data_out,
+			uint8_t *decrypted_iv);
+
+TEE_Result tee_sfkm_decrypt(const struct tee_sfkm_crypt_info *c,
+			const uint8_t *tag, uint8_t *data_out);
+
+TEE_Result tee_sfkm_generate_sha256(const uint8_t *data_in,
+			size_t data_size, uint8_t *hash_out);
+
+#endif /* TEE_STANDALONE_FS_KEY_MANAGER_H */
diff --git a/core/arch/arm/plat-rcar/tee_common_otp.c b/core/arch/arm/plat-rcar/tee_common_otp.c
new file mode 100644
index 0000000..e179c3e
--- /dev/null
+++ b/core/arch/arm/plat-rcar/tee_common_otp.c
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2014, STMicroelectronics International N.V.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stddef.h>
+#include <string.h>
+#include <trace.h>
+#include <kernel/tee_common_otp.h>
+#include <io.h>
+#include <stdlib.h>
+#include <tee/tee_cryp_utl.h>
+#include <tee/tee_cryp_provider.h>
+#include <kernel/panic.h>
+#include <utee_defines.h>
+
+#include <libcryptoengine/tee_provider_common.h>
+#include <libcryptoengine/include_secure/dx_util.h>
+#include <libcryptoengine/include_secure/dx_util_error.h>
+#include "platform_config.h"
+
+static void read_uid_reg(uint8_t *read_uid, uint32_t read_num);
+
+static const uint32_t uid_read_num = 3U;
+static const uint32_t reg_size = sizeof(uint32_t);
+
+static void read_uid_reg(uint8_t *read_uid, uint32_t read_num)
+{
+	uint32_t uid;
+	uint32_t i;
+	uint32_t uid_addr = (uint32_t)LIFEC_BASE + 0x40U;
+
+	/* get uid from LifeC register. */
+	for (i = 0U; i < read_num; i++) {
+		uid = read32(uid_addr);
+		uid = TEE_U32_TO_BIG_ENDIAN(uid);
+		(void)memcpy(&read_uid[i * reg_size], &uid, reg_size);
+		uid_addr += reg_size;
+	}
+}
+
+void tee_otp_get_hw_unique_key(struct tee_hw_unique_key *hwkey)
+{
+	const uint32_t uid_size = uid_read_num * reg_size;
+	const uint8_t string_for_unique_key_gen[] = "R-Car_hw_unique_key";
+	const uint32_t str_size = sizeof(string_for_unique_key_gen);
+	const uint32_t data_size = uid_size + str_size;
+	uint8_t input_data[data_size];
+	SSError_t dx_util_ret;
+	DX_UTIL_KeyType_t aesKeyType = DX_UTIL_KDR_KEY;
+	DX_UTIL_AES_CmacResult_t util_aes_cmac_key;
+
+	if (hwkey != NULL) {
+		/* get uid from LifeC register */
+		read_uid_reg(input_data, uid_read_num);
+
+		/* edit input data. add a fixed string. */
+		(void)memcpy(&input_data[uid_size],
+				string_for_unique_key_gen, str_size);
+
+		/* get CMAC key, specify the Kdr */
+		dx_util_ret = DX_UTIL_CmacDeriveKey(aesKeyType,
+				input_data, data_size, util_aes_cmac_key);
+
+		if (dx_util_ret == DX_UTIL_OK) {
+			/* edit output data */
+			(void)memcpy(hwkey, util_aes_cmac_key,
+				sizeof(struct tee_hw_unique_key));
+		} else {
+			EMSG("DX_UTIL_CmacDeriveKey() error. 0x%x",
+				dx_util_ret);
+			panic();
+		}
+	} else {
+		EMSG("hwkey is NULL");
+		panic();
+	}
+}
+
+int tee_otp_get_die_id(uint8_t *buffer, size_t len)
+{
+	const uint32_t uid_size = uid_read_num * reg_size;
+	const uint8_t string_for_die_id_gen[] = "R-Car_die_id";
+	const uint32_t str_size = sizeof(string_for_die_id_gen);
+	const uint32_t data_size = uid_size + str_size;
+	const uint32_t digest_size = (uint32_t)TEE_SHA256_HASH_SIZE;
+	uint8_t input_data[data_size];
+	uint8_t digest[digest_size];
+	uint32_t i;
+	TEE_Result res;
+	int32_t rc = -1;
+
+	if ((buffer != NULL) && (len != 0U)) {
+		/* get uid from LifeC register. */
+		read_uid_reg(input_data, uid_read_num);
+
+		/* edit input data. add a fixed string. */
+		(void)memcpy(&input_data[uid_size],
+				string_for_die_id_gen, str_size);
+
+		/* get hash for SHA256 */
+		res = tee_hash_createdigest((uint32_t)TEE_ALG_SHA256,
+				input_data, data_size, digest, digest_size);
+
+		if (res == (TEE_Result)TEE_SUCCESS) {
+			/* edit output data */
+			for (i = 0U; i < len; i++) {
+				buffer[i] = digest[i % digest_size];
+			}
+			rc = 0;	/* success */
+		} else {
+			EMSG("tee_hash_createdigest() error. 0x%x", res);
+		}
+	} else {
+		EMSG("buffer is 0x%p. len is %zu.", buffer, len);
+	}
+
+	return rc;
+}
diff --git a/core/arch/arm/plat-rcar/trace_ext.c b/core/arch/arm/plat-rcar/trace_ext.c
new file mode 100644
index 0000000..97b0f23
--- /dev/null
+++ b/core/arch/arm/plat-rcar/trace_ext.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2014, Linaro Limited
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdbool.h>
+#include <trace.h>
+#include <arm.h>
+#include <kernel/tee_time.h>
+#include "rcar_log_func.h"
+#include "rcar_common.h"
+
+const char trace_ext_prefix[] = "TEE-CORE";
+int trace_level = TRACE_LEVEL;
+static uint32_t interrupt_ctx_log_flag = INTCTX_LOG_DEFAULT;
+
+void trace_ext_puts(const char *str)
+{
+	int8_t time_buf[LOG_TIME_BUF_MAX_SIZE] = {0};
+	size_t time_len = 0U;
+	TEE_Time sys_time = {0U, 0U};
+	TEE_Result ret;
+	int32_t res;
+	struct msg_block_t msg_block[MSG_BLK_MAX_NUM];
+	int32_t msg_block_num = 0;
+	uint32_t cpsr;
+#ifdef RCAR_DEBUG_LOG
+	const int8_t TERM_LOG_PREFIX[] = "[OP-TEE]";
+	const size_t TERM_LOG_PREFIX_LEN = sizeof(TERM_LOG_PREFIX) - 1U;
+	size_t log_sum_size = 0U;
+	int32_t i;
+#endif
+
+	if ((str != NULL) && (log_secram_header != NULL)) {
+		cpu_spin_lock_irqsave(&log_spin_lock, &cpsr);
+
+		if ((interrupt_ctx_log_flag != INTCTX_LOG_NOT_OUTPUT) ||
+		    ((cpsr & ARM32_CPSR_F) == 0U)) {
+			ret = arm_cntpct_get_sys_time(&sys_time);
+			if (ret == TEE_SUCCESS) {
+				res = snprintf((char *)time_buf,
+					sizeof(time_buf),
+					"[%u.%06u][%d]",
+					sys_time.seconds,
+					sys_time.millis * 1000U,
+					(int32_t)get_core_pos());
+				if (0 < res) {
+					time_len = (size_t)res;
+				}
+			}
+
+			msg_block[SECRAM_IDX_TIME].addr = time_buf;
+			msg_block[SECRAM_IDX_TIME].size = time_len;
+			msg_block[SECRAM_IDX_MESG].addr = (const int8_t *)str;
+			msg_block[SECRAM_IDX_MESG].size = strlen(str);
+			msg_block_num = SECRAM_MSG_BLK_NUM;
+
+			log_buf_write(msg_block, msg_block_num);
+		}
+
+		cpu_spin_unlock_irqrestore(&log_spin_lock, cpsr);
+
+#ifdef RCAR_DEBUG_LOG
+		if ((is_normal_world_initialized != 0) &&
+		    (msg_block_num > 0)) {
+			msg_block[TRMLOG_IDX_PRFX].addr = TERM_LOG_PREFIX;
+			msg_block[TRMLOG_IDX_PRFX].size = TERM_LOG_PREFIX_LEN;
+			msg_block[TRMLOG_IDX_TIME].addr = time_buf;
+			msg_block[TRMLOG_IDX_TIME].size = time_len;
+			msg_block[TRMLOG_IDX_MESG].addr = (const int8_t *)str;
+			msg_block[TRMLOG_IDX_MESG].size = strlen(str);
+			msg_block_num = TRMLOG_MSG_BLK_NUM;
+
+			/* Log size is limited to 256 byte */
+			for (i = 0; i < msg_block_num; i++) {
+				log_sum_size += msg_block[i].size;
+			}
+			if (log_sum_size > MAX_PRINT_SIZE) {
+				msg_block[msg_block_num - 1].size -=
+					log_sum_size - (uint32_t)MAX_PRINT_SIZE;
+			}
+
+			if ((cpsr & ARM32_CPSR_F) == 0U) {
+				/* User context */
+				log_debug_send(msg_block, msg_block_num);
+			} else {
+				/* Interrupt context */
+			}
+		}
+#endif
+	}
+}
+
+int trace_ext_get_thread_id(void)
+{
+	return -1;
+}
diff --git a/core/arch/arm/tee/arch_svc.c b/core/arch/arm/tee/arch_svc.c
index acab6d7..16cebe1 100644
--- a/core/arch/arm/tee/arch_svc.c
+++ b/core/arch/arm/tee/arch_svc.c
@@ -40,6 +40,9 @@
 #include <kernel/misc.h>
 #include <kernel/trace_ta.h>
 #include "svc_cache.h"
+#ifdef PLATFORM_RCAR
+#include <rcar_maskrom.h>
+#endif
 
 #if (TRACE_LEVEL == TRACE_FLOW) && defined(CFG_TEE_CORE_TA_TRACE)
 #define TRACE_SYSCALLS
@@ -133,6 +136,9 @@ static const struct syscall_entry tee_svc_syscall_table[] = {
 	SYSCALL_ENTRY(syscall_se_channel_transmit),
 	SYSCALL_ENTRY(syscall_se_channel_close),
 	SYSCALL_ENTRY(syscall_cache_operation),
+#ifdef PLATFORM_RCAR
+	SYSCALL_ENTRY(syscall_rcar_aes_unwrap),
+#endif
 };
 
 #ifdef TRACE_SYSCALLS
diff --git a/core/core.mk b/core/core.mk
index c163396..9c206ef 100644
--- a/core/core.mk
+++ b/core/core.mk
@@ -68,9 +68,28 @@ libdir = lib/libmpa
 include mk/lib.mk
 base-prefix :=
 
+ifeq ($(CFG_CRYPT_HW_CRYPTOENGINE),y)
+core-platform-cflags += -DENABLE_CRYPTOENGINE
+
+ifeq ($(CFG_CRYPT_ENABLE_CEPKA),y)
+libname = crypto_engine_pka
+libdir = core/lib/libcryptoengine
+include core/lib/libcryptoengine/libcc.mk
+endif
+
+libname = crypto_engine_secure
+libdir = core/lib/libcryptoengine
+include core/lib/libcryptoengine/libcc.mk
+
+libname = crypto_engine
+libdir = core/lib/libcryptoengine
+include mk/lib.mk
+
+else
 libname = tomcrypt
 libdir = core/lib/libtomcrypt
 include mk/lib.mk
+endif
 
 #
 # Do main source
diff --git a/core/drivers/gic.c b/core/drivers/gic.c
index ba0d203..7a00070 100644
--- a/core/drivers/gic.c
+++ b/core/drivers/gic.c
@@ -205,7 +205,7 @@ static void gic_it_add(struct gic_data *gd, size_t it)
 			gd->gicd_base + GICD_IGROUPR(idx));
 }
 
-static void gic_it_set_cpu_mask(struct gic_data *gd, size_t it,
+void gic_it_set_cpu_mask(struct gic_data *gd, size_t it,
 				uint8_t cpu_mask)
 {
 	size_t idx = it / NUM_INTS_PER_REG;
diff --git a/core/include/drivers/gic.h b/core/include/drivers/gic.h
index 8dd636b..4f8edb2 100644
--- a/core/include/drivers/gic.h
+++ b/core/include/drivers/gic.h
@@ -53,4 +53,7 @@ void gic_cpu_init(struct gic_data *gd);
 void gic_it_handle(struct gic_data *gd);
 
 void gic_dump_state(struct gic_data *gd);
+
+void gic_it_set_cpu_mask(struct gic_data *gd, size_t it, uint8_t cpu_mask);
+
 #endif /*__DRIVERS_GIC_H*/
diff --git a/core/include/kernel/tee_time.h b/core/include/kernel/tee_time.h
index 95dc91a..5c6556c 100644
--- a/core/include/kernel/tee_time.h
+++ b/core/include/kernel/tee_time.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2014, STMicroelectronics International N.V.
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,5 +39,6 @@ TEE_Result tee_time_get_ta_time(const TEE_UUID *uuid, TEE_Time *time);
 TEE_Result tee_time_get_ree_time(TEE_Time *time);
 TEE_Result tee_time_set_ta_time(const TEE_UUID *uuid, const TEE_Time *time);
 void tee_time_wait(uint32_t milliseconds_delay);
+TEE_Result arm_cntpct_get_sys_time(TEE_Time *time);
 
 #endif
diff --git a/core/include/tee/tee_cryp_provider.h b/core/include/tee/tee_cryp_provider.h
index f28a727..e1a0b84 100644
--- a/core/include/tee/tee_cryp_provider.h
+++ b/core/include/tee/tee_cryp_provider.h
@@ -71,6 +71,9 @@ struct cipher_ops {
 			     size_t len, uint8_t *dst);
 	void       (*final)(void *ctx, uint32_t algo);
 	TEE_Result (*get_block_size)(uint32_t algo, size_t *size);
+	TEE_Result (*unwrap)(void *srcData, uint32_t srcLen,
+			const void *keyData, uint32_t keySize,
+			uint32_t isSecretKey, void *destData, uint32_t *dstLen);
 };
 
 /* Message Authentication Code functions */
@@ -285,6 +288,21 @@ struct prng_ops {
 
 	/* to read random data from PRNG implementation	 */
 	TEE_Result (*read)(void *buf, size_t blen);
+
+	/* to read random data from PRNG implementation	(SHE) */
+	TEE_Result (*read_without_init)(void *buf, size_t blen);
+
+	/* to initialize PRNG (SHE)*/
+	TEE_Result (*init)(void);
+};
+
+struct util_ops {
+	/* to driver 128bit customer keys(CMAC) using Crypto Engine Secure */
+	TEE_Result (*cmac_derivekey)(uint32_t keyType, uint8_t *in,
+			uint32_t inSize, uint8_t *out, uint32_t outSize);
+	TEE_Result (*rpmb_signframes)(uint64_t *in, uint32_t listSize,
+			uint8_t *out, uint32_t outSize);
+	TEE_Result (*rpmb_derivekey)(uint8_t *out, uint32_t outSize);
 };
 
 /* Cryptographic Provider API */
@@ -300,6 +318,7 @@ struct crypto_ops {
 	struct acipher_ops acipher;
 	struct bignum_ops bignum;
 	struct prng_ops prng;
+	struct util_ops util;
 };
 
 extern const struct crypto_ops crypto_ops;
diff --git a/core/include/tee/tee_fs.h b/core/include/tee/tee_fs.h
index 7dd0225..ec38853 100644
--- a/core/include/tee/tee_fs.h
+++ b/core/include/tee/tee_fs.h
@@ -68,5 +68,10 @@ extern const struct tee_file_operations ree_fs_ops;
 #ifdef CFG_RPMB_FS
 extern const struct tee_file_operations rpmb_fs_ops;
 #endif
+#ifdef CFG_STANDALONE_FS
+extern const struct tee_file_operations standalone_fs_ops;
+#endif
+
+const struct tee_file_operations *file_ops(uint32_t storage_id);
 
 #endif
diff --git a/core/include/tee/tee_fs_key_manager.h b/core/include/tee/tee_fs_key_manager.h
index ac4ff50..39bcd39 100644
--- a/core/include/tee/tee_fs_key_manager.h
+++ b/core/include/tee/tee_fs_key_manager.h
@@ -32,7 +32,11 @@
 
 #define TEE_FS_KM_CHIP_ID_LENGTH    32
 #define TEE_FS_KM_HMAC_ALG          TEE_ALG_HMAC_SHA256
+#ifndef ENABLE_CRYPTOENGINE
 #define TEE_FS_KM_AUTH_ENC_ALG      TEE_ALG_AES_GCM
+#else
+#define TEE_FS_KM_AUTH_ENC_ALG      TEE_ALG_AES_CCM
+#endif
 #define TEE_FS_KM_ENC_FEK_ALG       TEE_ALG_AES_ECB_NOPAD
 #define TEE_FS_KM_SSK_SIZE          TEE_SHA256_HASH_SIZE
 #define TEE_FS_KM_FEK_SIZE          16  /* bytes */
diff --git a/core/include/tee/tee_svc_cryp.h b/core/include/tee/tee_svc_cryp.h
index 5b4e0c1..e6ac71a 100644
--- a/core/include/tee/tee_svc_cryp.h
+++ b/core/include/tee/tee_svc_cryp.h
@@ -102,4 +102,7 @@ TEE_Result syscall_asymm_verify(unsigned long state,
 			size_t num_params, const void *data, size_t data_len,
 			const void *sig, size_t sig_len);
 
+TEE_Result syscall_rcar_aes_unwrap(void *srcData, uint32_t srcLen,
+		void *keyData, uint32_t keySize, uint32_t isSecretKey, void *destData,
+		uint32_t *dstLen);
 #endif /* TEE_SVC_CRYP_H */
diff --git a/core/lib/libcryptoengine/libcc.mk b/core/lib/libcryptoengine/libcc.mk
new file mode 100644
index 0000000..5f68451
--- /dev/null
+++ b/core/lib/libcryptoengine/libcc.mk
@@ -0,0 +1,35 @@
+# Input
+#
+# libname	tells the name of the lib and
+# libdir	tells directory of lib which also is used as input to
+#		mk/subdir.mk
+# conf-file     [optional] if set, all objects will depend on $(conf-file)
+#
+# Output
+#
+# updated cleanfiles and
+# updated libfiles, libdirs, libnames and libdeps
+
+lib-libfile	 = $(out-dir)/$(base-prefix)$(libdir)/lib$(libname).a
+cleanfiles	:= $(cleanfiles) $(lib-libfile)
+libfiles	:= $(lib-libfile) $(libfiles)
+libdirs 	:= $(out-dir)/$(base-prefix)$(libdir) $(libdirs)
+libnames	:= $(libname) $(libnames)
+libdeps		:= $(lib-libfile) $(libdeps)
+
+define process-lib
+$(lib-libfile): $(objs)
+	@echo '  CP      $$@'
+	@mkdir -p $$(dir $$@)
+	@cp -Rp $(libdir)/lib$(libname).a $(out-dir)/$(base-prefix)$(libdir)
+endef #process-lib
+
+$(eval $(call process-lib))
+
+$(objs): $(conf-file)
+
+# Clean residues from processing
+objs		:=
+libname		:=
+lib-use-ld	:=
+sansa-library :=
diff --git a/core/lib/libcryptoengine/sub.mk b/core/lib/libcryptoengine/sub.mk
new file mode 100644
index 0000000..a45014a
--- /dev/null
+++ b/core/lib/libcryptoengine/sub.mk
@@ -0,0 +1,115 @@
+#Crypto enable
+CFG_CRYPTO ?= y
+
+ifeq (y,$(CFG_CRYPTO))
+
+# Ciphers
+CFG_CRYPTO_AES ?= y
+CFG_CRYPTO_DES ?= y
+
+# Cipher block modes
+CFG_CRYPTO_ECB ?= y
+CFG_CRYPTO_CBC ?= y
+CFG_CRYPTO_CTR ?= y
+CFG_CRYPTO_CTS ?= y
+CFG_CRYPTO_XTS ?= y
+
+# Message authentication codes
+CFG_CRYPTO_HMAC ?= y
+CFG_CRYPTO_CMAC ?= y
+CFG_CRYPTO_CBC_MAC ?= y
+
+# Hashes
+CFG_CRYPTO_MD5 ?= y
+CFG_CRYPTO_SHA1 ?= y
+CFG_CRYPTO_SHA224 ?= y
+CFG_CRYPTO_SHA256 ?= y
+CFG_CRYPTO_SHA384 ?= y
+CFG_CRYPTO_SHA512 ?= y
+
+# Asymmetric ciphers
+CFG_CRYPTO_DSA ?= y
+CFG_CRYPTO_RSA ?= y
+CFG_CRYPTO_DH ?= y
+CFG_CRYPTO_ECC ?= y
+
+# Authenticated encryption
+CFG_CRYPTO_CCM ?= y
+CFG_CRYPTO_GCM ?= y
+
+endif
+
+ifeq ($(CFG_WITH_PAGER),y)
+ifneq ($(CFG_CRYPTO_SHA256),y)
+ifneq ($(CFG_CRYPTO_SHA256_ARM32_CE),y)
+$(warning Warning: Enabling CFG_CRYPTO_SHA256 [required by CFG_WITH_PAGER])
+CFG_CRYPTO_SHA256:=y
+endif
+endif
+endif
+
+cryp-enable-all-depends = $(call cfg-enable-all-depends,$(strip $(1)),$(foreach v,$(2),CFG_CRYPTO_$(v)))
+$(eval $(call cryp-enable-all-depends,CFG_ENC_FS, AES ECB CTR HMAC SHA256 GCM))
+
+# Dependency checks: warn and disable some features if dependencies are not met
+
+cryp-dep-one = $(call cfg-depends-one,CFG_CRYPTO_$(strip $(1)),$(patsubst %, CFG_CRYPTO_%,$(strip $(2))))
+cryp-dep-all = $(call cfg-depends-all,CFG_CRYPTO_$(strip $(1)),$(patsubst %, CFG_CRYPTO_%,$(strip $(2))))
+
+$(eval $(call cryp-dep-one, ECB, AES DES))
+$(eval $(call cryp-dep-one, CBC, AES DES))
+$(eval $(call cryp-dep-one, CTR, AES))
+# CTS is implemented with ECB and CBC
+$(eval $(call cryp-dep-all, CTS, AES ECB CBC))
+$(eval $(call cryp-dep-one, XTS, AES))
+$(eval $(call cryp-dep-one, HMAC, AES DES))
+$(eval $(call cryp-dep-one, HMAC, MD5 SHA1 SHA224 SHA256 SHA384 SHA512))
+$(eval $(call cryp-dep-one, CMAC, AES))
+$(eval $(call cryp-dep-one, CBC_MAC, AES DES))
+$(eval $(call cryp-dep-one, CCM, AES))
+$(eval $(call cryp-dep-one, GCM, AES))
+# If no AES cipher mode is left, disable AES
+$(eval $(call cryp-dep-one, AES, ECB CBC CTR CTS XTS))
+# If no DES cipher mode is left, disable DES
+$(eval $(call cryp-dep-one, DES, ECB CBC))
+
+cryp-one-enabled = $(call cfg-one-enabled,$(foreach v,$(1),CFG_CRYPTO_$(v)))
+cryp-all-enabled = $(call cfg-all-enabled,$(foreach v,$(1),CFG_CRYPTO_$(v)))
+
+_CFG_CRYPTO_WITH_ACIPHER := $(call cryp-one-enabled, RSA DSA DH ECC)
+_CFG_CRYPTO_WITH_AUTHENC := $(and $(filter y,$(CFG_CRYPTO_AES)), $(call cryp-one-enabled, CCM GCM))
+_CFG_CRYPTO_WITH_CIPHER := $(call cryp-one-enabled, AES DES)
+_CFG_CRYPTO_WITH_HASH := $(call cryp-one-enabled, MD5 SHA1 SHA224 SHA256 SHA384 SHA512)
+_CFG_CRYPTO_WITH_MAC := $(call cryp-one-enabled, HMAC CMAC CBC_MAC)
+_CFG_CRYPTO_WITH_CBC := $(call cryp-one-enabled, CBC CBC_MAC)
+_CFG_CRYPTO_WITH_ASN1 := $(call cryp-one-enabled, RSA DSA)
+_CFG_CRYPTO_WITH_FORTUNA_PRNG := $(call cryp-all-enabled, AES SHA256)
+
+cppflags-lib-$(libtomcrypt_with_optimize_size) += -DLTC_SMALL_CODE -DLTC_NO_FAST
+
+# Get mpa.h which normally is an internal .h file
+global-incdirs-y += ../libtomcrypt/include
+subdirs-y += ../libtomcrypt/src/math
+subdirs-y += ../libtomcrypt/src/misc
+subdirs-y += ../libtomcrypt/src/pk/ecc
+subdirs-y += ../libtomcrypt/src/pk/rsa
+srcs-y += ../libtomcrypt/src/mpa_desc.c
+cflags-../libtomcrypt/src/mpa_desc.c-y += -Wno-declaration-after-statement
+cflags-../libtomcrypt/src/mpa_desc.c-y += -Wno-unused-parameter
+
+ifeq ($(CFG_CRYPT_ENABLE_CEPKA),y)
+# Provider fro Crypto Engine PKA
+srcs-y += tee_pka_provider.c
+cflags-tee_pka_provider.c-y += -Wno-maybe-uninitialized
+endif
+
+#Provider for Crypto Engine Secure
+srcs-y += tee_ss_provider.c
+cflags-tee_ss_provider.c-y += -Wno-unused-function
+cflags-tee_ss_provider.c-y += -Wno-int-to-pointer-cast
+cflags-tee_ss_provider.c-y += -Wno-strict-aliasing
+cflags-tee_ss_provider.c-y += -Wno-pedantic
+cflags-tee_ss_provider.c-y += -Wno-undef -Wno-maybe-uninitialized
+
+# Common Function for Provider
+srcs-y += tee_provider_common.c
diff --git a/core/lib/libcryptoengine/tee_pka_provider.c b/core/lib/libcryptoengine/tee_pka_provider.c
new file mode 100644
index 0000000..f26009c
--- /dev/null
+++ b/core/lib/libcryptoengine/tee_pka_provider.c
@@ -0,0 +1,276 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY
+ */
+#include "include_pka/crys_error.h"
+#include "include_pka/sa_pkadrvlib.h"
+#include "tee_provider_common.h"
+#include "tee_pka_provider.h"
+
+/******************************************************************************/
+/* Static Function Prototypes                                                 */
+/******************************************************************************/
+static SSError_t pka_translate_error_pka2ss_ecc(SA_PkadrvlibRetCode_t err);
+static SSError_t pka_get_ecc_keysize(uint32_t curve,
+		CRYS_ECPKI_DomainID_t *domain_id,
+		uint32_t *key_size_bytes);
+static void userProcessCompletedFunc(CRYSError_t opStatus __unused,
+		void* pVerifContext __unused);
+
+/*
+ * brief:	Translate  CRYS API AES error into SS provider error.
+ *
+ * param[in]	err		- CRYS API AES error code
+ * return	TEE_Result
+ */
+static SSError_t pka_translate_error_pka2ss_ecc(SA_PkadrvlibRetCode_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("SA_PkadrvlibRetCode_t err=0x%08x\n", err);
+
+	switch (err) {
+	case SA_PKADRVLIB_RET_OK:
+	case SA_PKADRVLIB_RET_EINPROGRESS:
+		PROV_EMSG("res = SS_ERROR_BAD_STATE\n");
+		res = SS_SUCCESS;
+		break;
+	case SA_PKADRVLIB_RET_MUTEX_LOCK_ERROR:
+	case SA_PKADRVLIB_RET_MUTEX_UNLOCK_ERROR:
+	case SA_PKADRVLIB_RET_MUTEX_INIT_ERROR:
+	case SA_PKADRVLIB_RET_MUTEX_TERMINATE_ERROR:
+		PROV_EMSG("res = SS_ERROR_BAD_STATE\n");
+		res = SS_ERROR_BAD_STATE;
+		break;
+	default:
+		PROV_EMSG("res = SS_ERROR_BAD_STATE\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Get ECC key size by the domain ID of TEE internal API.
+ *
+ * param[in]	curve			- Domain ID of TEE internal API.
+ * param[out]	*domain_id		- Domain ID of CRYS API.
+ * return	SSError_t		- SS provider error code.
+ */
+static SSError_t pka_get_ecc_keysize(uint32_t curve,
+		CRYS_ECPKI_DomainID_t *domain_id, uint32_t *key_size_bytes)
+{
+	SSError_t res = SS_SUCCESS;
+
+	PROV_INMSG("curve=%d\n", curve);
+
+	switch ((int32_t)curve) {
+	case TEE_ECC_CURVE_NIST_P192:
+		PROV_DMSG("v\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp192r1;
+		*key_size_bytes = 24U;
+		break;
+	case TEE_ECC_CURVE_NIST_P224:
+		PROV_DMSG("curve=TEE_ECC_CURVE_NIST_P224\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp224r1;
+		*key_size_bytes = 28U;
+		break;
+	case TEE_ECC_CURVE_NIST_P256:
+		PROV_DMSG("curve=TEE_ECC_CURVE_NIST_P256\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp256r1;
+		*key_size_bytes = 32U;
+		break;
+	case TEE_ECC_CURVE_NIST_P384:
+		PROV_DMSG("curve=TEE_ECC_CURVE_NIST_P384\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp384r1;
+		*key_size_bytes = 48U;
+		break;
+	case TEE_ECC_CURVE_NIST_P521:
+		PROV_DMSG("curve=TEE_ECC_CURVE_NIST_P521\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp521r1;
+		*key_size_bytes = 66U;
+		break;
+	default:
+		PROV_DMSG("ERROR: NOT SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Callback for signalign "engine available" events,
+ *              in case all engines ware busy.
+ * 		But in case of Gen3, unusing callback function.
+ *
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static void userProcessCompletedFunc(CRYSError_t opStatus __unused,
+		void* pVerifContext __unused)
+{
+	return;
+}
+
+/*
+ * brief:	Verify by the ECC using CRYS API (FIPS 186-4 ANSI X9.62)
+ *
+ * param[in]	*key		- Pointer to the struct of the ECC key pair.
+ * param[in]	*msg		- Pointer to the message data buffer.
+ * param[in]	msg_len		- Size of message data buffer.
+ * param[in]	*sig		- Pointer to the signature data buffer.
+ * param[in]	*sig_len	- Size of signature data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+TEE_Result ss_ecc_verify_pka(struct ecc_public_key *key, const uint8_t *msg,
+		size_t msg_len, const uint8_t *sig, size_t sig_len)
+{
+	TEE_Result tee_res;
+	CRYSError_t crys_res;
+	SSError_t res = SS_SUCCESS;
+	SA_PkadrvlibRetCode_t pka_res;
+	CRYS_ECPKI_UserPublKey_t *pUserPublKey = NULL;
+	CRYS_ECPKI_HASH_OpMode_t eccHash = CRYS_ECPKI_AFTER_HASH_SHA1_mode;
+	uint8_t *pSignatureIn;
+	uint32_t signatureSizeBytes;
+	uint8_t *pMessageDataIn;
+	uint32_t messageSizeInBytes;
+	CRYS_ECPKI_DomainID_t domain_id;
+	CRYS_ECPKI_Domain_t *ecc_domain;
+	uint8_t *publKeyIn_ptr = NULL;
+	uint32_t publKeySizeInBytes;
+	size_t publKeySizeXBytes;
+	size_t publKeySizeYBytes;
+	uint32_t modulusbytes;
+	uint8_t *publKeyX_ptr = NULL;
+	uint8_t *publKeyY_ptr = NULL;
+
+	PROV_INMSG("*key=%p, *msg=%p, msg_len=%ld\n", (void * )key, msg,
+			msg_len);
+	PROV_INMSG("*sig=%p, sig_len=%ld\n", sig, sig_len);
+
+	pSignatureIn = (uint8_t *)sig;
+	signatureSizeBytes = (uint32_t)sig_len;
+	pMessageDataIn = (uint8_t *)msg;
+	messageSizeInBytes = (uint32_t)msg_len;
+
+	if (key == NULL) {
+		res = SS_ERROR_BAD_PARAMETERS;
+		PROV_DMSG("BAD_PARAMETERS(key)\n");
+	}
+
+	if (res == SS_SUCCESS) {
+		pUserPublKey = (CRYS_ECPKI_UserPublKey_t *)ss_malloc(
+				sizeof(CRYS_ECPKI_UserPublKey_t), &res);
+	}
+
+	if (res == SS_SUCCESS) {
+		res = pka_get_ecc_keysize(key->curve, &domain_id, &modulusbytes);
+	}
+
+	if (res == SS_SUCCESS) {
+		crys_res = CRYS_ECPKI_GetEcDomain(domain_id, &ecc_domain);
+		res = ss_translate_error_crys2ss_ecc(crys_res);
+		PROV_DMSG("Result: res=0x%08x\n", res);
+	}
+
+	if (res == SS_SUCCESS) {
+		/* malloc public key size */
+		res = ss_copy_bn2bin(key->x, &publKeyX_ptr, &publKeySizeXBytes);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin(key->y, &publKeyY_ptr, &publKeySizeYBytes);
+	}
+	if (res == SS_SUCCESS) {
+		publKeySizeInBytes = (sizeof(uint8_t) + (modulusbytes * 2U));
+		publKeyIn_ptr = (uint8_t *)ss_calloc(1U, publKeySizeInBytes, &res);
+	}
+
+	if (res == SS_SUCCESS) {
+		/* build public key */
+		*publKeyIn_ptr = (uint8_t)CRYS_EC_PointUncompressed;
+		(void)memcpy(((publKeyIn_ptr + 1U + modulusbytes)
+						- publKeySizeXBytes),
+				publKeyX_ptr, publKeySizeXBytes);
+		(void)memcpy(((publKeyIn_ptr + 1U + (modulusbytes * 2U))
+						- publKeySizeYBytes),
+				publKeyY_ptr, publKeySizeYBytes);
+		PROV_DMSG("CALL:  CRYS_ECPKI_BuildPublKey()\n");
+		PROV_DMSG("ecc_domain=%p publkeyIn_ptr=%p\n", (void *)ecc_domain,
+				(void *)publKeyIn_ptr);
+		PROV_DMSG("publKeySizeInBytes=%d pUserPublKey=%p\n",
+				publKeySizeInBytes, (void *)pUserPublKey);
+		pka_res = SA_PKADRV_EcdsaBuildPublKey(ecc_domain, publKeyIn_ptr,
+				publKeySizeInBytes, pUserPublKey);
+		res = pka_translate_error_pka2ss_ecc(pka_res);
+		PROV_DMSG("Result: res=0x%08x\n", res);
+	}
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL:  SA_PKADRV_EcdsaVerifyMessage()\n");
+		PROV_DMSG("pUserPublKey=%p eccHash=%d\n",
+				(void *)pUserPublKey, eccHash);
+		PROV_DMSG("pSignatureIn=%p signatureSizeBytes=%d\n",
+				(void *)pSignatureIn, signatureSizeBytes);
+		PROV_DMSG("pMessageDataIn=%p messageSizeInBytes=%d\n",
+				(void *)pMessageDataIn, messageSizeInBytes);
+		pka_res = SA_PKADRV_EcdsaVerifyMessage(
+		NULL, &userProcessCompletedFunc, pUserPublKey, eccHash,
+				pSignatureIn, signatureSizeBytes,
+				pMessageDataIn, messageSizeInBytes);
+		res = pka_translate_error_pka2ss_ecc(pka_res);
+		PROV_DMSG("Result: res=0x%08x\n", res);
+	}
+
+	ss_free((void *)publKeyX_ptr);
+	ss_free((void *)publKeyY_ptr);
+	ss_free((void *)publKeyIn_ptr);
+	ss_free((void *)pUserPublKey);
+
+	OUTMSG("END do_ecc_verify_pka res=0x%08x\n", res);
+	tee_res = ss_translate_error_ss2tee(res);
+	return tee_res;
+}
+
+/*
+ * brief:	Initialize the Crypto Engine PKA.
+ *
+ * return	TEE_Result	- TEE internal API error code.
+ */
+TEE_Result pka_verify_init(void)
+{
+
+	TEE_Result res;
+	SA_PkadrvlibRetCode_t pka_res;
+
+	PROV_INMSG("SA_PKADRV_Init()\n");
+	pka_res = SA_PKADRV_Init(NULL, NULL);
+	res = pka_translate_error_pka2ss_ecc(pka_res);
+
+	return res;
+}
diff --git a/core/lib/libcryptoengine/tee_pka_provider.h b/core/lib/libcryptoengine/tee_pka_provider.h
new file mode 100644
index 0000000..bc6f397
--- /dev/null
+++ b/core/lib/libcryptoengine/tee_pka_provider.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY
+ */
+
+#ifndef TEE_PKA_PROVIDER_H
+#define TEE_PKA_PROVIDER_H
+
+#include <tee/tee_cryp_provider.h>
+
+/******************************************************************************/
+/* Public Function Prototypes                                                 */
+/******************************************************************************/
+TEE_Result ss_ecc_verify_pka(struct ecc_public_key *key,
+		const uint8_t *msg, size_t msg_len, const uint8_t *sig,
+		size_t sig_len);
+
+TEE_Result pka_verify_init(void);
+
+#endif
diff --git a/core/lib/libcryptoengine/tee_provider_common.c b/core/lib/libcryptoengine/tee_provider_common.c
new file mode 100644
index 0000000..eab387b
--- /dev/null
+++ b/core/lib/libcryptoengine/tee_provider_common.c
@@ -0,0 +1,518 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY
+ */
+
+#include "tee_provider_common.h"
+
+const ErrorTable_t error_tbl[SS_ERROR_LAST_NUM] = {
+	{SS_SUCCESS,			  (TEE_Result)TEE_SUCCESS	   },
+	{SS_ERROR_CORRUPT_OBJECT,	  TEE_ERROR_CORRUPT_OBJECT	   },
+	{SS_ERROR_CORRUPT_OBJECT_2,	  TEE_ERROR_CORRUPT_OBJECT_2	   },
+	{SS_ERROR_STORAGE_NOT_AVAILABLE,  TEE_ERROR_STORAGE_NOT_AVAILABLE  },
+	{SS_ERROR_STORAGE_NOT_AVAILABLE_2,TEE_ERROR_STORAGE_NOT_AVAILABLE_2},
+	{SS_ERROR_GENERIC,		  TEE_ERROR_GENERIC		   },
+	{SS_ERROR_ACCESS_DENIED,	  TEE_ERROR_ACCESS_DENIED	   },
+	{SS_ERROR_CANCEL,		  TEE_ERROR_CANCEL		   },
+	{SS_ERROR_ACCESS_CONFLICT,	  TEE_ERROR_ACCESS_CONFLICT	   },
+	{SS_ERROR_EXCESS_DATA,		  TEE_ERROR_EXCESS_DATA		   },
+	{SS_ERROR_BAD_FORMAT,		  TEE_ERROR_BAD_FORMAT		   },
+	{SS_ERROR_BAD_PARAMETERS,	  TEE_ERROR_BAD_PARAMETERS	   },
+	{SS_ERROR_BAD_STATE,		  TEE_ERROR_BAD_STATE		   },
+	{SS_ERROR_ITEM_NOT_FOUND,	  TEE_ERROR_ITEM_NOT_FOUND	   },
+	{SS_ERROR_NOT_IMPLEMENTED,	  TEE_ERROR_NOT_IMPLEMENTED	   },
+	{SS_ERROR_NOT_SUPPORTED,	  TEE_ERROR_NOT_SUPPORTED	   },
+	{SS_ERROR_NO_DATA,		  TEE_ERROR_NO_DATA		   },
+	{SS_ERROR_OUT_OF_MEMORY,	  TEE_ERROR_OUT_OF_MEMORY	   },
+	{SS_ERROR_BUSY,			  TEE_ERROR_BUSY		   },
+	{SS_ERROR_COMMUNICATION,	  TEE_ERROR_COMMUNICATION	   },
+	{SS_ERROR_SECURITY,		  TEE_ERROR_SECURITY		   },
+	{SS_ERROR_SHORT_BUFFER,		  TEE_ERROR_SHORT_BUFFER	   },
+	{SS_ERROR_EXTERNAL_CANCEL,	  TEE_ERROR_EXTERNAL_CANCEL	   },
+	{SS_ERROR_OVERFLOW,		  TEE_ERROR_OVERFLOW		   },
+	{SS_ERROR_TARGET_DEAD,		  TEE_ERROR_TARGET_DEAD		   },
+	{SS_ERROR_STORAGE_NO_SPACE,	  TEE_ERROR_STORAGE_NO_SPACE	   },
+	{SS_ERROR_MAC_INVALID,		  TEE_ERROR_MAC_INVALID		   },
+	{SS_ERROR_SIGNATURE_INVALID,	  TEE_ERROR_SIGNATURE_INVALID	   },
+	{SS_ERROR_TIME_NOT_SET,		  TEE_ERROR_TIME_NOT_SET	   },
+	{SS_ERROR_TIME_NEEDS_RESET,	  TEE_ERROR_TIME_NEEDS_RESET	   },
+	{SS_ERROR_LAST_NUM, 		  0U}
+};
+
+
+
+
+/*
+ * brief:	Allocate memory block with malloc.
+ *
+ * param[in]	malloc_size	- Allocate memory size.
+ * param[out]	*err		- SS provider error code.
+ * return	*void		- Pointer to the memory block allocated.
+ */
+void *ss_malloc(size_t malloc_size, SSError_t *err)
+{
+	void *res = NULL;
+
+	PROV_INMSG("malloc_size=%ld err=0x%08x\n",malloc_size, *err);
+
+
+	if (0U == malloc_size) {
+		*err = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETERS malloc_size=%ld\n",
+				malloc_size);
+	}
+
+	if (SS_SUCCESS == *err) {
+		res = malloc(malloc_size);
+		if (NULL == res) {
+			*err = SS_ERROR_OUT_OF_MEMORY;
+			PROV_EMSG("OUT_OF_MEMORY \n");
+		} else {
+			*err = SS_SUCCESS;
+		}
+	}
+
+	PROV_OUTMSG("res=%p err = 0x%08x\n",res,*err);
+	return res;
+}
+
+/*
+ * brief:	Allocate memory block with calloc.
+ *
+ * param[in]	n		- Number of elements to allocate.
+ * param[in]	calloc_size	- Allocate memory size.
+ * param[out]	*err		- SS provider error code.
+ * return	*void		- Pointer to the memory block allocated.
+ */
+void *ss_calloc(size_t n, size_t calloc_size, SSError_t *err)
+{
+	void *res = NULL;
+
+	PROV_INMSG("n=%ld calloc_size=%ld err=0x%08x\n",n,calloc_size, *err);
+
+	if (n == 0U) {
+		*err = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETER n=%ld\n", n);
+	}
+	if (*err == SS_SUCCESS) {
+		if (calloc_size == 0U) {
+			*err = SS_ERROR_BAD_PARAMETERS;
+			PROV_EMSG("BAD_PARAMETER calloc_size=%ld\n",calloc_size);
+		}
+	}
+	if (*err == SS_SUCCESS) {
+		res = calloc(n, calloc_size);
+		if (res == NULL) {
+			*err = SS_ERROR_OUT_OF_MEMORY;
+			PROV_EMSG("OUT_OF_MEMORY res=NULL\n");
+		} else {
+			*err = SS_SUCCESS;
+			PROV_IMSG("SUCCESS calloc\n");
+		}
+	}
+
+	PROV_OUTMSG("res=%p err=0x%08x\n",res, *err);
+	return res;
+}
+
+/*
+ * brief:	Deallocate memory block.
+ *
+ * param[in]	*free_ptr	- Pointer to a memory block previously allocated.
+ * return	void
+ */
+void ss_free(void *free_ptr)
+{
+	if (free_ptr != NULL) {
+		free(free_ptr);
+	} else {
+		PROV_IMSG("Input address is NULL");
+	}
+}
+
+/*
+ * brief:	Allocate memory block and copy data buffer.
+ *
+ * param[in]	malloc_size	- Size of a memory block to allocate.
+ * param[in]	*src		- Pointer to a memory block previously allocated.
+ * param[in]	src_len		- Allocate memory size.
+ * param[in]	*err		- SS provider error code.
+ * return	void		- Pointer to a memory block allocated.
+ */
+void *ss_malloc_and_copy(size_t malloc_size, const void *src, size_t src_len,
+		SSError_t *err)
+{
+	void* res = NULL;
+	PROV_INMSG("malloc_size=%ld src=%p src_len=0x%08lx err=0x%08x\n",
+			malloc_size, src, src_len, *err);
+
+	if(src == NULL){
+		*err = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("ERROR(src) SS_ERROR_BAD_PARAMETERS\n");
+	}
+	if(src_len == 0U){
+		*err = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("ERROR(src_len) SS_ERROR_BAD_PARAMETERS\n");
+	}
+	if (*err == SS_SUCCESS) {
+		res = ss_malloc(malloc_size, err);
+	}
+	if (*err == SS_SUCCESS) {
+		PROV_IMSG("memcpy\n");
+		(void)memcpy(res, src, src_len);
+	}
+
+	PROV_OUTMSG("res=%p err=0x%08x\n",res, *err);
+	return res;
+}
+
+#define SS_MAX_BITS_PER_VARIABLE   (4096)
+#define SS_VARIABLE_NUMBER         (50)
+
+
+/*
+ * brief:	Calculate the bignum size (byte).
+ *
+ * param[in]	*a		- Pointer to bignum data.
+ * return	size_t		- Size of bignum represented in byte.
+ */
+size_t bn_num_bytes(struct bignum *a)
+{
+	PROV_INMSG("a=%p\n", (void *)a);
+	return mp_unsigned_bin_size(a);
+}
+
+/*
+ * brief:	Calculate the bignum size (bit).
+ *
+ * param[in]	*a		- Pointer to bignum data.
+ * return	size_t		- Size of bignum represented in bit.
+ */
+size_t bn_num_bits(struct bignum *a)
+{
+	PROV_INMSG("a=%p\n",(void *)a);
+	return (size_t)mp_count_bits(a);
+}
+
+/*
+ * brief:	Compare two bignum date.
+ *
+ * param[in]	*a		- The bignum data(op1).
+ * param[in]	*b		- The bignum data(op2).
+ * return	size_t		- 0 op1 == op2
+ *          			  1 op1 >  op2
+ *          			 -1 op1 <  op2
+ */
+int32_t bn_compare(struct bignum *a, struct bignum *b)
+{
+	PROV_INMSG("a=%p b=%p\n",(void *)a,(void *)b);
+	return mp_cmp(a, b);
+}
+
+/*
+ * brief:	Convert bignum into binary.
+ *
+ * param[in]	*from		- Bignum data.
+ * param[out]	*to		- Binary data.
+ * return	void
+ */
+void bn_bn2bin(const struct bignum *from, uint8_t *to)
+{
+	void *from_tmp;
+	from_tmp = (void *)from;
+
+	PROV_INMSG("from=%p to=%p\n",(void *)from, to);
+
+	mp_to_unsigned_bin(from_tmp, to);
+
+	PROV_OUTMSG("return (void)");
+}
+
+/*
+ * brief:	Convert binary into bignum.
+ *
+ * param[in]	*from		- Pointer to the binary data buffer.
+ * param[in]	fromsize	- Size of the binary data buffer.
+ * param[out]	*to		- Pointer to the output data of bignum.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+TEE_Result bn_bin2bn(const uint8_t *from, size_t fromsize,
+		struct bignum *to)
+{
+	TEE_Result res = (TEE_Result)TEE_SUCCESS;
+	void *to_tmp;
+	uint8_t *from_tmp;
+
+	PROV_INMSG("from=%p fromsize=%ld to=%p\n",from, fromsize, (void *)to);
+
+	to_tmp = to;
+	from_tmp = (uint8_t *)from;
+	if (mp_read_unsigned_bin(to_tmp, from_tmp, fromsize)
+			!= (int)CRYPT_OK) {
+		res = TEE_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("ERROR TEE_ERROR_BAD_PARAMETERS");
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n",res);
+	return res;
+}
+
+/*
+ * brief:	Copy the bignum data.
+ *
+ * param[out]	*to		- Pointer to the output bignum data.
+ * param[in]	*from		- Pointer to the input bignum data.
+ * return	void
+ */
+void bn_copy(struct bignum *to, const struct bignum *from)
+{
+	void *from_tmp;
+	from_tmp = (void *)from;
+
+	PROV_INMSG("to=%p from=%p\n",(void *)to, (void *)from);
+	mp_copy(from_tmp, (void * )to);
+	PROV_OUTMSG("return (void)");
+}
+
+/*
+ * brief:	Allocate memory block of the bignum.
+ *
+ * param[in]	*size_bits	- Size of memory block (bit).
+ * return	TEE_Result	- Pointer to the memory block allocated.
+ */
+struct bignum *bn_allocate(size_t size_bits)
+{
+	struct bignum *res;
+	struct mpa_numbase_struct *bn;
+	size_t mpaSize;
+	size_t sz;
+
+	PROV_INMSG("size_bits=%ld\n",size_bits);
+	mpaSize = (size_t)mpa_StaticVarSizeInU32(size_bits);
+	sz = mpaSize * sizeof(uint32_t);
+	bn = (struct mpa_numbase_struct *)calloc(1U, sz);
+	if (bn == NULL) {
+		PROV_EMSG("Error: bn=%p\n",(void *)bn);
+		res = NULL;
+	} else {
+		PROV_DMSG("success memory allocate\n");
+		bn->alloc = sz - ((size_t)MPA_NUMBASE_METADATA_SIZE_IN_U32
+				* sizeof(uint32_t));
+		res = (struct bignum *)bn;
+	}
+
+	PROV_OUTMSG("return res=%p\n",(void *)res);
+	return res;
+}
+
+/*
+ * brief:	Free memory block of bignum.
+ *
+ * param[in]	*s		- Pointer to the bignum data.
+ * return	void
+ */
+void bn_free(struct bignum *s)
+{
+	PROV_INMSG("s=%p\n",(void *)s);
+	ss_free((void *)s);
+	PROV_OUTMSG("return (void)");
+}
+
+/*
+ * brief:	Fill the bignum data 0.
+ *
+ * param[in]	*s		- Pointer to the bignum data.
+ * return	void
+ */
+void bn_clear(struct bignum *s)
+{
+	struct mpa_numbase_struct *bn;
+	PROV_INMSG("s=%p\n",(void *)s);
+	bn = (struct mpa_numbase_struct *)s;
+	(void)memset(bn, 0, bn->alloc);
+	PROV_OUTMSG("return (void)");
+}
+
+/*
+ * brief:	Allocate memory block of the bignum max size.
+ *
+ * param[in]	**s		- Double pointer to the bignum data.
+ * return	SSError_t	- SS provider error code.
+ */
+SSError_t bn_alloc_max(struct bignum **s)
+{
+	size_t sz;
+	SSError_t res;
+
+	PROV_INMSG("s=%p\n",(void *)s);
+	sz = (size_t)mpa_StaticVarSizeInU32(SS_MAX_BITS_PER_VARIABLE*2)
+			* sizeof(uint32_t) * 8U;
+
+	PROV_DMSG("Call: bn_allocate(%ld)",sz);
+	*s = bn_allocate(sz);
+
+	if (*s == 0) {
+		PROV_EMSG("Error: bn_allocate");
+		res = SS_ERROR_OUT_OF_MEMORY;
+	} else {
+		PROV_DMSG("Success: bn_allocate");
+		res = SS_SUCCESS;
+	}
+
+	PROV_OUTMSG("return res=0x%08x",res);
+	return res;
+}
+
+/*
+ * brief:	Convert bignum into binary.
+ *
+ * param[in]	*from		- Pointer to the binary data buffer.
+ * param[in]	fromsize	- Size of the binary data buffer.
+ * param[out]	*to		- Pointer to the output data of bignum.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+SSError_t ss_bn_bin2bn(const uint8_t *from, size_t fromsize,
+		struct bignum *to)
+{
+	SSError_t ss_res;
+	TEE_Result res;
+	PROV_INMSG("*from=%p, fromsize=%ld, *to=%p\n",from,fromsize,(void *)to);
+
+	res = bn_bin2bn(from, fromsize, to);
+
+	ss_res = ss_translate_error_tee2ss(res);
+	OUTMSG("return ss_res=0x%08x -> res=0x%08x\n",ss_res,res);
+	return ss_res;
+}
+
+/*
+ * brief:	Copy and convert bignum into binary.
+ *
+ * param[in]	*src_bin	- Pointer to the bignum data buffer.
+ * param[out]	**dest_ptr	- Pointer to the binary data address.
+ * param[out]	*dest_size	- Pointer to the binary data size.
+ * return	SSError_t	- SS provider error code.
+ */
+SSError_t ss_copy_bn2bin(struct bignum *src_bn, uint8_t **dest_ptr,
+		size_t *dest_size)
+{
+	SSError_t res = SS_SUCCESS;
+	PROV_INMSG("*src_bin=%p, dest_ptr=%p, dest_size=%ld\n",(void *)src_bn, *dest_ptr,*dest_size);
+
+	if (src_bn == NULL) {
+		PROV_EMSG("Error: SS_ERROR_BAD_PARAMETERS");
+		res = SS_ERROR_BAD_PARAMETERS;
+	} else {
+		*dest_size = (size_t)bn_num_bytes(src_bn);
+		*dest_ptr = (uint8_t *)ss_malloc(*dest_size, &res);
+		bn_bn2bin(src_bn, *dest_ptr);
+	}
+
+	PROV_OUTMSG("dest_ptr=%p, dest_size=%ld\n",*dest_ptr,*dest_size);
+	PROV_OUTMSG("return res=0x%08x\n",res);
+	return res;
+}
+
+/*
+ * brief:	Convert bignum into binary.
+ *
+ * param[in]	*src_bin	- Pointer to the bignum data buffer.
+ * param[out]	**dest_ptr	- Pointer to the binary data address.
+ * param[out]	*dest_size	- Pointer to the binary data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+SSError_t ss_copy_bn2bin_uint16(struct bignum *src_bn, uint8_t **dest_ptr,
+		uint16_t *dest_size)
+{
+	SSError_t res;
+	size_t tmp_size = 0U;
+
+	PROV_INMSG("*src_bin=%p, dest_size=%d\n",(void *)src_bn, *dest_size);
+	res = ss_copy_bn2bin(src_bn, dest_ptr, &tmp_size);
+
+	if (res == SS_SUCCESS) {
+		if (tmp_size > 0xFFFFU) {
+			PROV_EMSG("Error: SS_ERROR_OVERFLOW");
+			res = SS_ERROR_OVERFLOW;
+		} else {
+			*dest_size = (uint16_t)tmp_size;
+		}
+	}
+
+	PROV_OUTMSG("dest_ptr=%p, dest_size=%d\n",*dest_ptr,*dest_size);
+	PROV_OUTMSG("return res=0x%08x\n",res);
+	return res;
+}
+
+
+/*
+ * brief:	Translate SS provider error into TEE internal API error.
+ *
+ * param[in]	err		- TEE Internal API error code
+ * return	TEE_Result
+ */
+SSError_t ss_translate_error_tee2ss(TEE_Result err)
+{
+	uint8_t i;
+	SSError_t res = SS_ERROR_GENERIC;
+
+	PROV_INMSG("TEE_Result err= 0x%08x\n", err);
+
+	for (i = 0U; i < (SS_ERROR_LAST_NUM - 1U); i++) {
+		if (err == error_tbl[i].tee_result) {
+			res = error_tbl[i].ss_error;
+			break;
+		}
+	}
+
+	PROV_OUTMSG("SSError_t res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate SS provider error into TEE internal API error.
+ *
+ * param[in]	err		- Error code for provider
+ * return	TEE_Result
+ */
+TEE_Result ss_translate_error_ss2tee(SSError_t err)
+{
+	uint8_t i;
+	TEE_Result res = TEE_ERROR_GENERIC;
+
+	PROV_INMSG("SSError_t  err = 0x%08x\n", err);
+
+	for (i = 0U; i < (SS_ERROR_LAST_NUM - 1U); i++) {
+		if (err == error_tbl[i].ss_error) {
+			res = error_tbl[i].tee_result;
+			break;
+		}
+	}
+
+	PROV_OUTMSG("TEE_Result res = 0x%08x\n", res);
+	return res;
+}
+
+
diff --git a/core/lib/libcryptoengine/tee_provider_common.h b/core/lib/libcryptoengine/tee_provider_common.h
new file mode 100644
index 0000000..cd2ca42
--- /dev/null
+++ b/core/lib/libcryptoengine/tee_provider_common.h
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY
+ */
+#ifndef TEE_PROVIDER_COMMON_H
+#define TEE_PROVIDER_COMMON_H
+
+#include <tee/tee_cryp_provider.h>
+#include <tee/tee_cryp_utl.h>
+#include <kernel/tee_common_unpg.h>
+#include <mpalib.h>
+#include <stdlib.h>
+#include <string.h>
+#include <utee_defines.h>
+#include <trace.h>
+#include <tee_api_types.h>
+#include <string_ext.h>
+#include <util.h>
+#include <tomcrypt_mpa.h>
+#include <tomcrypt_macros.h>
+#include "include_secure/crys_error.h"
+/******************************************************************************/
+/* Defines                                                                    */
+/******************************************************************************/
+/* Debug */
+#define PROV_INMSG(...)		do{}while(0)
+#define PROV_OUTMSG(...)	do{}while(0)
+#define PROV_EMSG(...)		do{}while(0)
+#define PROV_IMSG(...)		do{}while(0)
+#define PROV_DMSG(...)		do{}while(0)
+#define PROV_FMSG(...)		do{}while(0)
+#define PROV_DHEXDUMP(...)	do{}while(0)
+
+/* Provider error codes */
+#define SS_SUCCESS			  0x0000000000U
+#define SS_ERROR_CORRUPT_OBJECT		  0x0000000001U
+#define SS_ERROR_CORRUPT_OBJECT_2	  0x0000000002U
+#define SS_ERROR_STORAGE_NOT_AVAILABLE	  0x0000000003U
+#define SS_ERROR_STORAGE_NOT_AVAILABLE_2  0x0000000004U
+#define SS_ERROR_GENERIC		  0x0000000005U
+#define SS_ERROR_ACCESS_DENIED		  0x0000000006U
+#define SS_ERROR_CANCEL			  0x0000000007U
+#define SS_ERROR_ACCESS_CONFLICT	  0x0000000008U
+#define SS_ERROR_EXCESS_DATA		  0x0000000009U
+#define SS_ERROR_BAD_FORMAT		  0x000000000AU
+#define SS_ERROR_BAD_PARAMETERS		  0x000000000BU
+#define SS_ERROR_BAD_STATE		  0x000000000CU
+#define SS_ERROR_ITEM_NOT_FOUND		  0x000000000DU
+#define SS_ERROR_NOT_IMPLEMENTED	  0x000000000EU
+#define SS_ERROR_NOT_SUPPORTED		  0x000000000FU
+#define SS_ERROR_NO_DATA		  0x0000000010U
+#define SS_ERROR_OUT_OF_MEMORY		  0x0000000011U
+#define SS_ERROR_BUSY			  0x0000000012U
+#define SS_ERROR_COMMUNICATION		  0x0000000013U
+#define SS_ERROR_SECURITY		  0x0000000014U
+#define SS_ERROR_SHORT_BUFFER		  0x0000000015U
+#define SS_ERROR_EXTERNAL_CANCEL	  0x0000000016U
+#define SS_ERROR_OVERFLOW		  0x0000000017U
+#define SS_ERROR_TARGET_DEAD		  0x0000000018U
+#define SS_ERROR_STORAGE_NO_SPACE	  0x0000000019U
+#define SS_ERROR_MAC_INVALID		  0x000000001AU
+#define SS_ERROR_SIGNATURE_INVALID	  0x000000001BU
+#define SS_ERROR_TIME_NOT_SET		  0x000000001CU
+#define SS_ERROR_TIME_NEEDS_RESET	  0x000000001DU
+#define SS_ERROR_LAST_NUM		  0x000000001FU
+
+/******************************************************************************/
+/* Typedefs                                                                   */
+/******************************************************************************/
+typedef uint32_t SSError_t;
+
+typedef struct {
+	SSError_t ss_error;
+	TEE_Result tee_result;
+}ErrorTable_t;
+
+/******************************************************************************/
+/* Global Variables                                                           */
+/******************************************************************************/
+extern const ErrorTable_t error_tbl[SS_ERROR_LAST_NUM];
+
+/******************************************************************************/
+/* Public Function Prototypes                                                 */
+/******************************************************************************/
+size_t bn_num_bytes(struct bignum *a);
+size_t bn_num_bits(struct bignum *a);
+int32_t bn_compare(struct bignum *a, struct bignum *b);
+void bn_bn2bin(const struct bignum *from, uint8_t *to);
+TEE_Result bn_bin2bn(const uint8_t *from, size_t fromsize,
+		struct bignum *to);
+SSError_t ss_bn_bin2bn(const uint8_t *from, size_t fromsize,
+		struct bignum *to);
+struct bignum *bn_allocate(size_t size_bits);
+void bn_free(struct bignum *s);
+void bn_clear(struct bignum *s);
+SSError_t bn_alloc_max(struct bignum **s);
+void bn_copy(struct bignum *to, const struct bignum *from);
+SSError_t ss_copy_bn2bin(struct bignum *src_bn, uint8_t **dest_ptr,
+		size_t *dest_size);
+void *ss_malloc_and_copy(size_t malloc_size, const void* src,
+		size_t src_len, SSError_t *err);
+
+void *ss_malloc(size_t malloc_size, SSError_t *err);
+void *ss_calloc(size_t n, size_t calloc_size, SSError_t *err);
+void ss_free(void *free_ptr);
+SSError_t ss_copy_bn2bin_uint16(struct bignum *src_bn,
+		uint8_t **dest_ptr, uint16_t *dest_size);
+SSError_t ss_translate_error_tee2ss(TEE_Result err);
+TEE_Result ss_translate_error_ss2tee(SSError_t err);
+SSError_t ss_translate_error_crys2ss_ecc(CRYSError_t err);
+/*****************************************************/
+
+#endif
diff --git a/core/lib/libcryptoengine/tee_ss_provider.c b/core/lib/libcryptoengine/tee_ss_provider.c
new file mode 100644
index 0000000..6c77595
--- /dev/null
+++ b/core/lib/libcryptoengine/tee_ss_provider.c
@@ -0,0 +1,6275 @@
+/*
+ * Copyright (c) 2015-2016, Renesas Electronics Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY
+ */
+#include <platform_config.h>
+#include <drivers/gic.h>
+#include <tomcrypt.h>
+#include "tee_provider_common.h"
+#include "include_secure/crys.h"
+#include "include_secure/crys_rsa_types.h"
+#include "include_secure/crys_rsa_error.h"
+#include "include_secure/crys_aes_error.h"
+#include "include_secure/crys_des_error.h"
+#include "include_secure/crys_hash_error.h"
+#include "include_secure/crys_hmac_error.h"
+#include "include_secure/crys_aesccm_error.h"
+#include "include_secure/crys_rnd_error.h"
+#include "include_secure/crys_dh_error.h"
+#include "include_secure/crys_ecpki_build.h"
+#include "include_secure/dx_cclib.h"
+#include "include_secure/dx_util.h"
+#include "include_secure/dx_util_error.h"
+#include "include_secure/dx_util_rpmb.h"
+#include "include_secure/crys_aes_unwrap_rcar.h"
+
+#ifdef CFG_CRYPT_ENABLE_CEPKA
+#include "tee_pka_provider.h"
+#endif
+
+typedef struct {
+	CRYS_AESCCM_UserContext_t crys_ctx;
+	CRYSError_t crys_error;
+	uint8_t restBuf[16U];
+	uint32_t restBufSize;
+	uint32_t blockSize;
+	uint32_t tagSize;
+} SS_AESCCM_Context_t;
+
+typedef struct {
+	CRYS_AESUserContext_t crys_ctx;
+	CRYSError_t crys_error;
+	uint8_t restBuf[32U];
+	uint32_t restBufSize;
+	uint32_t blockSize;
+	TEE_OperationMode mode;
+} SS_AES_Context_t;
+
+typedef struct {
+	CRYS_DESUserContext_t crys_ctx;
+	CRYSError_t crys_error;
+	uint8_t restBuf[8U];
+	uint32_t restBufSize;
+	uint32_t blockSize;
+} SS_DES_Context_t;
+
+typedef struct {
+	CRYS_HASHUserContext_t crys_ctx;
+	CRYSError_t crys_error;
+	uint8_t restBuf[128U];
+	uint32_t restBufSize;
+	uint32_t blockSize;
+} SS_HASH_Context_t;
+
+typedef struct {
+	CRYS_HMACUserContext_t crys_ctx;
+	CRYSError_t crys_error;
+	uint8_t restBuf[128U];
+	uint32_t restBufSize;
+	uint32_t blockSize;
+} SS_HMAC_Context_t;
+
+typedef enum {
+	SS_ALG_AES,
+	SS_ALG_DES,
+	SS_ALG_HASH,
+	SS_ALG_HMAC,
+	SS_ALG_AESCCM
+}ss_crys_algo;
+
+#define MAX_DATAIN_SIZE (64U*1024U)
+#define MAX_DATAIN_CCM_SIZE (512U*1024U)
+
+#define CONV_HASHMODE_TO_OAEP(hashMode) \
+do { \
+	switch (hashMode) { \
+	case CRYS_RSA_After_SHA1_mode: \
+		(hashMode) = CRYS_RSA_HASH_SHA1_mode; \
+		break; \
+	case CRYS_RSA_After_SHA224_mode: \
+		(hashMode) = CRYS_RSA_HASH_SHA224_mode; \
+		break; \
+	case CRYS_RSA_After_SHA256_mode: \
+		(hashMode) = CRYS_RSA_HASH_SHA384_mode; \
+		break; \
+	case CRYS_RSA_After_SHA384_mode: \
+		(hashMode) = CRYS_RSA_HASH_SHA384_mode; \
+		break; \
+	case CRYS_RSA_After_SHA512_mode: \
+		(hashMode) = CRYS_RSA_HASH_SHA512_mode; \
+		break; \
+	default: \
+		break; \
+	} \
+}while (0)
+
+#define CHECK_CONTEXT(res,ss_ctx,type,ctx) \
+do{ \
+	if ((ctx) != NULL) { \
+		(ss_ctx) = (type *)(ctx); \
+		if ((ss_ctx)->crys_error != (SSError_t)CRYS_OK) { \
+			(res) = SS_ERROR_BAD_STATE; \
+			PROV_EMSG("BAD_STATE crys_error=0x%08x\n", \
+					(ss_ctx)->crys_error); \
+		} \
+	} else { \
+		(res) = SS_ERROR_BAD_PARAMETERS; \
+		PROV_EMSG("BAD_PARAMETERS(ctx=NULL)\n"); \
+	} \
+} while(0)
+
+#define NULL_CHECK_RSA_KEYPAIR(ptr,res) \
+do { \
+	if(NULL == (ptr)){ \
+		(res) = SS_ERROR_BAD_PARAMETERS; \
+		PROV_EMSG("BAD_PARAMETERS key is NULL\n"); \
+	} else { \
+		if((NULL == (ptr)->e) || \
+		   (NULL == (ptr)->d) || \
+		   (NULL == (ptr)->n) || \
+		   (NULL == (ptr)->p) || \
+		   (NULL == (ptr)->q) || \
+		   (NULL == (ptr)->qp) || \
+		   (NULL == (ptr)->dp) || \
+		   (NULL == (ptr)->dq)) { \
+			(res) = SS_ERROR_BAD_PARAMETERS; \
+			PROV_EMSG("BAD_PARAMETERS key menbers are NULL\n"); \
+		} \
+	} \
+}while (0)
+
+#define NULL_CHECK_RSA_PUBLIC_KEY(ptr,res) \
+do { \
+	if(NULL == (ptr)){ \
+		(res) = SS_ERROR_BAD_PARAMETERS; \
+		PROV_EMSG("BAD_PARAMETERS key is NULL\n"); \
+	} else { \
+		if((NULL == (ptr)->e) || \
+		   (NULL == (ptr)->n)) { \
+			(res) = SS_ERROR_BAD_PARAMETERS; \
+			PROV_EMSG("BAD_PARAMETERS key menbers are NULL\n"); \
+		} \
+	} \
+}while (0)
+
+#define NULL_CHECK_DH_KEYPAIR(ptr,res) \
+do { \
+	if(NULL == (ptr)){ \
+		(res) = SS_ERROR_BAD_PARAMETERS; \
+		PROV_EMSG("BAD_PARAMETERS key is NULL\n"); \
+	} else { \
+		if((NULL == (ptr)->g) || \
+		   (NULL == (ptr)->p) || \
+		   (NULL == (ptr)->x) || \
+		   (NULL == (ptr)->y) || \
+		   (NULL == (ptr)->q)) { \
+			(res) = SS_ERROR_BAD_PARAMETERS; \
+			PROV_EMSG("BAD_PARAMETERS key menbers are NULL\n"); \
+		} \
+	} \
+}while (0)
+
+#define NULL_CHECK_ECC_PUBLIC_KEY(ptr,res) \
+do { \
+	if(NULL == (ptr)){ \
+		(res) = SS_ERROR_BAD_PARAMETERS; \
+		PROV_EMSG("BAD_PARAMETERS key is NULL\n"); \
+	} else { \
+		if((NULL == (ptr)->x) || \
+		   (NULL == (ptr)->y)) { \
+			(res) = SS_ERROR_BAD_PARAMETERS; \
+			PROV_EMSG("BAD_PARAMETERS key menbers are NULL\n"); \
+		} \
+	} \
+}while (0)
+
+#define NULL_CHECK_ECC_KEYPAIR(ptr,res) \
+do { \
+	if(NULL == (ptr)){ \
+		(res) = SS_ERROR_BAD_PARAMETERS; \
+		PROV_EMSG("BAD_PARAMETERS key is NULL\n"); \
+	} else { \
+		if((NULL == (ptr)->d) || \
+		   (NULL == (ptr)->x) || \
+		   (NULL == (ptr)->y)) { \
+			(res) = SS_ERROR_BAD_PARAMETERS; \
+			PROV_EMSG("BAD_PARAMETERS key menbers are NULL\n"); \
+		} \
+	} \
+}while (0)
+
+
+
+/*************** declaration statement ***************/
+static TEE_Result hash_get_ctx_size(uint32_t algo, size_t *size);
+static TEE_Result hash_init(void *ctx, uint32_t algo);
+static TEE_Result hash_update(void *ctx, uint32_t algo, const uint8_t *data,
+		size_t len);
+static TEE_Result hash_final(void *ctx, uint32_t algo, uint8_t *digest,
+		size_t len);
+
+static TEE_Result do_alloc_rsa_keypair(struct rsa_keypair *s,
+		size_t key_size_bits __unused);
+static TEE_Result do_alloc_rsa_public_key(struct rsa_public_key *s,
+		size_t key_size_bits __unused);
+static void free_rsa_public_key(struct rsa_public_key *s);
+static TEE_Result do_gen_rsa_key(struct rsa_keypair *key, size_t key_size);
+static TEE_Result do_rsanopad_encrypt(struct rsa_public_key *key,
+		const uint8_t *src, size_t src_len, uint8_t *dst,
+		size_t *dst_len);
+static TEE_Result do_rsanopad_decrypt(struct rsa_keypair *key,
+		const uint8_t *src, size_t src_len, uint8_t *dst,
+		size_t *dst_len);
+static TEE_Result do_rsaes_decrypt(uint32_t algo, struct rsa_keypair *key,
+		const uint8_t *label, size_t label_len, const uint8_t *src,
+		size_t src_len, uint8_t *dst, size_t *dst_len);
+static TEE_Result do_rsaes_encrypt(uint32_t algo, struct rsa_public_key *key,
+		const uint8_t *label, size_t label_len, const uint8_t *src,
+		size_t src_len, uint8_t *dst, size_t *dst_len);
+static TEE_Result do_rsassa_sign(uint32_t algo, struct rsa_keypair *key,
+		int salt_len, const uint8_t *msg, size_t msg_len, uint8_t *sig,
+		size_t *sig_len);
+static TEE_Result do_rsassa_verify(uint32_t algo, struct rsa_public_key *key,
+		int salt_len, const uint8_t *msg, size_t msg_len,
+		const uint8_t *sig, size_t sig_len);
+
+static TEE_Result do_alloc_dsa_keypair(struct dsa_keypair *s,
+		size_t key_size_bits __unused);
+static TEE_Result do_alloc_dsa_public_key(struct dsa_public_key *s,
+		size_t key_size_bits __unused);
+static TEE_Result do_gen_dsa_key(struct dsa_keypair *key, size_t key_size);
+static TEE_Result do_dsa_sign(uint32_t algo, struct dsa_keypair *key,
+		const uint8_t *msg, size_t msg_len, uint8_t *sig,
+		size_t *sig_len);
+static TEE_Result do_dsa_verify(uint32_t algo, struct dsa_public_key *key,
+		const uint8_t *msg, size_t msg_len, const uint8_t *sig,
+		size_t sig_len);
+
+static TEE_Result do_alloc_dh_keypair(struct dh_keypair *s,
+		size_t key_size_bits __unused);
+static TEE_Result do_gen_dh_key(struct dh_keypair *key, struct bignum *q,
+		size_t xbits);
+static TEE_Result do_dh_shared_secret(struct dh_keypair *private_key,
+		struct bignum *public_key, struct bignum *secret);
+		
+#if defined(CFG_CRYPTO_ECC)
+static TEE_Result do_alloc_ecc_keypair(struct ecc_keypair *s,
+		size_t key_size_bits __unused);
+static TEE_Result do_alloc_ecc_public_key(struct ecc_public_key *s,
+		size_t key_size_bits __unused);
+static void free_ecc_public_key(struct ecc_public_key *s);
+static SSError_t ss_get_ecc_keysize(uint32_t curve,
+		CRYS_ECPKI_DomainID_t *domain_id, uint32_t *key_size_bytes);
+
+static TEE_Result do_gen_ecc_key(struct ecc_keypair *key);
+static TEE_Result do_ecc_sign(uint32_t algo, struct ecc_keypair *key,
+		const uint8_t *msg, size_t msg_len, uint8_t *sig,
+		size_t *sig_len);
+static TEE_Result do_ecc_verify(uint32_t algo, struct ecc_public_key *key,
+		const uint8_t *msg, size_t msg_len, const uint8_t *sig,
+		size_t sig_len);
+static TEE_Result do_ecc_shared_secret(struct ecc_keypair *private_key,
+		struct ecc_public_key *public_key, void *secret,
+		unsigned long *secret_len);
+#endif
+static TEE_Result cipher_get_block_size(uint32_t algo, size_t *size);
+static TEE_Result cipher_get_ctx_size(uint32_t algo, size_t *size);
+static TEE_Result cipher_init(void *ctx, uint32_t algo, TEE_OperationMode mode,
+		const uint8_t *key1, size_t key1_len, const uint8_t *key2,
+		size_t key2_len, const uint8_t *iv, size_t iv_len);
+static TEE_Result cipher_update(void *ctx, uint32_t algo,
+		TEE_OperationMode mode,
+		bool last_block, const uint8_t *data, size_t len, uint8_t *dst);
+static void cipher_final(void *ctx, uint32_t algo);
+
+static TEE_Result mac_get_ctx_size(uint32_t algo, size_t *size);
+static TEE_Result mac_init(void *ctx, uint32_t algo, const uint8_t *key,
+		size_t len);
+static TEE_Result mac_update(void *ctx, uint32_t algo, const uint8_t *data,
+		size_t len);
+static TEE_Result mac_final(void *ctx, uint32_t algo, uint8_t *digest,
+		size_t digest_len);
+
+static TEE_Result authenc_get_ctx_size(uint32_t algo, size_t *size);
+static TEE_Result authenc_init(void *ctx, uint32_t algo, TEE_OperationMode mode,
+		const uint8_t *key, size_t key_len, const uint8_t *nonce,
+		size_t nonce_len, size_t tag_len, size_t aad_len,
+		size_t payload_len);
+static TEE_Result authenc_update_aad(void *ctx, uint32_t algo,
+		TEE_OperationMode mode __unused, const uint8_t *data,
+		size_t len);
+static TEE_Result authenc_update_payload(void *ctx, uint32_t algo,
+		TEE_OperationMode mode, const uint8_t *src_data, size_t src_len,
+		uint8_t *dst_data, size_t *dst_len);
+static TEE_Result authenc_enc_final(void *ctx, uint32_t algo,
+		const uint8_t *src_data, size_t src_len, uint8_t *dst_data,
+		size_t *dst_len, uint8_t *dst_tag, size_t *dst_tag_len);
+static TEE_Result authenc_dec_final(void *ctx, uint32_t algo,
+		const uint8_t *src_data, size_t src_len, uint8_t *dst_data,
+		size_t *dst_len, const uint8_t *tag, size_t tag_len);
+static void authenc_final(void *ctx, uint32_t algo);
+static TEE_Result prng_read(void *buf, size_t blen);
+static TEE_Result prng_read_without_init(void *buf, size_t blen);
+static TEE_Result prng_add_entropy(const uint8_t *inbuf, size_t len);
+static TEE_Result prng_init(void);
+static TEE_Result tee_ss_init(void);
+static TEE_Result do_cmac_derivekey(uint32_t keyType, uint8_t *in,
+		uint32_t inSize, uint8_t *out, uint32_t outSize);
+static TEE_Result do_rpmb_signframes(uint64_t *in, uint32_t listSize,
+		uint8_t *out, uint32_t outSize);
+static TEE_Result do_rpmb_derivekey(uint8_t *out, uint32_t outSize);
+static TEE_Result cipher_unwrap(void *srcData, uint32_t srcLen,
+		const void *keyData, uint32_t keySize, uint32_t isSecretKey,
+		void *destData, uint32_t *dstLen);
+
+/* ss provider original function */
+static SSError_t ss_get_rsa_hash(uint32_t algo,
+		CRYS_RSA_HASH_OpMode_t *rsa_hashmode, size_t *hashSize,
+		CRYS_PKCS1_MGF_t *mgf, CRYS_PKCS1_version *version);
+static SSError_t ss_build_pub_key(CRYS_RSAUserPubKey_t **userPubKey,
+		struct rsa_public_key *key);
+static SSError_t ss_build_priv_key(CRYS_RSAUserPrivKey_t **userPrivKey,
+		struct rsa_keypair *key);
+static SSError_t ss_aes_init(void *ctx, uint32_t algo, TEE_OperationMode mode,
+		const uint8_t *key1, size_t key1_len, const uint8_t *key2,
+		size_t key2_len, const uint8_t *iv, size_t iv_len);
+static SSError_t ss_des_init(void *ctx, uint32_t algo, TEE_OperationMode mode,
+		const uint8_t *key1, size_t key1_len, const uint8_t *key2,
+		size_t key2_len, const uint8_t *iv, size_t iv_len);
+static SSError_t ss_swap_cts_block(uint32_t algo, uint8_t *dstPtr,
+		uint32_t dstSize, uint32_t blockSize);
+static SSError_t ss_aes_update(void *ctx, uint32_t algo, bool last_block, const uint8_t *data,
+		size_t len, uint8_t *dst);
+static SSError_t ss_des_update(void *ctx, uint32_t algo, const uint8_t *data, size_t len,
+		uint8_t *dst);
+static void ss_aes_final(void *ctx, uint32_t algo);
+static void ss_des_final(void *ctx, uint32_t algo);
+static SSError_t ss_aesmac_init(void *ctx, uint32_t algo, const uint8_t *key,
+		size_t len);
+static SSError_t ss_hmac_init(void *ctx, uint32_t algo, const uint8_t *key,
+		size_t len);
+static SSError_t ss_hmac_update(void *ctx, uint32_t algo, const uint8_t *data, size_t len);
+static SSError_t ss_aesmac_update(void *ctx, uint32_t algo, const uint8_t *data,
+		size_t len);
+static SSError_t ss_hmac_final(void *ctx, uint32_t algo, uint8_t *digest,
+		size_t digest_len);
+static SSError_t ss_aesmac_final(void *ctx, uint32_t algo, uint8_t *digest, size_t digest_len);
+static SSError_t ss_translate_error_crys2ss_init(DX_CclibRetCode_t err);
+static SSError_t ss_translate_error_crys2ss_rsa(CRYSError_t err);
+static SSError_t ss_translate_error_crys2ss_dh(CRYSError_t err);
+static SSError_t ss_translate_error_crys2ss_aes(CRYSError_t err);
+static SSError_t ss_translate_error_crys2ss_des(CRYSError_t err);
+static SSError_t ss_translate_error_crys2ss_hash(CRYSError_t err);
+static SSError_t ss_translate_error_crys2ss_hmac(CRYSError_t err);
+static SSError_t ss_translate_error_crys2ss_ccm(CRYSError_t err);
+static SSError_t ss_translate_error_crys2ss_rnd(CRYSError_t err);
+static SSError_t ss_translate_error_crys2ss_util(DxUTILError_t err);
+static void tee_ltc_alloc_mpa(void);
+#ifndef CFG_CRYPT_ENABLE_CEPKA
+static SSError_t ss_ecc_verify_secure(struct ecc_public_key *key,
+		const uint8_t *msg, size_t msg_len, const uint8_t *sig,
+		size_t sig_len);
+#endif
+
+static SSError_t ss_buffer_update(void *ctx, uint32_t algo,
+		const uint8_t *srcData, uint32_t srcLen, uint8_t **dstData);
+
+static SSError_t ss_crys_aes_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr, CRYSError_t *crysRes);
+static SSError_t ss_crys_des_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr, CRYSError_t *crysRes);
+static SSError_t ss_crys_hash_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr, CRYSError_t *crysRes);
+static SSError_t ss_crys_hmac_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr, CRYSError_t *crysRes);
+static SSError_t ss_crys_aesccm_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr, CRYSError_t *crysRes);
+
+static SSError_t ss_crys_aes_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr, CRYSError_t *crysRes)
+{
+	SSError_t res;
+	PROV_DMSG("ctx=%p dataIn_prt=%p\n", ctx, dataIn_ptr);
+	PROV_DMSG("dataInSize=%d dataOut_ptr=%p\n", dataInSize, dataOut_ptr);
+	*crysRes = CRYS_AES_Block((CRYS_AESUserContext_t *)ctx, dataIn_ptr,
+			dataInSize, dataOut_ptr);
+	res = ss_translate_error_crys2ss_aes(*crysRes);
+	PROV_DMSG("crysRes=0x%08x -> res=0x%08x\n", *crysRes, res);
+	return res;
+}
+static SSError_t ss_crys_des_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr, CRYSError_t *crysRes)
+{
+	SSError_t res;
+	PROV_DMSG("ctx=%p dataIn_prt=%p\n", ctx, dataIn_ptr);
+	PROV_DMSG("dataInSize=%d dataOut_ptr=%p\n", dataInSize, dataOut_ptr);
+	*crysRes = CRYS_DES_Block((CRYS_DESUserContext_t *)ctx, dataIn_ptr,
+			dataInSize, dataOut_ptr);
+	res = ss_translate_error_crys2ss_des(*crysRes);
+	PROV_DMSG("crysRes=0x%08x -> res=0x%08x\n", *crysRes, res);
+	return res;
+}
+static SSError_t ss_crys_hash_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr __unused,
+		CRYSError_t *crysRes)
+{
+	SSError_t res;
+	PROV_DMSG("ctx=%p dataIn_prt=%p\n", ctx, dataIn_ptr);
+	PROV_DMSG("dataInSize=%d dataOut_ptr=%p\n", dataInSize, dataOut_ptr);
+	*crysRes = CRYS_HASH_Update((CRYS_HASHUserContext_t *)ctx, dataIn_ptr,
+			dataInSize);
+	res = ss_translate_error_crys2ss_hash(*crysRes);
+	PROV_DMSG("crysRes=0x%08x -> res=0x%08x\n", *crysRes, res);
+	return res;
+}
+static SSError_t ss_crys_hmac_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr __unused,
+		CRYSError_t *crysRes)
+{
+	SSError_t res;
+	PROV_DMSG("ctx=%p dataIn_prt=%p\n", ctx, dataIn_ptr);
+	PROV_DMSG("dataInSize=%d dataOut_ptr=%p\n", dataInSize, dataOut_ptr);
+	*crysRes = CRYS_HMAC_Update((CRYS_HMACUserContext_t *)ctx, dataIn_ptr,
+			dataInSize);
+	res = ss_translate_error_crys2ss_hmac(*crysRes);
+	PROV_DMSG("crysRes=0x%08x -> res=0x%08x\n", *crysRes, res);
+	return res;
+}
+static SSError_t ss_crys_aesccm_update(void *ctx, uint8_t *dataIn_ptr,
+		uint32_t dataInSize, uint8_t *dataOut_ptr, CRYSError_t *crysRes)
+{
+	SSError_t res;
+	PROV_DMSG("ctx=%p dataIn_prt=%p\n", ctx, dataIn_ptr);
+	PROV_DMSG("dataInSize=%d dataOut_ptr=%p\n", dataInSize, dataOut_ptr);
+	*crysRes = CRYS_AESCCM_BlockTextData((CRYS_AESCCM_UserContext_t *)ctx,
+			dataIn_ptr, dataInSize, dataOut_ptr);
+	res = ss_translate_error_crys2ss_ccm(*crysRes);
+	PROV_DMSG("crysRes=0x%08x -> res=0x%08x\n", *crysRes, res);
+	return res;
+}
+
+/*****************************************************/
+
+/*
+ * brief:	Translate  CRYS API initialize error into SS provider error.
+ *
+ * param[in]	err		- CRYS API initialize error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_init(DX_CclibRetCode_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("err = 0x%08x\n", err);
+
+	switch (err) {
+	case DX_CCLIB_RET_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_CCLIB_RET_ENOTSUP:
+		PROV_DMSG("res = SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	case DX_CCLIB_RET_ENOPERM:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate  CRYS API RSA error into SS provider error.
+ *
+ * param[in]	err		- CRYS API RSA error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_rsa(CRYSError_t err)
+{
+	SSError_t  res;
+
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case (CRYSError_t)CRYS_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_FAIL:
+	case CRYS_FATAL_ERROR:
+	case CRYS_OUT_OF_RESOURCE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_RSA_BASE_OAEP_DECODE_PARAMETER_STRING_TOO_LONG:
+	case CRYS_RSA_BASE_OAEP_ENCODE_MESSAGE_TOO_LONG:
+		PROV_DMSG("res = SS_ERROR_SHORT_BUFFER\n");
+		res = SS_ERROR_SHORT_BUFFER;
+		break;
+	case CRYS_RSA_KEY_GEN_CONDITIONAL_TEST_FAIL_ERROR:
+	case CRYS_RSA_CAN_NOT_GENERATE_RAND_IN_RANGE:
+	case CRYS_RSA_FIPS_MODE_FAIL_ERROR:
+	case CRYS_RSA_FIPS_MODE_SF_NOT_PERFORMED_ERROR:
+	case CRYS_RSA_INVALID_INPUT_BUFFER_SIZE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate  CRYS API DH error into SS provider error.
+ *
+ * param[in]	err		- CRYS API DH error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_dh(CRYSError_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case (CRYSError_t)CRYS_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_FAIL:
+	case CRYS_FATAL_ERROR:
+	case CRYS_OUT_OF_RESOURCE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_DH_IS_NOT_SUPPORTED:
+		PROV_DMSG("res = SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate  CRYS API AES error into SS provider error.
+ *
+ * param[in]	err		- CRYS API AES error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_aes(CRYSError_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case (CRYSError_t)CRYS_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_FAIL:
+	case CRYS_FATAL_ERROR:
+	case CRYS_OUT_OF_RESOURCE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_AES_DECRYPT_MODE_NOT_ALLOWED_ON_CTR_MODE:
+	case CRYS_AES_XTS_IS_NOT_SUPPORTED_ON_HW_ERROR:
+	case CRYS_AES_DECRYPTION_NOT_ALLOWED_ON_THIS_MODE:
+	case CRYS_AES_NOT_ALLOWED_KEY_TYPE_ON_THIS_MODE:
+	case CRYS_AES_ILLEGAL_SECRET_KEY_MODE:
+	case CRYS_AES_ADDITIONAL_BLOCK_NOT_PERMITTED_ERROR:
+	case CRYS_AES_XTS_IS_NOT_SUPPORTED_ERROR:
+	case CRYS_AES_IS_NOT_SUPPORTED:
+		PROV_DMSG("res = SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate  CRYS DES DES error into SS provider error.
+ *
+ * param[in]	err		- CRYS API DES error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_des(CRYSError_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case (CRYSError_t)CRYS_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_FAIL:
+	case CRYS_FATAL_ERROR:
+	case CRYS_OUT_OF_RESOURCE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_DES_IS_NOT_SUPPORTED:
+		PROV_DMSG("res = SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate  CRYS API HASH error into SS provider error.
+ *
+ * param[in]	err		- CRYS API HASH error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_hash(CRYSError_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case (CRYSError_t)CRYS_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_FAIL:
+	case CRYS_FATAL_ERROR:
+	case CRYS_OUT_OF_RESOURCE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_HASH_LAST_BLOCK_ALREADY_PROCESSED_ERROR:
+		PROV_DMSG("res = SS_ERROR_BAD_STATE\n");
+		res = SS_ERROR_BAD_STATE;
+		break;
+	case CRYS_HASH_IS_NOT_SUPPORTED:
+		PROV_DMSG("res = SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate  CRYS API HMAC error into SS provider error.
+ *
+ * param[in]	err		- CRYS API HMAC error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_hmac(CRYSError_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case (CRYSError_t)CRYS_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_FAIL:
+	case CRYS_FATAL_ERROR:
+	case CRYS_OUT_OF_RESOURCE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_HMAC_LAST_BLOCK_ALREADY_PROCESSED_ERROR:
+		PROV_DMSG("res = SS_ERROR_BAD_STATE\n");
+		res = SS_ERROR_BAD_STATE;
+		break;
+	case CRYS_HMAC_IS_NOT_SUPPORTED:
+		PROV_DMSG("res = SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate  CRYS API AESCCM error into SS provider error.
+ *
+ * param[in]	err		- CRYS API AESCCM error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_ccm(CRYSError_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case (CRYSError_t)CRYS_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_FAIL:
+	case CRYS_FATAL_ERROR:
+	case CRYS_OUT_OF_RESOURCE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_AESCCM_NOT_ALL_ADATA_WAS_PROCESSED_ERROR:
+	case CRYS_AESCCM_NOT_ALL_DATA_WAS_PROCESSED_ERROR:
+	case CRYS_AESCCM_ADATA_WAS_PROCESSED_ERROR:
+		PROV_DMSG("res = SS_ERROR_BAD_STATE\n");
+		res = SS_ERROR_BAD_STATE;
+		break;
+	case CRYS_AESCCM_ILLEGAL_DMA_BUFF_TYPE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_AESCCM_ADDITIONAL_BLOCK_NOT_PERMITTED_ERROR:
+	case CRYS_AESCCM_IS_NOT_SUPPORTED:
+		PROV_DMSG("res = SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	case CRYS_AESCCM_CCM_MAC_INVALID_ERROR:
+		res = SS_ERROR_MAC_INVALID;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate  CRYS API RND error into SS provider error.
+ *
+ * param[in]	err		- CRYS API RND error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_rnd(CRYSError_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case (CRYSError_t)CRYS_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_FAIL:
+	case CRYS_FATAL_ERROR:
+	case CRYS_OUT_OF_RESOURCE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_RND_INSTANTIATION_NOT_DONE_ERROR:
+	case CRYS_RND_TRNG_TIME_EXCEED_ERROR:
+	case CRYS_RND_TRNG_LOSS_SAMPLES_AND_TIME_EXCEED_ERROR:
+		PROV_DMSG("res = SS_ERROR_BAD_STATE\n");
+		res = SS_ERROR_BAD_STATE;
+		break;
+	case CRYS_RND_IS_KAT_MODE_ERROR:
+	case CRYS_RND_GEN_A_ERROR:
+	case CRYS_RND_GEN_B_ERROR:
+	case CRYS_RND_GEN_C_ERROR:
+	case CRYS_RND_ILLEGAL_AES_KEY_SIZE_ERROR:
+	case CRYS_RND_TRNG_ERRORS_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_RND_IS_NOT_SUPPORTED:
+		PROV_DMSG("res = SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Translate  CRYS API ECC error into SS provider error.
+ *
+ * param[in]	err		- CRYS API ECC error code
+ * return	TEE_Result
+ */
+SSError_t ss_translate_error_crys2ss_ecc(CRYSError_t err)
+{
+	SSError_t res;
+
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case (CRYSError_t)CRYS_OK:
+		PROV_DMSG("res = SS_SUCCESS\n");
+		res = SS_SUCCESS;
+		break;
+	case DX_FAIL:
+	case CRYS_FATAL_ERROR:
+	case CRYS_OUT_OF_RESOURCE_ERROR:
+		PROV_DMSG("res = SS_ERROR_GENERIC\n");
+		res = SS_ERROR_GENERIC;
+		break;
+	case CRYS_ECPKI_GEN_KEY_THIS_D0MAIN_IS_NOT_SUPPORTED_ERROR:
+	case CRYS_ECPKI_IS_NOT_SUPPORTED:
+		PROV_DMSG("res = SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	default:
+		PROV_DMSG("res = SS_ERROR_BAD_PARAMETERS\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	PROV_OUTMSG("return res = 0x%08x\n", res);
+	return res;
+}
+
+
+/*
+ * brief:	Translate  CRYS API RND error into SS provider error.
+ *
+ * param[in]	err		- CRYS API Util error code
+ * return	TEE_Result
+ */
+static SSError_t ss_translate_error_crys2ss_util(DxUTILError_t err)
+{
+	SSError_t res;
+	PROV_INMSG("CRYSError_t = 0x%08x\n", err);
+
+	switch ((ulong32)err) {
+	case DX_UTIL_OK:
+		res = SS_SUCCESS;
+		break;
+	case DX_UTIL_INVALID_KEY_TYPE:
+	case DX_UTIL_DATA_IN_POINTER_INVALID_ERROR:
+	case DX_UTIL_DATA_IN_SIZE_INVALID_ERROR:
+	case DX_UTIL_DATA_OUT_POINTER_INVALID_ERROR:
+	case DX_UTIL_DATA_OUT_SIZE_INVALID_ERROR:
+	case DX_UTIL_ILLEGAL_PARAMS_ERROR:
+	case DX_UTIL_BAD_ADDR_ERROR:
+	case DX_UTIL_EK_DOMAIN_INVALID_ERROR:
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	case DX_UTIL_FATAL_ERROR:
+	case DX_UTIL_KDR_INVALID_ERROR:
+	case DX_UTIL_LCS_INVALID_ERROR:
+	default:
+		res = SS_ERROR_GENERIC;
+		break;
+	}
+	return res;
+}
+
+static SSError_t ss_buffer_update(void *ctx, uint32_t algo,
+		const uint8_t *srcData, uint32_t srcLen, uint8_t **dstData)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t *crysRes;
+	ss_crys_algo crysAlgo;
+	SS_AES_Context_t *aesCtx;
+	SS_DES_Context_t *desCtx;
+	SS_HASH_Context_t *hashCtx;
+	SS_HMAC_Context_t *hmacCtx;
+	SS_AESCCM_Context_t *ccmCtx;
+	void * context;
+	uint8_t *restBuffer;
+	uint32_t *restBufferSize;
+	uint32_t updateBlockSize;
+	uint32_t copySize;
+	uint32_t maxDataInSize = MAX_DATAIN_SIZE;
+	uint8_t *srcUpdateData = (uint8_t *)srcData;
+
+	static CRYSError_t (*ss_update[5])(void *ctx, uint8_t *dataIn_ptr,
+			uint32_t dataInSize, uint8_t *dataOut_ptr,
+			CRYSError_t *crysRes) = {
+				[SS_ALG_AES] = &ss_crys_aes_update,
+				[SS_ALG_DES] = &ss_crys_des_update,
+				[SS_ALG_HASH] = &ss_crys_hash_update,
+				[SS_ALG_HMAC] = &ss_crys_hmac_update,
+				[SS_ALG_AESCCM] = &ss_crys_aesccm_update
+	};
+
+	PROV_INMSG("ctx=%p algo=%d srcData=%p srcLen=%d dstData=%p", ctx, algo,
+			srcData, srcLen, dstData);
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_AES)
+#if defined(CFG_CRYPTO_CBC_MAC)
+	case TEE_ALG_AES_CBC_MAC_NOPAD:
+	case TEE_ALG_AES_CBC_MAC_PKCS5:
+#endif
+#if defined(CFG_CRYPTO_CMAC)
+	case TEE_ALG_AES_CMAC:
+#endif
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_AES_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_AES_CBC_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CTR)
+	case TEE_ALG_AES_CTR:
+#endif
+#if defined(CFG_CRYPTO_CTS)
+	case TEE_ALG_AES_CTS:
+#endif
+#if defined(CFG_CRYPTO_XTS)
+	case TEE_ALG_AES_XTS:
+#endif
+		PROV_DMSG("algo=AES (no CCM)\n");
+		crysAlgo = SS_ALG_AES;
+		aesCtx = (SS_AES_Context_t *)ctx;
+		context = (void *)&aesCtx->crys_ctx;
+		crysRes = &aesCtx->crys_error;
+		restBuffer = aesCtx->restBuf;
+		restBufferSize = &aesCtx->restBufSize;
+		updateBlockSize = aesCtx->blockSize;
+		break;
+#if defined(CFG_CRYPTO_CCM)
+	case TEE_ALG_AES_CCM:
+		PROV_DMSG("algo=AES CCM\n");
+		crysAlgo = SS_ALG_AESCCM;
+		ccmCtx = (SS_AESCCM_Context_t *)ctx;
+		context = (void *)&ccmCtx->crys_ctx;
+		crysRes = &ccmCtx->crys_error;
+		restBuffer = ccmCtx->restBuf;
+		restBufferSize = &ccmCtx->restBufSize;
+		updateBlockSize = ccmCtx->blockSize;
+		maxDataInSize = MAX_DATAIN_CCM_SIZE;
+		break;
+#endif
+#endif
+#if defined(CFG_CRYPTO_DES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_DES_ECB_NOPAD:
+	case TEE_ALG_DES3_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_DES_CBC_NOPAD:
+	case TEE_ALG_DES3_CBC_NOPAD:
+#endif
+		PROV_DMSG("algo=DES\n");
+		crysAlgo = SS_ALG_DES;
+		desCtx = (SS_DES_Context_t *)ctx;
+		context = (void *)&desCtx->crys_ctx;
+		crysRes = &desCtx->crys_error;
+		restBuffer = desCtx->restBuf;
+		restBufferSize = &desCtx->restBufSize;
+		updateBlockSize = desCtx->blockSize;
+		break;
+#endif
+#if defined(_CFG_CRYPTO_WITH_HASH)
+#if defined(CFG_CRYPTO_MD5)
+	case TEE_ALG_MD5:
+#endif
+#if defined(CFG_CRYPTO_SHA1)
+	case TEE_ALG_SHA1:
+#endif
+#if defined(CFG_CRYPTO_SHA224)
+	case TEE_ALG_SHA224:
+#endif
+#if defined(CFG_CRYPTO_SHA256)
+	case TEE_ALG_SHA256:
+#endif
+#if defined(CFG_CRYPTO_SHA384)
+	case TEE_ALG_SHA384:
+#endif
+#if defined(CFG_CRYPTO_SHA512)
+	case TEE_ALG_SHA512:
+		PROV_DMSG("algo=HASH\n");
+		crysAlgo = SS_ALG_HASH;
+		hashCtx = (SS_HASH_Context_t *)ctx;
+		context = (void *)&hashCtx->crys_ctx;
+		crysRes = &hashCtx->crys_error;
+		restBuffer = hashCtx->restBuf;
+		restBufferSize = &hashCtx->restBufSize;
+		updateBlockSize = hashCtx->blockSize;
+		break;
+#endif
+#endif
+#if defined(CFG_CRYPTO_HMAC)
+#if defined(CFG_CRYPTO_MD5)
+	case TEE_ALG_HMAC_MD5:
+#endif
+#if defined(CFG_CRYPTO_SHA1)
+	case TEE_ALG_HMAC_SHA1:
+#endif
+#if defined(CFG_CRYPTO_SHA224)
+	case TEE_ALG_HMAC_SHA224:
+#endif
+#if defined(CFG_CRYPTO_SHA256)
+	case TEE_ALG_HMAC_SHA256:
+#endif
+#if defined(CFG_CRYPTO_SHA384)
+	case TEE_ALG_HMAC_SHA384:
+#endif
+#if defined(CFG_CRYPTO_SHA512)
+	case TEE_ALG_HMAC_SHA512:
+#endif
+		PROV_DMSG("algo=HMAC\n");
+		crysAlgo = SS_ALG_HMAC;
+		hmacCtx = (SS_HMAC_Context_t *)ctx;
+		context = (void *)&hmacCtx->crys_ctx;
+		crysRes = &hmacCtx->crys_error;
+		restBuffer = hmacCtx->restBuf;
+		restBufferSize = &hmacCtx->restBufSize;
+		updateBlockSize = hmacCtx->blockSize;
+		break;
+#endif
+	default:
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	if (res == SS_SUCCESS) {
+		if (((*restBufferSize + srcLen) > updateBlockSize)
+				&& (*restBufferSize != 0U)) {
+			/* There is not yet input data in context. */
+			copySize = updateBlockSize - *restBufferSize;
+			(void)memcpy(restBuffer + *restBufferSize,
+					srcUpdateData, copySize);
+			PROV_DMSG("CALL CRYS Update [algo=%d]\n", crysAlgo);
+			PROV_DMSG("context=%p restBuffer=%p\n", context,
+					restBuffer);
+			PROV_DMSG("updateBlockSize=%d dstData=%p\n",
+					updateBlockSize, *dstData);
+			res = ss_update[crysAlgo](context, restBuffer,
+					updateBlockSize, *dstData, crysRes);
+			PROV_DMSG("Result : 0x%08x\n", res);
+			*restBufferSize = 0U;
+			srcUpdateData += copySize;
+			srcLen -= copySize;
+			if (*dstData != NULL) {
+				*dstData += updateBlockSize;
+			}
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		/* There is not yet input data in srcData. */
+		while (srcLen >= updateBlockSize) {
+			copySize = MIN(ROUNDDOWN(srcLen, updateBlockSize),
+					maxDataInSize);
+			PROV_DMSG("CALL CRYS Update [algo=%d]\n", crysAlgo);
+			PROV_DMSG("context=%p restBuffer=%p\n", context,
+					restBuffer);
+			PROV_DMSG("updateBlockSize=%d dstData=%p\n",
+					updateBlockSize, *dstData);
+			res = ss_update[crysAlgo](context, srcUpdateData,
+					copySize, *dstData, crysRes);
+			PROV_DMSG("Result : 0x%08x\n", res);
+			if (res != SS_SUCCESS) {
+				break;
+			}
+			srcUpdateData += copySize;
+			srcLen -= copySize;
+			if (*dstData != NULL) {
+				*dstData += copySize;
+			}
+		}
+		/* Rest data exists ? */
+		if ((res == SS_SUCCESS) && (srcLen > 0U)) {
+			PROV_DMSG("%d byte data can't input to CRYS API.\n",
+					srcLen);
+			(void)memcpy((restBuffer + *restBufferSize),
+					srcUpdateData, srcLen);
+			*restBufferSize += srcLen;
+			PROV_DMSG("restBufferSize%d.\n", *restBufferSize);
+		}
+	}
+
+	PROV_OUTMSG("Return : 0x%08x\n", res);
+	return res;
+}
+
+/******************************************************************************
+ * Message digest functions
+ ******************************************************************************/
+
+/*
+ * brief:	Get context size to HASH algorithm.
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*size		- Size of context to HASH algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+#ifdef _CFG_CRYPTO_WITH_HASH
+static TEE_Result hash_get_ctx_size(uint32_t algo, size_t *size)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+
+	PROV_INMSG("algo=%d, *size=%p\n",algo,size);
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_MD5)
+	case TEE_ALG_MD5:
+#endif
+#if defined(CFG_CRYPTO_SHA1)
+	case TEE_ALG_SHA1:
+#endif
+#if defined(CFG_CRYPTO_SHA224)
+	case TEE_ALG_SHA224:
+#endif
+#if defined(CFG_CRYPTO_SHA256)
+	case TEE_ALG_SHA256:
+#endif
+#if defined(CFG_CRYPTO_SHA384)
+	case TEE_ALG_SHA384:
+#endif
+#if defined(CFG_CRYPTO_SHA512)
+	case TEE_ALG_SHA512:
+#endif
+		PROV_DMSG("size = sizeof(SS_HASH_Context_t)\n");
+		*size = sizeof(SS_HASH_Context_t);
+		break;
+	default:
+		PROV_EMSG("NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+	PROV_DMSG("size=%ld byte\n",*size);
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+
+/*
+ * brief:	Initialize state of HASH algorithm.
+ *
+ * param[in]	*ctx		- Context to HASH algorithm.
+ * param[in]	algo		- Cryptographic algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result hash_init(void *ctx, uint32_t algo)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_HASH_Context_t *ss_ctx;
+	CRYS_HASHUserContext_t *contextID_ptr;
+	CRYS_HASH_OperationMode_t hash_mode;
+
+	PROV_INMSG("*ctx=%p, algo=%d\n",ctx,algo);
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_HASH_Context_t *)ctx;
+		(void)memset(ss_ctx,0,sizeof(SS_HASH_Context_t));
+		ss_ctx->crys_error = SS_SUCCESS;
+		ss_ctx->restBufSize = 0U;
+		ss_ctx->blockSize = 64U;
+		contextID_ptr = &ss_ctx->crys_ctx;
+	} else {
+		res = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETERS ctx=%p\n",ctx);
+	}
+	if (res == SS_SUCCESS) {
+		switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_MD5)
+		case TEE_ALG_MD5:
+			PROV_DMSG("algo = TEE_ALG_MD5\n");
+			hash_mode = CRYS_HASH_MD5_mode;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA1)
+		case TEE_ALG_SHA1:
+			PROV_DMSG("algo = TEE_ALG_SHA1\n");
+			hash_mode = CRYS_HASH_SHA1_mode;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA224)
+		case TEE_ALG_SHA224:
+			PROV_DMSG("algo = TEE_ALG_SHA224\n");
+			hash_mode = CRYS_HASH_SHA224_mode;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA256)
+		case TEE_ALG_SHA256:
+			PROV_DMSG("algo = TEE_ALG_SHA256\n");
+			hash_mode = CRYS_HASH_SHA256_mode;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA384)
+		case TEE_ALG_SHA384:
+			PROV_DMSG("algo = TEE_ALG_SHA384\n");
+			hash_mode = CRYS_HASH_SHA384_mode;
+			ss_ctx->blockSize = 128U;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA512)
+		case TEE_ALG_SHA512:
+			PROV_DMSG("algo = TEE_ALG_SHA512\n");
+			hash_mode = CRYS_HASH_SHA512_mode;
+			ss_ctx->blockSize = 128U;
+			break;
+#endif
+		default:
+			PROV_EMSG("NOT_SUPPORTED\n");
+			hash_mode = CRYS_HASH_OperationModeLast;
+			res = SS_ERROR_NOT_SUPPORTED;
+			break;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL:CRYS_HASH_Init(%p,0x%08x)\n",contextID_ptr, hash_mode);
+		crys_res = CRYS_HASH_Init(contextID_ptr, hash_mode);
+		ss_ctx->crys_error = crys_res;
+		res = ss_translate_error_crys2ss_hash(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Block Data Update state of HASH algorithm.
+ *
+ * param[in]	*ctx		- Context to HASH algorithm.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	data		- Pointer to input data buffer.
+ * param[in]	len		- Size of the data to HASH algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result hash_update(void *ctx, uint32_t algo __unused,
+		const uint8_t *data, size_t len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	SS_HASH_Context_t *ss_ctx;
+	uint8_t *nullBuf = NULL;
+
+	PROV_INMSG("*ctx=%p, algo=%d, *data=%p, len=%ld\n", ctx, algo, data,
+			len);
+
+	CHECK_CONTEXT(res, ss_ctx, SS_HASH_Context_t, ctx);
+
+	if(SS_SUCCESS == res){
+		res = ss_buffer_update(ctx, algo, data, len, &nullBuf);
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Finalize state of HASH algorithm.
+ *
+ * param[in]	*ctx		- Context to HASH algorithm.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*digest		- Pointer to the output buffer.
+ * param[out]	len		- Size of the output data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result hash_final(void *ctx, uint32_t algo, uint8_t *digest,
+		size_t len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+
+	SS_HASH_Context_t *ss_ctx;
+	CRYS_HASHUserContext_t *contextID_ptr = NULL;
+	CRYS_HASH_Result_t hashResultBuff;
+
+	PROV_INMSG("*ctx=%p, algo=%d, *digest=%p, len=%ld\n",ctx,algo,digest,len);
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_HASH_Context_t *)ctx;
+		contextID_ptr = &ss_ctx->crys_ctx;
+		if (ss_ctx->crys_error != (SSError_t)CRYS_OK) {
+			res = SS_ERROR_BAD_STATE;
+			PROV_EMSG("BAD_STATE ss_ctx->crys_error=0x%08x\n",ss_ctx->crys_error);
+		}
+	} else {
+		res = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETERS(ctx=%p)\n",ctx);
+	}
+
+	if (res == SS_SUCCESS) {
+		if (NULL == digest) {
+			res = SS_ERROR_BAD_PARAMETERS;
+			PROV_EMSG("BAD_PARAMETERS(digest=%p)\n", digest);
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_MD5)
+		case TEE_ALG_MD5:
+#endif
+#if defined(CFG_CRYPTO_SHA1)
+		case TEE_ALG_SHA1:
+#endif
+#if defined(CFG_CRYPTO_SHA224)
+		case TEE_ALG_SHA224:
+#endif
+#if defined(CFG_CRYPTO_SHA256)
+		case TEE_ALG_SHA256:
+#endif
+#if defined(CFG_CRYPTO_SHA384)
+		case TEE_ALG_SHA384:
+#endif
+#if defined(CFG_CRYPTO_SHA512)
+		case TEE_ALG_SHA512:
+#endif
+			PROV_DMSG("algo = 0x%08x\n");
+			break;
+		default:
+			PROV_EMSG("NOT_SUPPORTED\n");
+			res = SS_ERROR_NOT_SUPPORTED;
+			break;
+		}
+	}
+
+	if ((res == SS_SUCCESS) && (ss_ctx->restBufSize != 0U)) {
+		PROV_DMSG("CALL:  CRYS_HASH_Update(%p,%p,%d)\n",
+				contextID_ptr, ss_ctx->restBuf, ss_ctx->restBufSize);
+		crys_res = CRYS_HASH_Update(contextID_ptr,
+				ss_ctx->restBuf,ss_ctx->restBufSize);
+		ss_ctx->crys_error = crys_res;
+		res = ss_translate_error_crys2ss_hash(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL:  CRYS_HASH_Finish(%p,%p)\n",contextID_ptr, hashResultBuff);
+		crys_res = CRYS_HASH_Finish(contextID_ptr, hashResultBuff);
+		ss_ctx->crys_error = crys_res;
+		res = ss_translate_error_crys2ss_hash(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+		if (res == SS_SUCCESS) {
+			(void)memcpy(digest, hashResultBuff, len);
+		}
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+#endif
+
+/******************************************************************************
+ * Asymmetric algorithms
+ ******************************************************************************/
+#if defined(_CFG_CRYPTO_WITH_ACIPHER)
+#if defined(CFG_CRYPTO_RSA)
+
+/*
+ * brief:	Allocate member struct data of the RSA key pair.
+ *
+ * param[out]	*s		- Pointer to the struct data of RSA key pair.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_alloc_rsa_keypair(struct rsa_keypair *s,
+		size_t key_size_bits __unused)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+	PROV_INMSG("s=%p, key_size_bits=%ld\n",(void*)s,key_size_bits);
+
+	if (NULL == s) {
+		res = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETERS(s=%p)\n", s);
+	} else {
+		s->d = NULL;
+		s->e = NULL;
+		s->n = NULL;
+		s->p = NULL;
+		s->q = NULL;
+		s->dp = NULL;
+		s->dq = NULL;
+		s->qp = NULL;
+		PROV_DMSG("CALL: bn_alloc_max(&s->e)\n");
+		res = bn_alloc_max(&s->e);
+
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL: bn_alloc_max(&s->d)\n");
+			res = bn_alloc_max(&s->d);
+		}
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL: bn_alloc_max(&s->n)\n");
+			res = bn_alloc_max(&s->n);
+		}
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL: bn_alloc_max(&s->p)\n");
+			res = bn_alloc_max(&s->p);
+		}
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL: bn_alloc_max(&s->q)\n");
+			res = bn_alloc_max(&s->q);
+		}
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL: bn_alloc_max(&s->dp)\n");
+			res = bn_alloc_max(&s->dp);
+		}
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL:  bn_alloc_max(&s->dp)\n");
+			res = bn_alloc_max(&s->dq);
+		}
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL: bn_alloc_max(&s->qp)\n");
+			res = bn_alloc_max(&s->qp);
+		}
+		if (res != SS_SUCCESS) {
+			bn_free(s->e);
+			bn_free(s->d);
+			bn_free(s->n);
+			bn_free(s->p);
+			bn_free(s->q);
+			bn_free(s->dp);
+			bn_free(s->dq);
+			bn_free(s->qp);
+			PROV_DMSG("ERROR: OUT_OF_MEMORY\n");
+		}
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Allocate member struct data of the RSA public key.
+ *
+ * param[out]	*s		- Pointer to the struct data of RSA public key.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_alloc_rsa_public_key(struct rsa_public_key *s,
+		size_t key_size_bits __unused)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+
+	PROV_INMSG("s=%p, key_size_bits=%ld\n", (void * )s, key_size_bits);
+	if (NULL == s) {
+		res = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETERS(s=%p)\n", s);
+	} else {
+		s->e = NULL;
+		s->n = NULL;
+		PROV_DMSG("CALL:  bn_alloc_max(&s->e)\n");
+		res = bn_alloc_max(&s->e);
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL:  bn_alloc_max(&s->n)\n");
+			res = bn_alloc_max(&s->n);
+		}
+		if (res != SS_SUCCESS) {
+			bn_free(s->e);
+			bn_free(s->n);
+			PROV_EMSG("Memory allocate failed\n");
+		}
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Free RSA public key.
+ *
+ * param[out]	*s		- Pointer to the struct data of RSA public key.
+ * return	void
+ */
+static void free_rsa_public_key(struct rsa_public_key *s)
+{
+	if (NULL == s) {
+		PROV_EMSG("BAD_PARAMETERS(s=%p)\n", s);
+	} else {
+		PROV_DMSG("FREE RSA public key\n");
+		bn_free(s->n);
+		bn_free(s->e);
+	}
+}
+
+/*
+ * brief:	Generate RSA key pair.
+ *
+ * param[out]	*key		- Pointer to the struct data of RSA key pair.
+ * param[in]	key_sizse	- Size of RSA key pair.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_gen_rsa_key(struct rsa_keypair *key, size_t key_size)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	int32_t mpa_res;
+	uint8_t *pubExp_ptr = NULL;
+	uint16_t pubExpSizeInBytes = 0U;
+	CRYS_RSAUserPrivKey_t *pCcUserPrivKey = NULL;
+	CRYS_RSAUserPubKey_t *pCcUserPubKey = NULL;
+	CRYS_RSAKGData_t *keyGenData = NULL;
+	CRYSRSAPrivKey_t *pCcPrivKey = NULL;
+	CRYSRSAPubKey_t *pCcPublKey;
+	CRYS_RSAConvertKeyToCrtBuffers_t *crt_buffer = NULL;
+	void *tmp1 = NULL;
+	void *tmp2 = NULL;
+
+	PROV_INMSG("*key=%p, key_size=%ld\n",key,key_size);
+	NULL_CHECK_RSA_PUBLIC_KEY(key,res);
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_copy_bn2bin_uint16(%p,%p,%d)\n", key->e,
+				&pubExp_ptr, pubExpSizeInBytes);
+		res = ss_copy_bn2bin_uint16(key->e, &pubExp_ptr,
+				&pubExpSizeInBytes);
+		PROV_DMSG("Result: res=0x%08x\n", res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_malloc(%ld,0x%08x)\n",sizeof(CRYS_RSAUserPrivKey_t), res);
+		pCcUserPrivKey = (CRYS_RSAUserPrivKey_t *)ss_malloc(
+				sizeof(CRYS_RSAUserPrivKey_t), &res);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_malloc(%ld,0x%08x)\n",sizeof(CRYS_RSAUserPrivKey_t), res);
+		pCcUserPubKey = (CRYS_RSAUserPubKey_t *)ss_malloc(
+				sizeof(CRYS_RSAUserPubKey_t), &res);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_malloc(%ld,0x%08x)\n",sizeof(CRYS_RSAUserPrivKey_t), res);
+		keyGenData = (CRYS_RSAKGData_t *)ss_malloc(
+				sizeof(CRYS_RSAKGData_t), &res);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_malloc(%ld,0x%08x)\n",sizeof(CRYS_RSAUserPrivKey_t), res);
+		crt_buffer = (CRYS_RSAConvertKeyToCrtBuffers_t *)ss_malloc(
+				sizeof(CRYS_RSAConvertKeyToCrtBuffers_t), &res);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: CRYS_RSA_KG_GenerateKeyPairCRT() pubExp_ptr=%p pubExpSizeInBytes=0x%08x\n",
+				(void *)pubExp_ptr, pubExpSizeInBytes);
+		PROV_DMSG("key_size=%ld, pCcUserPrivKey=%p, pCcUserPubKey=%p, keyGenData=%p\n",
+				 key_size, pCcUserPrivKey, pCcUserPubKey, keyGenData);
+		crys_res = CRYS_RSA_KG_GenerateKeyPairCRT(pubExp_ptr,
+				pubExpSizeInBytes, key_size, pCcUserPrivKey,
+				pCcUserPubKey, keyGenData);
+		res = ss_translate_error_crys2ss_rsa(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+	if (res == SS_SUCCESS) {
+		pCcPrivKey = (CRYSRSAPrivKey_t *)pCcUserPrivKey->PrivateKeyDbBuff;
+		pCcPublKey = (CRYSRSAPubKey_t *)pCcUserPubKey->PublicKeyDbBuff;
+		PROV_DMSG("CALL: ss_bn_bin2bn(key->e)\n");
+		res = ss_bn_bin2bn((uint8_t *)pCcPublKey->e,
+			(ROUNDUP(pCcPublKey->eSizeInBits, 8U) / 8U), key->e);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_bn_bin2bn(key->n)\n");
+		res = ss_bn_bin2bn((uint8_t *)pCcPrivKey->n,
+			(ROUNDUP(pCcPrivKey->nSizeInBits, 8U) / 8U), key->n);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_bn_bin2bn(key->p)\n");
+		res = ss_bn_bin2bn((uint8_t *)pCcPrivKey->PriveKeyDb.Crt.P,
+			(ROUNDUP(pCcPrivKey->PriveKeyDb.Crt.PSizeInBits, 8U) / 8U),
+				key->p);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_bn_bin2bn(key->q)\n");
+		res = ss_bn_bin2bn((uint8_t *)pCcPrivKey->PriveKeyDb.Crt.Q,
+			(ROUNDUP(pCcPrivKey->PriveKeyDb.Crt.QSizeInBits, 8U) / 8U),
+				key->q);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_bn_bin2bn(key->qp)\n");
+		res = ss_bn_bin2bn((uint8_t *)pCcPrivKey->PriveKeyDb.Crt.qInv,
+			(ROUNDUP(pCcPrivKey->PriveKeyDb.Crt.qInvSizeInBits, 8U) / 8U),
+				key->qp);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_bn_bin2bn(key->dp)\n");
+		res = ss_bn_bin2bn((uint8_t *)pCcPrivKey->PriveKeyDb.Crt.dP,
+			(ROUNDUP(pCcPrivKey->PriveKeyDb.Crt.dPSizeInBits, 8U) / 8U),
+				key->dp);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_bn_bin2bn(key->dq)\n");
+		res = ss_bn_bin2bn((uint8_t *)pCcPrivKey->PriveKeyDb.Crt.dQ,
+			(ROUNDUP(pCcPrivKey->PriveKeyDb.Crt.dQSizeInBits, 8U) / 8U),
+				key->dq);
+		PROV_DMSG("Result: res=0x%08x\n",res);
+	}
+	/* Calculation private exponents (key->d) */
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: bn_alloc_max(&tmp1)\n");
+		if(CRYPT_OK != mp_init_multi(&tmp1,&tmp2,NULL)){
+			res = SS_ERROR_OUT_OF_MEMORY;
+			PROV_DMSG("Result: res=0x%08x\n",res);
+		}
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: mp_sub_d(%p,1,%p)\n",key->p,tmp1);
+		mpa_res = mp_sub_d(key->p, 1U, tmp2);
+		PROV_DMSG("Result: mpa_res=0x%08x\n",mpa_res);
+
+		if (mpa_res == CRYPT_OK) {
+			PROV_DMSG("CALL: mp_sub_d(%p,1,%p)\n",key->q,tmp2);
+			mpa_res = mp_sub_d(key->q, 1U, tmp1);
+			PROV_DMSG("Result: mpa_res=0x%08x\n",mpa_res);
+		}
+		if (mpa_res == CRYPT_OK) {
+			PROV_DMSG("CALL: mp_mul(%p,%p,%p)\n",tmp1,tmp2,tmp1);
+			mpa_res = mp_lcm(tmp1, tmp2, tmp1);
+			PROV_DMSG("Result: mpa_res=0x%08x\n",mpa_res);
+		}
+		if (mpa_res == CRYPT_OK) {
+			PROV_DMSG("CALL: mp_mul(%p,%p,%p)\n",key->e, tmp1, key->d);
+			mpa_res = mp_invmod(key->e, tmp1, key->d);
+			PROV_DMSG("Result: mpa_res=0x%08x\n",mpa_res);
+		}
+		if (mpa_res != CRYPT_OK) {
+			res = SS_ERROR_GENERIC;
+			PROV_DMSG("Calc [key->d] failed res=0x%08x\n",res);
+		}
+	}
+
+	mp_clear_multi(tmp1,tmp2,NULL);
+	ss_free((void*)pubExp_ptr);
+	ss_free((void*)pCcUserPrivKey);
+	ss_free((void*)pCcUserPubKey);
+	ss_free((void*)keyGenData);
+	ss_free((void*)crt_buffer);
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Build RSA private key.
+ *
+ * param[out]	**userPrivKey	- RSA private key of Sansa format.
+ * param[in]	*key		- RSA private key of TEE internal API format.
+ * return	SSError_t	- SS provider error code.
+ */
+static SSError_t ss_build_priv_key(CRYS_RSAUserPrivKey_t **userPrivKey,
+		struct rsa_keypair *key)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_RSAUserPrivKey_t *privKey_ptr = NULL;
+	uint8_t *e_ptr = NULL;
+	uint16_t eSize = 0U;
+	uint8_t *d_ptr = NULL;
+	uint16_t dSize = 0U;
+	uint8_t *n_ptr = NULL;
+	uint16_t nSize = 0U;
+	uint8_t *dp_ptr = NULL;
+	uint16_t dpSize = 0U;
+	uint8_t *p_ptr = NULL;
+	uint16_t pSize = 0U;
+	uint8_t *q_ptr = NULL;
+	uint16_t qSize = 0U;
+	uint8_t *dq_ptr = NULL;
+	uint16_t dqSize = 0U;
+	uint8_t *qInv_ptr = NULL;
+	uint16_t qInvSize = 0U;
+
+	PROV_INMSG("**userPrivKey=%p, key=%p\n",*userPrivKey,key);
+	NULL_CHECK_RSA_KEYPAIR(key,res);
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_malloc(CRYS_RSAUserPrivKey_t)\n");
+		privKey_ptr = (CRYS_RSAUserPrivKey_t *)ss_malloc(
+				sizeof(CRYS_RSAUserPrivKey_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		if (bn_num_bytes(key->p) == 0U) {
+			PROV_DMSG("key->e=%p\n", key->e);
+			res = ss_copy_bn2bin_uint16(key->e, &e_ptr, &eSize);
+			if (res == SS_SUCCESS) {
+				PROV_DMSG("key->d=%p\n", key->d);
+				res = ss_copy_bn2bin_uint16(key->d, &d_ptr,
+						&dSize);
+			}
+			if (res == SS_SUCCESS) {
+				PROV_DMSG("key->n=%p\n", key->n);
+				res = ss_copy_bn2bin_uint16(key->n, &n_ptr,
+						&nSize);
+			}
+			if (res == SS_SUCCESS) {
+				PROV_DMSG("CALL: CRYS_RSA_Build_PrivKey()\n");
+				PROV_DMSG("privKey_ptr=%p\n", privKey_ptr);
+				PROV_DMSG("d_ptr=%p dSize=%d\n", d_ptr, dSize);
+				PROV_DMSG("e_ptr=%p eSize=%d\n", e_ptr, eSize);
+				PROV_DMSG("n_ptr=%p nSize=%d\n", n_ptr, nSize);
+				crys_res = CRYS_RSA_Build_PrivKey(privKey_ptr,
+						d_ptr, dSize, e_ptr, eSize,
+						n_ptr, nSize);
+				res = ss_translate_error_crys2ss_rsa(crys_res);
+				PROV_DMSG("crys_res=0x%08x -> res=0x%08x\n",
+						crys_res, res);
+			}
+		} else {
+			PROV_DMSG("key->p=%p\n", key->p);
+			res = ss_copy_bn2bin_uint16(key->p, &p_ptr, &pSize);
+			if (res == SS_SUCCESS) {
+				PROV_DMSG("key->q=%p\n", key->q);
+				res = ss_copy_bn2bin_uint16(key->q, &q_ptr,
+						&qSize);
+			}
+			if (res == SS_SUCCESS) {
+				PROV_DMSG("key->dp=%p\n", key->dp);
+				res = ss_copy_bn2bin_uint16(key->dp, &dp_ptr,
+						&dpSize);
+			}
+			if (res == SS_SUCCESS) {
+				PROV_DMSG("key->dq=%p\n", key->dq);
+				res = ss_copy_bn2bin_uint16(key->dq, &dq_ptr,
+						&dqSize);
+			}
+			if (res == SS_SUCCESS) {
+				PROV_DMSG("key->qp=%p\n", key->qp);
+				res = ss_copy_bn2bin_uint16(key->qp, &qInv_ptr,
+						&qInvSize);
+			}
+			if (res == SS_SUCCESS) {
+				PROV_DMSG("CRYS_RSA_Build_PrivKeyCRT()\n");
+				PROV_DMSG("privKey_ptr=%p\n", privKey_ptr);
+				PROV_DMSG("p_ptr=%p pSize=%d\n", p_ptr, pSize);
+				PROV_DMSG("q_ptr=%p qSize=%d\n", q_ptr, qSize);
+				PROV_DMSG("dp_ptr=%p nSize=%d\n", dp_ptr,
+						dqSize);
+				PROV_DMSG("dq_ptr=%p dSize=%d\n", dp_ptr,
+						dqSize);
+				PROV_DMSG("qInv_ptr=%p qInvSize=%d\n", e_ptr,
+						eSize);
+				crys_res = CRYS_RSA_Build_PrivKeyCRT(
+						privKey_ptr, p_ptr, pSize,
+						q_ptr, qSize, dp_ptr, dpSize,
+						dq_ptr, dqSize, qInv_ptr,
+						qInvSize);
+				res = ss_translate_error_crys2ss_rsa(crys_res);
+				PROV_DMSG("crys_res=0x%08x -> res=0x%08x\n",
+						crys_res, res);
+			}
+		}
+	}
+	if (res == SS_SUCCESS) {
+		*userPrivKey = privKey_ptr;
+	} else {
+		ss_free((void*)privKey_ptr);
+		PROV_EMSG("ss_build_priv_key\n");
+	}
+
+	ss_free((void*)e_ptr);
+	ss_free((void*)d_ptr);
+	ss_free((void*)n_ptr);
+	ss_free((void*)p_ptr);
+	ss_free((void*)q_ptr);
+	ss_free((void*)dp_ptr);
+	ss_free((void*)dq_ptr);
+	ss_free((void*)qInv_ptr);
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Build RSA public key.
+ *
+ * param[out]	**userPubKey	- Double pointer to RSA public key of Sansa format.
+ * param[in]	*key		- Pointer to RSA private key of TEE internal API format.
+ * return	SSError_t	- SS provider error code.
+ */
+static SSError_t ss_build_pub_key(CRYS_RSAUserPubKey_t **userPubKey,
+		struct rsa_public_key *key)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_RSAUserPubKey_t *pubKey_ptr = NULL;
+	uint8_t *modulus_ptr = NULL;
+	uint8_t *exponent_ptr = NULL;
+	uint16_t modulusSize = 0U;
+	uint16_t exponentSize = 0U;
+
+	PROV_INMSG("**userPubKey=%p, *key=%p\n",*userPubKey,key);
+	NULL_CHECK_RSA_PUBLIC_KEY(key,res);
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_malloc(CRYS_RSAUserPubKey_t)\n");
+		pubKey_ptr = (CRYS_RSAUserPubKey_t *)ss_malloc(
+				sizeof(CRYS_RSAUserPubKey_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin_uint16(key->e,&exponent_ptr,&exponentSize);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin_uint16(key->n,&modulus_ptr,&modulusSize);
+	}
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: CRYS_RSA_Build_PubKey()\n");
+		((mpanum)key->n)->d[bn_num_bytes(key->n)-1U] |= 0x1U;
+		crys_res = CRYS_RSA_Build_PubKey(pubKey_ptr,
+				exponent_ptr,
+				exponentSize,
+				modulus_ptr,
+				modulusSize);
+		res = ss_translate_error_crys2ss_rsa(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+	if (res == SS_SUCCESS) {
+		*userPubKey = pubKey_ptr;
+	} else {
+		ss_free((void*)pubKey_ptr);
+		PROV_EMSG("ss_build_publ_key\n");
+	}
+
+	ss_free(exponent_ptr);
+	ss_free(modulus_ptr);
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Encryption by the RSA primitive (PKCS #1)
+ *
+ * param[in]	*key		- Pointer to the struct data of RSA key pair.
+ * param[in]	*src		- Pointer to the source data.
+ * param[in]	src_len		- Size of source data.
+ * param[out]	*dst		- Pointer to the destination of the encrypt data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_rsanopad_encrypt(struct rsa_public_key *key,
+		const uint8_t *src, size_t src_len, uint8_t *dst,
+		size_t *dst_len __unused)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_RSAUserPubKey_t *userPubKey_ptr = NULL;
+	CRYS_RSAPrimeData_t * primeData_ptr = NULL;
+	uint8_t *data_ptr = NULL;
+	uint16_t data_len = 0U;
+	uint8_t *in_ptr = NULL;
+	uint8_t *out_ptr = NULL;
+	size_t in_len;
+	size_t out_len = 0U;
+	size_t offset =0U;
+
+	PROV_INMSG("*key=%p, *src=%p, src_len=%ld, *dst=%p, *dst_len=%p\n",key,src,src_len,dst,dst_len);
+
+	in_len = bn_num_bytes(key->n);
+
+	if(src_len > in_len) {
+		res = SS_ERROR_BAD_PARAMETERS;
+	} else if (src_len == in_len) {
+		data_ptr = (uint8_t *)src;
+		data_len = (uint16_t)src_len;
+	} else {
+		in_ptr = (uint8_t *)ss_calloc(1U, in_len, &res);
+		if(res == SS_SUCCESS){
+			(void)memcpy(in_ptr, src, src_len);
+		}
+		data_ptr = in_ptr;
+		data_len = (uint16_t)src_len;
+	}
+
+	if (res == SS_SUCCESS) {
+		out_len = in_len;
+		out_ptr = (uint8_t *)ss_calloc(1U,out_len, &res);
+	}
+
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_malloc(CRYS_RSAPrimeData_t)\n");
+		primeData_ptr = (CRYS_RSAPrimeData_t *)ss_malloc(
+				sizeof(CRYS_RSAPrimeData_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_build_pub_key()\n");
+		res = ss_build_pub_key(&userPubKey_ptr, key);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: CRYS_RSA_PRIM_Encrypt()\n");
+		crys_res = CRYS_RSA_PRIM_Encrypt(userPubKey_ptr, primeData_ptr,
+				data_ptr, data_len, out_ptr);
+		res = ss_translate_error_crys2ss_rsa(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	/* Remove the zero-padding (leave one zero if buff is all zeroes) */
+	if (res == SS_SUCCESS) {
+		while ((offset < (out_len - 1U)) && (*(out_ptr + offset) == 0U)) {
+			offset++;
+		}
+
+		if (*dst_len < (out_len - offset)) {
+			*dst_len = out_len - offset;
+			res = SS_ERROR_SHORT_BUFFER;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		*dst_len = out_len - offset;
+		(void)memcpy(dst, (uint8_t *)out_ptr + offset, *dst_len);
+	}
+
+	ss_free((void *)in_ptr);
+	ss_free((void *)out_ptr);
+	ss_free((void *)userPubKey_ptr);
+	ss_free((void *)primeData_ptr);
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Decryption by the RSA primitive (PKCS #1)
+ *
+ * param[in]	*key		- Pointer to the struct data of RSA key pair.
+ * param[in]	*src		- Pointer to the source data.
+ * param[in]	src_len		- Size of source data.
+ * param[out]	*dst		- Pointer to the destination of the decrypt data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_rsanopad_decrypt(struct rsa_keypair *key,
+		const uint8_t *src, size_t src_len, uint8_t *dst,
+		size_t *dst_len __unused)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_RSAUserPrivKey_t *userPrivKey_ptr = NULL;
+	CRYS_RSAPrimeData_t * primeData_ptr = NULL;
+	uint8_t *rsaData_ptr;
+	uint16_t rsaDataSize;
+	uint8_t *outBuf;
+	size_t blen;
+	size_t offset =0U;
+
+	PROV_INMSG("*key=%p, *src=%p, src_len=%ld, *dst=%p, *dst_len=%p\n",key,src,src_len,dst,dst_len);
+
+	rsaData_ptr = (uint8_t *) src;
+	rsaDataSize = (uint16_t) src_len;
+
+	blen = src_len;
+	outBuf = (uint8_t *)ss_malloc(blen, &res);
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_malloc(CRYS_RSAPrimeData_t)\n");
+		primeData_ptr = (CRYS_RSAPrimeData_t *)ss_malloc(
+				sizeof(CRYS_RSAPrimeData_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: ss_build_priv_key()\n");
+		res = ss_build_priv_key(&userPrivKey_ptr, key);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: CRYS_RSA_PRIM_Decrypt()\n");
+		crys_res = CRYS_RSA_PRIM_Decrypt(userPrivKey_ptr, primeData_ptr,
+				rsaData_ptr, rsaDataSize, outBuf);
+		res = ss_translate_error_crys2ss_rsa(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	/* Remove the zero-padding (leave one zero if buff is all zeroes) */
+	if (res == SS_SUCCESS) {
+		while ((offset < (blen - 1U)) && (*(outBuf + offset) == 0U)) {
+			offset++;
+		}
+		if (*dst_len < (blen - offset)) {
+			*dst_len = blen - offset;
+			res = SS_ERROR_SHORT_BUFFER;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		*dst_len = blen - offset;
+		(void)memcpy(dst, (uint8_t *)outBuf + offset, *dst_len);
+	}
+
+	ss_free((void *)userPrivKey_ptr);
+	ss_free((void *)primeData_ptr);
+	ss_free((void *)outBuf);
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Decryption by the RSA primitive (PKCS #1)
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*rsa_hashmode	- Pointer to the hash mode of the RSA key.
+ * param[out]	*hashSize	- Pointer to the size of hash data.
+ * param[out]	*mgf		- Pointer to the mask generation functions (MGF).
+ * param[out]	*version	- Pointer to the version of the RSA key.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static SSError_t ss_get_rsa_hash(uint32_t algo,
+		CRYS_RSA_HASH_OpMode_t *rsa_hashmode, size_t *hashSize,
+		CRYS_PKCS1_MGF_t *mgf, CRYS_PKCS1_version *version)
+{
+	SSError_t res = SS_SUCCESS;
+	PROV_INMSG("algo = 0x%08x\n",algo);
+	switch ((int32_t)algo) {
+	case TEE_ALG_RSAES_PKCS1_V1_5:
+		PROV_DMSG("algo=TEE_ALG_RSAES_PKCS1_V1_5");
+		*rsa_hashmode = CRYS_RSA_HASH_NO_HASH_mode;
+		*hashSize = 0U;
+		*mgf = CRYS_PKCS1_NO_MGF;
+		*version = CRYS_PKCS1_VER15;
+		break;
+	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:
+		PROV_DMSG("algo=TEE_ALG_RSASSA_PKCS1_V1_5_SHA1");
+		*rsa_hashmode = CRYS_RSA_After_SHA1_mode;
+		*hashSize = 20U;
+		*mgf = CRYS_PKCS1_NO_MGF;
+		*version = CRYS_PKCS1_VER15;
+		break;
+	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:
+		PROV_DMSG("algo=TEE_ALG_RSASSA_PKCS1_V1_5_SHA224");
+		*rsa_hashmode = CRYS_RSA_After_SHA224_mode;
+		*hashSize = 28U;
+		*mgf = CRYS_PKCS1_NO_MGF;
+		*version = CRYS_PKCS1_VER15;
+		break;
+	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:
+		PROV_DMSG("algo=TEE_ALG_RSASSA_PKCS1_V1_5_SHA256");
+		*rsa_hashmode = CRYS_RSA_After_SHA256_mode;
+		*hashSize = 32U;
+		*mgf = CRYS_PKCS1_NO_MGF;
+		*version = CRYS_PKCS1_VER15;
+		break;
+	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:
+		PROV_DMSG("algo=TEE_ALG_RSASSA_PKCS1_V1_5_SHA384");
+		*rsa_hashmode = CRYS_RSA_After_SHA384_mode;
+		*hashSize = 48U;
+		*mgf = CRYS_PKCS1_NO_MGF;
+		*version = CRYS_PKCS1_VER15;
+		break;
+	case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:
+		PROV_DMSG("algo=TEE_ALG_RSASSA_PKCS1_V1_5_SHA512");
+		*rsa_hashmode = CRYS_RSA_After_SHA512_mode;
+		*mgf = CRYS_PKCS1_NO_MGF;
+		*hashSize = 64U;
+		*version = CRYS_PKCS1_VER15;
+		break;
+	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:
+		PROV_DMSG("algo=TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1");
+		*rsa_hashmode = CRYS_RSA_After_SHA1_mode;
+		*hashSize = 20U;
+		*mgf = CRYS_PKCS1_MGF1;
+		*version = CRYS_PKCS1_VER21;
+		break;
+	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:
+		PROV_DMSG("algo=TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224");
+		*rsa_hashmode = CRYS_RSA_After_SHA224_mode;
+		*hashSize = 28U;
+		*mgf = CRYS_PKCS1_MGF1;
+		*version = CRYS_PKCS1_VER21;
+		break;
+	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:
+		PROV_DMSG("algo=TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256");
+		*rsa_hashmode = CRYS_RSA_After_SHA256_mode;
+		*hashSize = 32U;
+		*mgf = CRYS_PKCS1_MGF1;
+		*version = CRYS_PKCS1_VER21;
+		break;
+	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:
+		PROV_DMSG("algo=TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384");
+		*rsa_hashmode = CRYS_RSA_After_SHA384_mode;
+		*hashSize = 48U;
+		*mgf = CRYS_PKCS1_MGF1;
+		*version = CRYS_PKCS1_VER21;
+		break;
+	case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:
+	case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:
+		PROV_DMSG("algo=TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512");
+		*rsa_hashmode = CRYS_RSA_After_SHA512_mode;
+		*hashSize = 64U;
+		*mgf = CRYS_PKCS1_MGF1;
+		*version = CRYS_PKCS1_VER21;
+		break;
+	default:
+		PROV_EMSG("NOT_SUPPORTED\n");
+		*rsa_hashmode = CRYS_RSA_HASH_OpModeLast;
+		*hashSize = 0U;
+		*mgf = CRYS_PKCS1_MGFLast;
+		*version = CRYS_PKCS1_versionLast;
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+	PROV_DMSG("*rsa_hashmode=0x%08x, *hashSize=0x%08lx,*mgf=0x%08x,*version=0x%08x\n",
+			*rsa_hashmode, *hashSize,*mgf,*version);
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Encryption by the RSA (PKCS1 v1.5, OAEP) FIPS 180-4 (SHA-1, SHA-2)
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*key		- Pointer to the struct of the RSA public key.
+ * param[in]	*label		- Pointer to the the label data.
+ * param[in]	label_len	- Size of the label data.
+ * param[in]	*src		- Pointer to the source data buffer.
+ * param[in]	*src_len	- Size of source data buffer.
+ * param[out]	dst		- Pointer to the destination data buffer.
+ * param[out]	*dst_len	- Size of destination data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_rsaes_encrypt(uint32_t algo, struct rsa_public_key *key,
+		const uint8_t *label, size_t label_len, const uint8_t *src,
+		size_t src_len, uint8_t *dst, size_t *dst_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_RSAUserPubKey_t *userPubKey_ptr = NULL;
+	CRYS_RSAPrimeData_t *primeData_ptr = NULL;
+	CRYS_RSA_HASH_OpMode_t hashFunc;
+	CRYS_PKCS1_MGF_t mgf;
+	uint8_t *l;
+	uint16_t llen;
+	uint8_t *dataIn_ptr;
+	uint16_t dataInSize;
+	uint8_t *output_ptr;
+	CRYS_PKCS1_version version;
+	size_t modulas_size;
+	size_t hashSize;
+
+	PROV_INMSG("algo=%d, *key=%p, *label=%p, label_len=%ld\n",algo,key,label,label_len);
+	PROV_INMSG("*src=%p, src_len=%ld, *dst=%p, dst_len=%p\n",src,src_len,dst,dst_len);
+
+
+	PROV_DMSG("Input key->e\n");
+	PROV_DHEXDUMP(key->e,bn_num_bytes(key->e));
+	PROV_DMSG("Input key->n\n");
+	PROV_DHEXDUMP(key->n,bn_num_bytes(key->n));
+	PROV_DMSG("Input label\n");
+	PROV_DHEXDUMP(label,label_len);
+	PROV_DMSG("Input src  src_len=%ld\n",src_len);
+	PROV_DHEXDUMP(src,src_len);
+
+	output_ptr = dst;
+	l = (uint8_t *)label;
+	llen = (uint16_t)label_len;
+	dataIn_ptr = (uint8_t *)src;
+	dataInSize = (uint16_t)src_len;
+
+	NULL_CHECK_RSA_PUBLIC_KEY(key,res);
+	if (res == SS_SUCCESS) {
+		modulas_size = bn_num_bytes(key->n);
+		if (NULL == dst_len) {
+			res = SS_ERROR_BAD_PARAMETERS;
+			PROV_EMSG("BAD_PARAMETERS(key=%p)\n", key);
+		} else {
+			if (*dst_len < modulas_size) {
+				res = SS_ERROR_SHORT_BUFFER;
+			}
+			*dst_len = modulas_size;
+			PROV_DMSG("dst_len=%ld\n",*dst_len);
+		}
+	}
+	if (res == SS_SUCCESS) {
+		primeData_ptr = (CRYS_RSAPrimeData_t *)ss_malloc(
+				sizeof(CRYS_RSAPrimeData_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_build_pub_key(&userPubKey_ptr, key);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_get_rsa_hash((const uint32_t)algo, &hashFunc,
+				&hashSize, &mgf, &version);
+	}
+	if (res == SS_SUCCESS) {
+		if (version == CRYS_PKCS1_VER15) {
+			PROV_DMSG("CALL:  CRYS_RSA_PKCS1v15_Encrypt()\n");
+			crys_res = CRYS_RSA_PKCS1v15_Encrypt(userPubKey_ptr,
+					primeData_ptr, dataIn_ptr, dataInSize,
+					output_ptr);
+		} else {
+			CONV_HASHMODE_TO_OAEP(hashFunc);
+			PROV_DMSG("CALL:  CRYS_RSA_OAEP_Encrypt()\n");
+			crys_res = CRYS_RSA_OAEP_Encrypt(userPubKey_ptr,
+					primeData_ptr, hashFunc, l, llen, mgf,
+					dataIn_ptr, dataInSize, output_ptr);
+		}
+		res = ss_translate_error_crys2ss_rsa(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	ss_free((void *)userPubKey_ptr);
+	ss_free((void *)primeData_ptr);
+	PROV_DHEXDUMP(dst,*dst_len);
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+
+/*
+ * brief:	Decryption by the RSA (PKCS1 v1.5, OAEP) FIPS 180-4 (SHA-1, SHA-2)
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*key		- Pointer to the struct of the RSA key pair.
+ * param[in]	*label		- Pointer to the the label data.
+ * param[in]	label_len	- Size of the label data.
+ * param[in]	*src		- Pointer to the source data buffer.
+ * param[in]	*src_len	- Size of source data buffer.
+ * param[out]	dst		- Pointer to the destination data buffer.
+ * param[out]	*dst_len	- Size of destination data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_rsaes_decrypt(uint32_t algo, struct rsa_keypair *key,
+		const uint8_t *label, size_t label_len, const uint8_t *src,
+		size_t src_len, uint8_t *dst, size_t *dst_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+
+	/* CRYS_*_Decrypt */
+	CRYS_RSAUserPrivKey_t *userPrivKey_ptr = NULL;
+	CRYS_RSAPrimeData_t *primeData_ptr = NULL;
+	CRYS_RSA_HASH_OpMode_t rsa_hashMode;
+	CRYS_PKCS1_MGF_t mgf;
+	CRYS_PKCS1_version version;
+	uint8_t *l;
+	uint16_t llen = 0U;
+	uint16_t dataInSize = 0U;
+	uint16_t outputSize;
+	uint8_t *dataIn_ptr;
+	uint8_t *output_ptr;
+	size_t modulas_size;
+	size_t hashSize;
+
+	PROV_INMSG("algo=%d, *key=%p, *label=%p, label_len=%ld\n",algo,key,label,label_len);
+	PROV_INMSG("*src=%p, src_len=%ld, *dst=%p, *dst_len=%p\n",src,src_len,dst,dst_len);
+
+	PROV_DMSG("Input key->e\n");
+	PROV_DHEXDUMP(key->e,bn_num_bytes(key->e));
+	PROV_DMSG("Input key->d\n");
+	PROV_DHEXDUMP(key->d,bn_num_bytes(key->d));
+	PROV_DMSG("Input key->n\n");
+	PROV_DHEXDUMP(key->n,bn_num_bytes(key->n));
+	PROV_DMSG("Input key->p\n");
+	PROV_DHEXDUMP(key->p,bn_num_bytes(key->p));
+	PROV_DMSG("Input key->q\n");
+	PROV_DHEXDUMP(key->q,bn_num_bytes(key->q));
+	PROV_DMSG("Input key->qp\n");
+	PROV_DHEXDUMP(key->qp,bn_num_bytes(key->qp));
+	PROV_DMSG("Input key->dp\n");
+	PROV_DHEXDUMP(key->dp,bn_num_bytes(key->dp));
+	PROV_DMSG("Input key->dq\n");
+	PROV_DHEXDUMP(key->dq,bn_num_bytes(key->dq));
+	PROV_DMSG("Input label\n");
+	PROV_DHEXDUMP(label,label_len);
+	PROV_DMSG("Input src  src_len=%ld\n",src_len);
+	PROV_DHEXDUMP(src,src_len);
+
+	l = (uint8_t *)label;
+	dataIn_ptr = (uint8_t *)src;
+	output_ptr = (uint8_t *)dst;
+
+	NULL_CHECK_RSA_KEYPAIR(key,res);
+	if (res == SS_SUCCESS){
+		modulas_size = bn_num_bytes(key->n);
+		if (src_len < 0xFFFFU) {
+			dataInSize = (uint16_t)src_len;
+		} else {
+			res = SS_ERROR_OVERFLOW;
+			PROV_EMSG("OVERFLOW(src_len)\n");
+		}
+	}
+	if (res == SS_SUCCESS){
+		if(dst_len == NULL){
+			res = SS_ERROR_BAD_PARAMETERS;
+			PROV_EMSG("BAD_PARAMETERS(dst_len=%p)\n", key);
+		} else {
+			if (*dst_len < 0xFFFFU) {
+				outputSize = (uint16_t)*dst_len;
+			} else {
+				outputSize = 0xFFFFU;
+			}
+		}
+	}
+	if (res == SS_SUCCESS) {
+		if (label_len < 0xFFFFU) {
+			llen = (uint16_t)label_len;
+		} else {
+			res = SS_ERROR_OVERFLOW;
+			PROV_EMSG("OVERFLOW(label_len)\n");
+		}
+	}
+	if (res == SS_SUCCESS) {
+		primeData_ptr = (CRYS_RSAPrimeData_t *)ss_malloc(
+				sizeof(CRYS_RSAPrimeData_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_build_priv_key(&userPrivKey_ptr, key);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_get_rsa_hash((const uint32_t)algo, &rsa_hashMode,
+				&hashSize, &mgf, &version);
+	}
+	if (res == SS_SUCCESS) {
+		if (version == CRYS_PKCS1_VER15) {
+			if (outputSize >= (modulas_size - 11U)) {
+				PROV_DMSG("CALL: CRYS_RSA_PKCS1v15_Decrypt()\n");
+				crys_res = CRYS_RSA_PKCS1v15_Decrypt(
+						userPrivKey_ptr, primeData_ptr,
+						dataIn_ptr, dataInSize,
+						output_ptr, &outputSize);
+				res = ss_translate_error_crys2ss_rsa(crys_res);
+				PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+			} else {
+				*dst_len = modulas_size;
+				res = SS_ERROR_SHORT_BUFFER;
+				PROV_EMSG("SHORT_BUFFER(PKCS)\n");
+			}
+		} else {
+			if (outputSize >= (modulas_size - (2U * hashSize) - 2U)) {
+				CONV_HASHMODE_TO_OAEP(rsa_hashMode);
+				PROV_DMSG("CALL: CRYS_RSA_OAEP_Decrypt()\n");
+				crys_res = CRYS_RSA_OAEP_Decrypt(
+						userPrivKey_ptr, primeData_ptr,
+						rsa_hashMode, l, llen, mgf,
+						dataIn_ptr, dataInSize,
+						output_ptr, &outputSize);
+				res = ss_translate_error_crys2ss_rsa(crys_res);
+				PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+			} else {
+				*dst_len = modulas_size;
+				res = SS_ERROR_SHORT_BUFFER;
+				PROV_EMSG("SHORT_BUFFER(OAEP)\n");
+			}
+		}
+
+	}
+	if (res == SS_SUCCESS) {
+		*dst_len = (size_t)outputSize;
+		PROV_DMSG("Output dst   dst_len=%ld\n",*dst_len);
+	}
+
+	ss_free((void *)userPrivKey_ptr);
+	ss_free((void *)primeData_ptr);
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_DHEXDUMP(dst,*dst_len);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Sign by the RSA (PKCS1 v1.5, PSS) FIPS 180-4 (SHA-1, SHA-2)
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*key		- Pointer to the struct of the RSA key pair.
+ * param[in]	*salt_len	- Pointer to the the salt data.
+ * param[in]	*msg		- Pointer to the message data buffer.
+ * param[in]	msg_len		- Size of message data buffer.
+ * param[out]	*sig		- Pointer to the signature data buffer.
+ * param[out]	*sig_len	- Size of signature data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_rsassa_sign(uint32_t algo, struct rsa_keypair *key,
+		int salt_len, const uint8_t *msg, size_t msg_len, uint8_t *sig,
+		size_t *sig_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_RSAPrivUserContext_t *userContext_ptr = NULL;
+	CRYS_RSAUserPrivKey_t *userPrivKey_ptr = NULL;
+	CRYS_RSA_HASH_OpMode_t rsaHashMode;
+	CRYS_PKCS1_MGF_t mgf;
+	uint16_t saltLen = 0U;
+	uint8_t *dataIn_ptr;
+	uint32_t dataInSize = 0U;
+	uint8_t *output_ptr;
+	uint16_t outputSize;
+	CRYS_PKCS1_version version;
+	size_t modulas_size;
+	size_t hashSize;
+
+	PROV_INMSG("algo=%d, *key=%p, salt_len=%d, *msg=%p",algo,key,salt_len, msg);
+	PROV_INMSG("msg_len=%ld, *sig=%p, sig_len=%p\n",msg_len,sig,sig_len);
+
+	dataIn_ptr = (uint8_t *)msg;
+	output_ptr = (uint8_t *)sig;
+
+	NULL_CHECK_RSA_KEYPAIR(key,res);
+	if (res == SS_SUCCESS) {
+		modulas_size = bn_num_bytes(key->n);
+		if ( NULL == sig_len) {
+			res = SS_ERROR_BAD_PARAMETERS;
+			PROV_EMSG("BAD_PARAMETERS(key=%p)\n", key);
+		} else {
+			if (*sig_len < modulas_size) {
+				res = SS_ERROR_SHORT_BUFFER;
+				PROV_EMSG("SHORT_BUFFER(sig_len=%ld)\n",
+						*sig_len);
+			}
+		}
+		if (res == SS_SUCCESS) {
+			if (*sig_len <= 0xFFFFU) {
+				outputSize = (uint16_t)*sig_len;
+			} else {
+				outputSize = 0xFFFFU;
+			}
+		}
+	}
+	if (res == SS_SUCCESS) {
+		if (salt_len < 0xFFFF) {
+			saltLen = (uint16_t)salt_len;
+		} else {
+			res = SS_ERROR_OVERFLOW;
+			PROV_EMSG("OVERFLOW(salt_len)\n");
+		}
+	}
+	if (res == SS_SUCCESS) {
+		if (msg_len < 0xFFFFU) {
+			dataInSize = (uint16_t)msg_len;
+		} else {
+			res = SS_ERROR_OVERFLOW;
+			PROV_EMSG("OVERFLOW(msg_len)\n");
+		}
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_build_priv_key(&userPrivKey_ptr, key);
+	}
+	if (res == SS_SUCCESS) {
+		userContext_ptr = (CRYS_RSAPrivUserContext_t *)ss_malloc(
+				sizeof(CRYS_RSAPrivUserContext_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_get_rsa_hash((const uint32_t)algo, &rsaHashMode,
+				&hashSize, &mgf, &version);
+	}
+	if (res == SS_SUCCESS) {
+		if (version == CRYS_PKCS1_VER15) {
+			PROV_DMSG("CALL:  CRYS_RSA_PKCS1v15_Sign()\n");
+			crys_res = CRYS_RSA_PKCS1v15_Sign(userContext_ptr,
+					userPrivKey_ptr, rsaHashMode,
+					dataIn_ptr, dataInSize, output_ptr,
+					&outputSize);
+		} else {
+			PROV_DMSG("CALL:  CRYS_RSA_PSS_Sign()\n");
+			crys_res = CRYS_RSA_PSS_Sign(userContext_ptr,
+					userPrivKey_ptr, rsaHashMode, mgf,
+					saltLen, dataIn_ptr, dataInSize,
+					output_ptr, &outputSize);
+		}
+		res = ss_translate_error_crys2ss_rsa(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	if (res == SS_SUCCESS) {
+		*sig_len = (size_t)outputSize;
+		PROV_DMSG("sig=%p, *sig_len=%ld\n",sig,*sig_len);
+	}
+
+	ss_free((void *)userContext_ptr);
+	ss_free((void *)userPrivKey_ptr);
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Verify by the RSA (PKCS1 v1.5, PSS) FIPS 180-4 (SHA-1, SHA-2)
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*key		- Pointer to the struct of the RSA key pair.
+ * param[in]	*salt_len	- Pointer to the the salt data.
+ * param[in]	*msg		- Pointer to the message data buffer.
+ * param[in]	msg_len		- Size of message data buffer.
+ * param[in]	*sig		- Pointer to the signature data buffer.
+ * param[in]	*sig_len	- Size of signature data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_rsassa_verify(uint32_t algo, struct rsa_public_key *key,
+		int salt_len, const uint8_t *msg, size_t msg_len,
+		const uint8_t *sig, size_t sig_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+
+	CRYS_RSAPubUserContext_t *userContext_ptr = NULL;
+	CRYS_RSAUserPubKey_t *userPubKey_ptr = NULL;
+	CRYS_RSA_HASH_OpMode_t rsaHashMode;
+	CRYS_PKCS1_MGF_t mgf;
+	uint16_t saltLen = 0U;
+	uint8_t *dataIn_ptr;
+	uint32_t dataInSize = 0U;
+	uint8_t *sig_ptr;
+	CRYS_PKCS1_version version;
+	size_t modulas_size;
+	size_t hashSize;
+
+	PROV_INMSG("algo=%d, *key=%p, salt_len=%d, *msg=%p",algo,key,salt_len, msg);
+	PROV_INMSG("msg_len=%ld, *sig=%p, sig_len=%ld\n",msg_len,sig,sig_len);
+
+	dataIn_ptr = (uint8_t *)msg;
+	sig_ptr = (uint8_t *)sig;
+	NULL_CHECK_RSA_PUBLIC_KEY(key,res);
+	if (res == SS_SUCCESS) {
+		modulas_size = bn_num_bytes(key->n);
+		if (sig_len <= 0xFFFFU) {
+			if (sig_len != modulas_size) {
+				res = SS_ERROR_SHORT_BUFFER;
+				PROV_EMSG("SHORT_BUFFER(sig_len)\n");
+			}
+		} else {
+			res = SS_ERROR_OVERFLOW;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		if (salt_len < 0xFFFF) {
+			saltLen = (uint16_t)salt_len;
+		} else {
+			res = SS_ERROR_OVERFLOW;
+			PROV_EMSG("OVERFLOW(salt_len)\n");
+		}
+	}
+	if (res == SS_SUCCESS) {
+		if (msg_len < 0xFFFFU) {
+			dataInSize = (uint16_t)msg_len;
+		} else {
+			res = SS_ERROR_OVERFLOW;
+			PROV_EMSG("OVERFLOW(msg_len)\n");
+		}
+	}
+	if (res == SS_SUCCESS) {
+		userContext_ptr = (CRYS_RSAPubUserContext_t *)ss_malloc(
+				sizeof(CRYS_RSAPubUserContext_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_build_pub_key(&userPubKey_ptr, key);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_get_rsa_hash((const uint32_t)algo, &rsaHashMode,
+				&hashSize, &mgf, &version);
+	}
+	if (res == SS_SUCCESS) {
+		if (version == CRYS_PKCS1_VER15) {
+			PROV_DMSG("CALL:  CRYS_RSA_PKCS1v15_Verify()\n");
+			crys_res = CRYS_RSA_PKCS1v15_Verify(userContext_ptr,
+					userPubKey_ptr, rsaHashMode, dataIn_ptr,
+					dataInSize, sig_ptr);
+		} else {
+			PROV_DMSG("CALL:  CRYS_RSA_PSS_Verify()\n");
+			crys_res = CRYS_RSA_PSS_Verify(userContext_ptr,
+					userPubKey_ptr, rsaHashMode, mgf,
+					saltLen, dataIn_ptr, dataInSize,
+					sig_ptr);
+		}
+		res = ss_translate_error_crys2ss_rsa(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	ss_free((void *)userContext_ptr);
+	ss_free((void *)userPubKey_ptr);
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+#endif /* CFG_CRYPTO_RSA */
+
+#if defined(CFG_CRYPTO_DSA)
+
+/*
+ * brief:	Sansa does not support DSA
+ *
+ * return	TEE_Result	- Always return (TEE_ERROR_NOT_SUPPORTED).
+ */
+static TEE_Result do_alloc_dsa_keypair(struct dsa_keypair *s __unused,
+		size_t key_size_bits __unused)
+{
+	TEE_Result tee_res;
+	PROV_INMSG("START: All argument unused.\n");
+	tee_res = ss_translate_error_ss2tee(SS_ERROR_NOT_SUPPORTED);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",SS_ERROR_NOT_SUPPORTED,tee_res);
+	return tee_res;
+
+}
+
+/*
+ * brief:	Sansa does not support DSA
+ *
+ * return	TEE_Result	- Always return (TEE_ERROR_NOT_SUPPORTED).
+ */
+static TEE_Result do_alloc_dsa_public_key(struct dsa_public_key *s __unused,
+		size_t key_size_bits __unused)
+{
+	TEE_Result tee_res;
+	PROV_INMSG("START: do_alloc_dsa_public_key\n");
+	tee_res = ss_translate_error_ss2tee(SS_ERROR_NOT_SUPPORTED);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",SS_ERROR_NOT_SUPPORTED,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Sansa does not support DSA
+ *
+ * return	TEE_Result	- Always return (TEE_ERROR_NOT_SUPPORTED).
+ */
+static TEE_Result do_gen_dsa_key(struct dsa_keypair *key __unused,
+		size_t key_size __unused)
+{
+	TEE_Result tee_res;
+	PROV_INMSG("START: do_gen_dsa_key\n");
+	tee_res = ss_translate_error_ss2tee(SS_ERROR_NOT_SUPPORTED);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",SS_ERROR_NOT_SUPPORTED,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Sansa does not support DSA
+ *
+ * return	TEE_Result	- Always return (TEE_ERROR_NOT_SUPPORTED).
+ */
+static TEE_Result do_dsa_sign(uint32_t algo __unused,
+		struct dsa_keypair *key __unused, const uint8_t *msg __unused,
+		size_t msg_len __unused, uint8_t *sig __unused,
+		size_t *sig_len __unused)
+{
+	TEE_Result tee_res;
+	PROV_INMSG("START: do_dsa_sign\n");
+	tee_res = ss_translate_error_ss2tee(SS_ERROR_NOT_SUPPORTED);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",SS_ERROR_NOT_SUPPORTED,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Sansa does not support DSA
+ *
+ * return	TEE_Result	- Always return (TEE_SUCCESS).
+ */
+static TEE_Result do_dsa_verify(uint32_t algo __unused,
+		struct dsa_public_key *key __unused,
+		const uint8_t *msg __unused, size_t msg_len __unused,
+		const uint8_t *sig __unused, size_t sig_len __unused)
+{
+	TEE_Result tee_res;
+	PROV_INMSG("START: do_dsa_verify\n");
+	tee_res = ss_translate_error_ss2tee(SS_ERROR_NOT_SUPPORTED);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",SS_ERROR_NOT_SUPPORTED,tee_res);
+	return tee_res;
+}
+
+#endif /* CFG_CRYPTO_DSA */
+
+#if defined(CFG_CRYPTO_DH)
+/*
+ * brief:	Allocate member struct data of the DH key pair.
+ *
+ * param[in]	*s		- Pointer to the struct data of DH key pair.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_alloc_dh_keypair(struct dh_keypair *s,
+		size_t key_size_bits __unused)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+	PROV_INMSG("*s=%p\n",s);
+
+	if (NULL == s) {
+		res = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETERS(s=%p)\n", s);
+	} else {
+		s->g = NULL;
+		s->p = NULL;
+		s->q = NULL;
+		s->x = NULL;
+		s->y = NULL;
+		s->xbits = 0U;
+		res = bn_alloc_max(&s->g);
+
+		if (res == SS_SUCCESS) {
+			res = bn_alloc_max(&s->p);
+		}
+		if (res == SS_SUCCESS) {
+			res = bn_alloc_max(&s->x);
+		}
+		if (res == SS_SUCCESS) {
+			res = bn_alloc_max(&s->y);
+		}
+		if (res == SS_SUCCESS) {
+			res = bn_alloc_max(&s->q);
+		}
+		if (res != SS_SUCCESS) {
+			bn_free(s->g);
+			bn_free(s->p);
+			bn_free(s->x);
+			bn_free(s->y);
+			bn_free(s->q);
+			PROV_EMSG("Allocate Memory Failed\n");
+		}
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Generate DH key pair.
+ *
+ * param[in/out] *key		- Pointer to the struct data of DH key pair.
+ * param[in]	 *q		- Pointer to the bignum data of q(SUBPRIME).
+ * param[in]	 *xbits		- Pointer to the bignum data of x bits.
+ * return	 TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_gen_dh_key(struct dh_keypair *key, struct bignum *q,
+		size_t xbits)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	uint32_t modulusSize;
+	uint8_t *generator_ptr = NULL;
+	uint16_t generatorSize;
+	uint8_t *prime_ptr = NULL;
+	uint16_t primeSize;
+	uint16_t l;
+	uint8_t *q_ptr = NULL;
+	uint16_t qSize;
+	CRYS_DHUserPubKey_t *tmpPubKey = NULL;
+	CRYS_DHPrimeData_t *tmpPrimeData = NULL;
+	uint8_t *clientPrvKey_ptr = NULL;
+	uint16_t clientPrvKeySize = 0U;
+	uint8_t *clientPubKey_ptr = NULL;
+	uint16_t clientPubKeySize = 0U;
+
+	PROV_INMSG("*key=%p, *q=%p, xbits=%ld\n",key,q,xbits);
+
+	NULL_CHECK_DH_KEYPAIR(key,res);
+	if (res == SS_SUCCESS) {
+		modulusSize = bn_num_bytes(key->p);
+		if (0xFFFFU < xbits) {
+			res = SS_ERROR_OVERFLOW;
+			PROV_EMSG("OVERFLOW(xbits)\n");
+		} else {
+			l = (uint16_t)xbits;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		tmpPubKey = (CRYS_DHUserPubKey_t *)ss_malloc(
+				sizeof(CRYS_DHUserPubKey_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		tmpPrimeData = (CRYS_DHPrimeData_t *)ss_malloc(
+				sizeof(CRYS_DHPrimeData_t), &res);
+	}
+
+	if (res == SS_SUCCESS) {
+		if (0U != l) {
+			clientPrvKeySize = l / 8U;
+		} else {
+			clientPrvKeySize = (uint16_t)modulusSize;
+		}
+		clientPrvKey_ptr = (uint8_t *)ss_malloc(
+				(uint32_t)clientPrvKeySize, &res);
+	}
+	if (res == SS_SUCCESS) {
+		clientPubKeySize = (uint16_t)modulusSize;
+		clientPubKey_ptr = (uint8_t *)ss_malloc(
+				(uint32_t)clientPubKeySize, &res);
+	}
+	/* convert from bignum to binary */
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin_uint16(key->g, &generator_ptr,
+				&generatorSize);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin_uint16(key->p, &prime_ptr, &primeSize);
+	}
+	if (res == SS_SUCCESS) {
+		if (q == NULL) {
+			PROV_DMSG("CALL: CRYS_DH_PKCS3_GeneratePubPrv()\n");
+			crys_res = CRYS_DH_PKCS3_GeneratePubPrv(
+					generator_ptr, generatorSize,
+					prime_ptr, primeSize, l,
+					tmpPubKey, tmpPrimeData,
+					clientPrvKey_ptr,
+					&clientPrvKeySize,
+					clientPubKey_ptr,
+					&clientPubKeySize);
+			res = ss_translate_error_crys2ss_dh(crys_res);
+			PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+		} else {
+			/* q */
+			res = ss_copy_bn2bin_uint16(q, &q_ptr, &qSize);
+			if (res == SS_SUCCESS) {
+				bn_copy(q, key->q);
+				PROV_DMSG("CALL: CRYS_DH_ANSI_X942_GeneratePubPrv()\n");
+				crys_res = CRYS_DH_ANSI_X942_GeneratePubPrv(
+						generator_ptr, generatorSize,
+						prime_ptr, primeSize, q_ptr,
+						qSize, tmpPubKey, tmpPrimeData,
+						clientPrvKey_ptr,
+						&clientPrvKeySize,
+						clientPubKey_ptr,
+						&clientPubKeySize);
+				res = ss_translate_error_crys2ss_dh(crys_res);
+				PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+
+			}
+		}
+	}
+
+	/* convert bin -> bignum */
+	if (res == SS_SUCCESS) {
+		res = ss_bn_bin2bn(clientPrvKey_ptr, (size_t)clientPrvKeySize,
+				key->x);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_bn_bin2bn(clientPubKey_ptr, (size_t)clientPubKeySize,
+				key->y);
+	}
+
+	ss_free((void *)generator_ptr);
+	ss_free((void *)prime_ptr);
+	ss_free((void *)tmpPrimeData);
+	ss_free((void *)tmpPubKey);
+	ss_free((void *)clientPrvKey_ptr);
+	ss_free((void *)clientPubKey_ptr);
+	ss_free((void *)q_ptr);
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Generate secret key.
+ *
+ * param[in/out] *private_key	- Pointer to the struct data of DH client private key.
+ * param[in]	 *public_key	- Pointer to the bignum data of DH server public key.
+ * param[in]	 *secret	- Pointer to the bignum data of secret key.
+ * return	 TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_dh_shared_secret(struct dh_keypair *private_key,
+		struct bignum *public_key, struct bignum *secret)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	uint8_t *clientPrvKey_ptr = NULL;
+	uint16_t clientPrvKeySize = 0U;
+	uint8_t *serverPubKey_ptr = NULL;
+	uint16_t serverPubKeySize = 0U;
+	uint8_t *prime_ptr = NULL;
+	uint16_t primeSize = 0U;
+	CRYS_DHUserPubKey_t *tmpPubKey = NULL;
+	CRYS_DHPrimeData_t *tmpPrimeData = NULL;
+	uint8_t *secretKey_ptr = NULL;
+	uint16_t secretKeySize;
+
+	PROV_INMSG("*private_key=%p, *public_key=%p, *secret=%p\n",private_key,public_key,secret);
+
+	NULL_CHECK_DH_KEYPAIR(private_key,res);
+	if (res == SS_SUCCESS) {
+		tmpPubKey = (CRYS_DHUserPubKey_t *)ss_malloc(
+				sizeof(CRYS_DHUserPubKey_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		tmpPrimeData = (CRYS_DHPrimeData_t *) ss_malloc(
+				sizeof(CRYS_DHPrimeData_t), &res);
+	}
+
+	/* client private key */
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin_uint16(private_key->x, &clientPrvKey_ptr,
+				&clientPrvKeySize);
+	}
+	/* client public key */
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin_uint16(public_key, &serverPubKey_ptr,
+				&serverPubKeySize);
+	}
+	/* prime */
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin_uint16(private_key->p, &prime_ptr,
+				&primeSize);
+	}
+
+	if (res == SS_SUCCESS) {
+		secretKeySize = primeSize;
+		secretKey_ptr = (uint8_t *)ss_malloc((size_t)secretKeySize, &res);
+	}
+
+
+	if (res == SS_SUCCESS) {
+		secretKeySize = primeSize;
+		PROV_DMSG("CALL: CRYS_DH_GetSecretKey()\n");
+		crys_res = CRYS_DH_GetSecretKey(clientPrvKey_ptr,
+				clientPrvKeySize, serverPubKey_ptr,
+				serverPubKeySize, prime_ptr, primeSize,
+				tmpPubKey, tmpPrimeData, secretKey_ptr,
+				&secretKeySize);
+		res = ss_translate_error_crys2ss_dh(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	if (res == SS_SUCCESS) {
+		res = ss_bn_bin2bn(secretKey_ptr,(size_t)secretKeySize, secret);
+	}
+
+	ss_free((void *)tmpPubKey);
+	ss_free((void *)tmpPrimeData);
+	ss_free((void *)clientPrvKey_ptr);
+	ss_free((void *)serverPubKey_ptr);
+	ss_free((void *)prime_ptr);
+	ss_free((void *)secretKey_ptr);
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+#endif /* CFG_CRYPTO_DH */
+
+#if defined(CFG_CRYPTO_ECC)
+
+/*
+ * brief:	Allocate  struct member's memory block of the ECC key pair.
+ *
+ * param[out]	*s		- Pointer to the struct data of ECC key pair.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_alloc_ecc_keypair(struct ecc_keypair *s,
+		size_t key_size_bits __unused)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+
+	PROV_INMSG("*s=%p\n", s);
+
+	if (NULL == s) {
+		res = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETERS(s=%p)\n", s);
+	} else {
+		s->curve = 0U;
+		s->d = NULL;
+		s->x = NULL;
+		s->y = NULL;
+		PROV_DMSG("CALL: bn_alloc_max(&s->d)\n");
+		res = bn_alloc_max(&s->d);
+
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL: bn_alloc_max(&s->x)\n");
+			res = bn_alloc_max(&s->x);
+		}
+		if (res == SS_SUCCESS) {
+			PROV_DMSG("CALL: bn_alloc_max(&s->y)\n");
+			res = bn_alloc_max(&s->y);
+		}
+		if (res != SS_SUCCESS) {
+			bn_free(s->d);
+			bn_free(s->x);
+			bn_free(s->y);
+			PROV_EMSG("Allocate Memory Failed\n");
+		}
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Allocate  struct member's memory block of the ECC public key.
+ *
+ * param[out]	*s		- Pointer to the struct data of ECC public key.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_alloc_ecc_public_key(struct ecc_public_key *s,
+		size_t key_size_bits __unused)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+
+	PROV_INMSG("*s=%p\n", s);
+
+	if (NULL == s) {
+		res = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETERS(s=%p)\n", s);
+	} else {
+		s->curve = 0U;
+		s->x = NULL;
+		s->y = NULL;
+		PROV_DMSG("CALL: bn_alloc_max(&s->x)\n");
+		res = bn_alloc_max(&s->x);
+		if (res == SS_SUCCESS) {
+			res = bn_alloc_max(&s->y);
+		}
+		if (res != SS_SUCCESS) {
+			bn_free(s->x);
+			bn_free(s->y);
+			PROV_EMSG("Allocate Memory Failed\n");
+		}
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	FREE  ECC public key.
+ *
+ * param[out]	*s		- Pointer to the struct data of ECC public key.
+ * return	void
+ */
+static void free_ecc_public_key(struct ecc_public_key *s)
+{
+	if (NULL == s) {
+		PROV_EMSG("BAD_PARAMETERS(s=%p)\n", s);
+	} else {
+		PROV_DMSG("FREE ECC public key\n");
+		bn_free(s->x);
+		bn_free(s->y);
+	}
+	return;
+}
+
+/*
+ * brief:	Get ECC key size by the domain ID of TEE internal API.
+ *
+ * param[in]	curve			- Domain ID of TEE internal API.
+ * param[out]	*domain_id		- Domain ID of CRYS API.
+ * return	SSError_t		- SS provider error code.
+ */
+static SSError_t ss_get_ecc_keysize(uint32_t curve,
+		CRYS_ECPKI_DomainID_t *domain_id, uint32_t *key_size_bytes)
+{
+	SSError_t res = SS_SUCCESS;
+
+	PROV_INMSG("curve=%d\n", curve);
+
+	switch ((int32_t)curve) {
+	case TEE_ECC_CURVE_NIST_P192:
+		PROV_DMSG("v\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp192r1;
+		*key_size_bytes = 24U;
+		break;
+	case TEE_ECC_CURVE_NIST_P224:
+		PROV_DMSG("curve=TEE_ECC_CURVE_NIST_P224\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp224r1;
+		*key_size_bytes = 28U;
+		break;
+	case TEE_ECC_CURVE_NIST_P256:
+		PROV_DMSG("curve=TEE_ECC_CURVE_NIST_P256\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp256r1;
+		*key_size_bytes = 32U;
+		break;
+	case TEE_ECC_CURVE_NIST_P384:
+		PROV_DMSG("curve=TEE_ECC_CURVE_NIST_P384\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp384r1;
+		*key_size_bytes = 48U;
+		break;
+	case TEE_ECC_CURVE_NIST_P521:
+		PROV_DMSG("curve=TEE_ECC_CURVE_NIST_P521\n");
+		*domain_id = CRYS_ECPKI_DomainID_secp521r1;
+		*key_size_bytes = 66U;
+		break;
+	default:
+		PROV_DMSG("ERROR: NOT SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	PROV_OUTMSG("return res=0x%08x", res);
+	return res;
+}
+
+/*
+ * brief:	Generate ECC key pair.
+ *
+ * param[in/out] *key		- Pointer to the struct data of ECC key pair.
+ * return	 TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_gen_ecc_key(struct ecc_keypair *key)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_ECPKI_DomainID_t domain_id;
+	CRYS_ECPKI_UserPrivKey_t *userpriv_key = NULL;
+	CRYS_ECPKI_UserPublKey_t *userpubl_key = NULL;
+	CRYS_ECPKI_KG_TempData_t *temp_buff = NULL;
+	CRYS_ECPKI_PrivKey_t *privKey_ptr;
+	CRYS_ECPKI_PublKey_t *publKey_ptr = NULL;
+	uint32_t key_size_bytes;
+
+	PROV_INMSG("*key=%p\n",key);
+
+	NULL_CHECK_ECC_KEYPAIR(key,res);
+	if (res == SS_SUCCESS) {
+		userpriv_key = (CRYS_ECPKI_UserPrivKey_t *)ss_malloc(
+				sizeof(CRYS_ECPKI_UserPrivKey_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		userpubl_key = (CRYS_ECPKI_UserPublKey_t *)ss_malloc(
+				sizeof(CRYS_ECPKI_UserPublKey_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		temp_buff = (CRYS_ECPKI_KG_TempData_t *)ss_malloc(
+				sizeof(CRYS_ECPKI_KG_TempData_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_get_ecc_keysize(key->curve, &domain_id, &key_size_bytes);
+	}
+	/* Generate the ECC key */
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL:  CRYS_ECPKI_GenKeyPair()\n");
+		crys_res = CRYS_ECPKI_GenKeyPair(domain_id, userpriv_key,
+				userpubl_key, temp_buff);
+		res = ss_translate_error_crys2ss_ecc(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+	if (res == SS_SUCCESS) {
+		privKey_ptr = (CRYS_ECPKI_PrivKey_t *)userpriv_key->PrivKeyDbBuff;
+		publKey_ptr = (CRYS_ECPKI_PublKey_t *)userpubl_key->PublKeyDbBuff;
+		res = ss_bn_bin2bn((uint8_t *)&privKey_ptr->PrivKey[0], key_size_bytes, key->d);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_bn_bin2bn((uint8_t *)&publKey_ptr->PublKeyX[0], key_size_bytes, key->x);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_bn_bin2bn((uint8_t *)&publKey_ptr->PublKeyY[0], key_size_bytes, key->y);
+	}
+
+	ss_free((void *)userpriv_key);
+	ss_free((void *)userpubl_key);
+	ss_free((void *)temp_buff);
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Sign by the ECC (FIPS 186-4 ANSI X9.62)
+ *
+ * param[in]	*key		- Pointer to the struct of the ECC key pair.
+ * param[in]	*msg		- Pointer to the message data buffer.
+ * param[in]	msg_len		- Size of message data buffer.
+ * param[out]	*sig		- Pointer to the signature data buffer.
+ * param[out]	*sig_len	- Size of signature data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_ecc_sign(uint32_t algo __unused, struct ecc_keypair *key,
+		const uint8_t *msg, size_t msg_len, uint8_t *sig,
+		size_t *sig_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_ECPKI_DomainID_t domain_id;
+	CRYS_ECDSA_SignUserContext_t *signUserContext_ptr = NULL;
+	CRYS_ECPKI_UserPrivKey_t *signerPrivKey_ptr = NULL;
+	uint8_t *privKeySizeIn_ptr = NULL;
+	size_t privKeySizeInBytes;
+	uint8_t *messageDataIn_ptr;
+	uint32_t messageSizeInBytes;
+	uint8_t *signatureOut_ptr;
+	uint32_t *signatureOutSize_ptr;
+	uint32_t modulusbytes;
+
+	PROV_INMSG("algo=%d, *key=%p, *msg=%p\n",algo,key,msg);
+	PROV_INMSG("msg_len=0x%08lx, *sig=%p, *sig_len=0x%08lx\n",msg_len,sig,*sig_len);
+
+	NULL_CHECK_ECC_KEYPAIR(key,res);
+	messageDataIn_ptr = (uint8_t *)msg;
+	messageSizeInBytes = (uint32_t)msg_len;
+	signatureOut_ptr = (uint8_t *)sig;
+	signatureOutSize_ptr = (uint32_t *)sig_len;
+
+	if (res == SS_SUCCESS){
+		signUserContext_ptr = (CRYS_ECDSA_SignUserContext_t *)ss_malloc(
+				sizeof(CRYS_ECDSA_SignUserContext_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		signerPrivKey_ptr = (CRYS_ECPKI_UserPrivKey_t *)ss_malloc(
+				sizeof(CRYS_ECPKI_UserPrivKey_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_get_ecc_keysize(key->curve, &domain_id, &modulusbytes);
+	}
+
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin(key->d, &privKeySizeIn_ptr,
+				&privKeySizeInBytes);
+	}
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL:  CRYS_ECPKI_BuildPrivKey()\n");
+		crys_res = CRYS_ECPKI_BuildPrivKey(domain_id, privKeySizeIn_ptr,
+				(uint32_t)privKeySizeInBytes, signerPrivKey_ptr);
+		PROV_DMSG("Result: crys_res=0x%08x\n", crys_res);
+		if (crys_res == (CRYSError_t) CRYS_OK) {
+			PROV_DMSG("CALL:  CRYS_ECDSA_Sign()\n");
+			crys_res = CRYS_ECDSA_Sign(signUserContext_ptr,
+					signerPrivKey_ptr,
+					CRYS_ECPKI_AFTER_HASH_SHA1_mode,
+					messageDataIn_ptr, messageSizeInBytes,
+					signatureOut_ptr, signatureOutSize_ptr);
+			PROV_DMSG("Result: crys_res=0x%08x\n", crys_res);
+		}
+		res = ss_translate_error_crys2ss_ecc(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	ss_free((void *)signUserContext_ptr);
+	ss_free((void *)privKeySizeIn_ptr);
+	ss_free((void *)signerPrivKey_ptr);
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+
+#ifndef CFG_CRYPT_ENABLE_CEPKA
+/*
+ * brief:	Verify by the ECC using PKA engines (FIPS 186-4 ANSI X9.62)
+ *
+ * param[in]	*key		- Pointer to the struct of the ECC key pair.
+ * param[in]	*msg		- Pointer to the message data buffer.
+ * param[in]	msg_len		- Size of message data buffer.
+ * param[in]	*sig		- Pointer to the signature data buffer.
+ * param[in]	*sig_len	- Size of signature data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static SSError_t ss_ecc_verify_secure(struct ecc_public_key *key,
+		const uint8_t *msg, size_t msg_len, const uint8_t *sig,
+		size_t sig_len)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+
+	CRYS_ECPKI_UserPublKey_t *userPublKey_ptr = NULL;
+	CRYS_ECDSA_VerifyUserContext_t *verifyUserContext_ptr = NULL;
+	CRYS_ECPKI_HASH_OpMode_t eccHashMode = CRYS_ECPKI_AFTER_HASH_SHA1_mode;
+	uint8_t *messageDataIn_ptr;
+	uint32_t messageSizeInBytes;
+	uint8_t *signatureOut_ptr;
+	uint32_t signatureOutSize;
+	CRYS_ECPKI_DomainID_t domain_id;
+	uint8_t *publKeyIn_ptr = NULL;
+	uint32_t publKeySizeInBytes = 0U;
+	size_t publKeySizeXBytes;
+	size_t publKeySizeYBytes;
+	uint8_t *publKeyX_ptr = NULL;
+	uint8_t *publKeyY_ptr = NULL;
+	uint32_t modulusbytes = 0U;
+
+	PROV_INMSG("*key=%p, *msg=%p, msg_len=%ld\n", key, msg, msg_len);
+	PROV_INMSG("*sig=%p, sig_len=%ld\n", sig, sig_len);
+
+	messageDataIn_ptr = (uint8_t *)msg;
+	messageSizeInBytes = (uint32_t)msg_len;
+	signatureOut_ptr = (uint8_t *)sig;
+	signatureOutSize = (uint32_t)sig_len;
+
+	NULL_CHECK_ECC_PUBLIC_KEY(key,res);
+	if( res == SS_SUCCESS){
+		res = ss_get_ecc_keysize(key->curve, &domain_id, &modulusbytes);
+	}
+
+	if (res == SS_SUCCESS) {
+		userPublKey_ptr = (CRYS_ECPKI_UserPublKey_t *)ss_malloc(
+				sizeof(CRYS_ECPKI_UserPublKey_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		verifyUserContext_ptr =
+				(CRYS_ECDSA_VerifyUserContext_t *)ss_malloc(
+						sizeof(CRYS_ECDSA_VerifyUserContext_t),
+						&res);
+	}
+
+	if (res == SS_SUCCESS) {
+		/* malloc public key size */
+		res = ss_copy_bn2bin(key->x, &publKeyX_ptr, &publKeySizeXBytes);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin(key->y, &publKeyY_ptr, &publKeySizeYBytes);
+	}
+	if (res == SS_SUCCESS) {
+		publKeySizeInBytes = sizeof(uint8_t) + (modulusbytes * 2U);
+
+		publKeyIn_ptr = (uint8_t *)ss_calloc(1U, publKeySizeInBytes, &res);
+	}
+	if (res == SS_SUCCESS) {
+		/* build public key */
+		*publKeyIn_ptr = (uint8_t)CRYS_EC_PointUncompressed;
+		(void)memcpy((publKeyIn_ptr + 1U + modulusbytes) - publKeySizeXBytes,
+				publKeyX_ptr, publKeySizeXBytes);
+		(void)memcpy((publKeyIn_ptr + 1U + (modulusbytes * 2U)) - publKeySizeYBytes,
+				publKeyY_ptr, publKeySizeYBytes);
+		PROV_DMSG("CALL:  CRYS_ECDSA_Verify()\n");
+		crys_res = CRYS_ECPKI_BuildPublKey(domain_id, publKeyIn_ptr,
+				publKeySizeInBytes, userPublKey_ptr);
+		res = ss_translate_error_crys2ss_ecc(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n", crys_res,
+				res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL:  CRYS_ECDSA_Verify()\n");
+		crys_res = CRYS_ECDSA_Verify(verifyUserContext_ptr,
+				userPublKey_ptr, eccHashMode, signatureOut_ptr,
+				signatureOutSize, messageDataIn_ptr,
+				messageSizeInBytes);
+		res = ss_translate_error_crys2ss_ecc(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n", crys_res,
+				res);
+	}
+
+	ss_free((void *)publKeyX_ptr);
+	ss_free((void *)publKeyY_ptr);
+	ss_free((void *)publKeyIn_ptr);
+	ss_free((void *)verifyUserContext_ptr);
+	ss_free((void *)userPublKey_ptr);
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+#endif
+
+/*
+ * brief:	Verify by the ECC (FIPS 186-4 ANSI X9.62)
+ *
+ * param[in]	*key		- Pointer to the struct of the ECC key pair.
+ * param[in]	*msg		- Pointer to the message data buffer.
+ * param[in]	msg_len		- Size of message data buffer.
+ * param[in]	*sig		- Pointer to the signature data buffer.
+ * param[in]	*sig_len	- Size of signature data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_ecc_verify(uint32_t algo __unused,
+		struct ecc_public_key *key, const uint8_t *msg, size_t msg_len,
+		const uint8_t *sig, size_t sig_len)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+	PROV_INMSG("*key=%p, *msg=%p, msg_len=%ld\n",key,msg,msg_len);
+	PROV_INMSG("*sig=%p, sig_len=%ld\n",sig,sig_len);
+
+#ifdef CFG_CRYPT_ENABLE_CEPKA
+	PROV_DMSG("USE Crypto Engine PKA\n");
+	res = ss_ecc_verify_pka(key, msg, msg_len, sig, sig_len);
+#else
+	PROV_DMSG("USE Crypto Engine Secure\n");
+	res = ss_ecc_verify_secure(key,msg,msg_len,sig,sig_len);
+#endif
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Generate secret key by the ECC.
+ *
+ * param[in]	*private_key	- Pointer to the struct data of ECC private key.
+ * param[in]	*public_key	- Pointer to the struct data of ECC public key.
+ * param[out]	*secret		- Pointer to the secret key data buffer.
+ * param[out]	*secret_len	- Pointer to the secret key Size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_ecc_shared_secret(struct ecc_keypair *private_key,
+		struct ecc_public_key *public_key, void *secret,
+		unsigned long *secret_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_ECPKI_DomainID_t domain_id;
+	CRYS_ECPKI_UserPrivKey_t *userpriv_key = NULL;
+	CRYS_ECPKI_UserPublKey_t *userpubl_key = NULL;
+	CRYS_ECDH_TempData_t *tempBuff_ptr = NULL;
+	uint8_t *privKeyIn_ptr = NULL;
+	size_t privKeySizeInBytes = 0U;
+	uint8_t *publKeyIn_ptr = NULL;
+	uint32_t publkeysize_bytes = 0U;
+	uint8_t *publKeyX_ptr = NULL;
+	size_t publKeySizeXBytes = 0U;
+	uint8_t *publKeyY_ptr = NULL;
+	size_t publKeySizeYBytes = 0U;
+	uint8_t *sharedSecretValue_ptr;
+	uint32_t *sharedSecrValSize_ptr;
+	uint32_t modulusbytes = 0U;
+
+	PROV_INMSG("*private_key=%p, *public_key=%p\n",private_key,public_key);
+	PROV_INMSG("*secret=%p, *secret_len=%p\n",secret,secret_len);
+
+	sharedSecretValue_ptr = (uint8_t *)secret;
+	sharedSecrValSize_ptr = (uint32_t *)secret_len;
+
+	NULL_CHECK_ECC_KEYPAIR(private_key,res);
+	NULL_CHECK_ECC_PUBLIC_KEY(public_key,res);
+	if (res == SS_SUCCESS) {
+		if (private_key->curve != public_key->curve) {
+			res = SS_ERROR_BAD_PARAMETERS;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		tempBuff_ptr = (CRYS_ECDH_TempData_t *)ss_malloc(
+				sizeof(CRYS_ECDH_TempData_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		userpriv_key = (CRYS_ECPKI_UserPrivKey_t *)ss_malloc(
+				sizeof(CRYS_ECPKI_UserPrivKey_t), &res);
+	}
+	if (res == SS_SUCCESS) {
+		userpubl_key = (CRYS_ECPKI_UserPublKey_t *)ss_malloc(
+				sizeof(CRYS_ECPKI_UserPublKey_t), &res);
+	}
+
+	/* Check the curves are the same */
+	if (res == SS_SUCCESS) {
+		res = ss_get_ecc_keysize(public_key->curve, &domain_id, &modulusbytes);
+	}
+	/* build public key */
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin(public_key->x, &publKeyX_ptr,
+				&publKeySizeXBytes);
+	}
+
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin(public_key->y, &publKeyY_ptr,
+				&publKeySizeYBytes);
+	}
+	if (res == SS_SUCCESS) {
+		publkeysize_bytes = sizeof(uint8_t) + (modulusbytes * 2U);
+		publKeyIn_ptr = (uint8_t *)ss_calloc(1,publkeysize_bytes, &res);
+	}
+	if (res == SS_SUCCESS) {
+		*publKeyIn_ptr = (uint8_t)CRYS_EC_PointUncompressed;
+		(void)memcpy((((publKeyIn_ptr + 1U) + modulusbytes) - publKeySizeXBytes),
+				publKeyX_ptr, publKeySizeXBytes);
+		(void)memcpy(((((publKeyIn_ptr) + 1U) + (modulusbytes * 2U)) - publKeySizeYBytes),
+				publKeyY_ptr, publKeySizeYBytes);
+		PROV_DMSG("CALL:  CRYS_ECPKI_BuildPublKey()\n");
+		crys_res = CRYS_ECPKI_BuildPublKey(domain_id, publKeyIn_ptr,
+				publkeysize_bytes, userpubl_key);
+		res = ss_translate_error_crys2ss_ecc(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+	if (res == SS_SUCCESS) {
+		res = ss_copy_bn2bin(private_key->d, &privKeyIn_ptr,
+				&privKeySizeInBytes);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL:  CRYS_ECPKI_BuildPrivKey()\n");
+		crys_res = CRYS_ECPKI_BuildPrivKey(domain_id, privKeyIn_ptr,
+				privKeySizeInBytes, userpriv_key);
+		PROV_DMSG("Result: crys_res=0x%08x\n", crys_res);
+		if (crys_res == (CRYSError_t) CRYS_OK) {
+			PROV_DMSG("CALL:  CRYS_ECDH_SVDP_DH()\n");
+			crys_res = CRYS_ECDH_SVDP_DH(userpubl_key, userpriv_key,
+					sharedSecretValue_ptr,
+					sharedSecrValSize_ptr, tempBuff_ptr);
+			PROV_DMSG("Result: crys_res=0x%08x\n", crys_res);
+		}
+		res = ss_translate_error_crys2ss_ecc(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	ss_free((void *)tempBuff_ptr);
+	ss_free((void *)userpriv_key);
+	ss_free((void *)userpubl_key);
+	ss_free((void *)publKeyX_ptr);
+	ss_free((void *)publKeyY_ptr);
+	ss_free((void *)publKeyIn_ptr);
+	ss_free((void *)privKeyIn_ptr);
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+#endif /* CFG_CRYPTO_ECC */
+
+#endif /* _CFG_CRYPTO_WITH_ACIPHER */
+
+/******************************************************************************
+ * Symmetric ciphers
+ ******************************************************************************/
+
+#if defined(_CFG_CRYPTO_WITH_CIPHER)
+
+/*
+ * brief:	Get block size to AES,DES algorithm.
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*size		- Size of block to AES,DES algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result cipher_get_block_size(uint32_t algo, size_t *size)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	PROV_INMSG("algo=%d, *size=%p\n",algo,size);
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_AES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_AES_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_AES_CBC_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CTR)
+	case TEE_ALG_AES_CTR:
+#endif
+#if defined(CFG_CRYPTO_CTS)
+	case TEE_ALG_AES_CTS:
+#endif
+#if defined(CFG_CRYPTO_XTS)
+	case TEE_ALG_AES_XTS:
+#endif
+		*size = 16U;
+		break;
+#endif
+#if defined(CFG_CRYPTO_DES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_DES_ECB_NOPAD:
+	case TEE_ALG_DES3_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_DES_CBC_NOPAD:
+	case TEE_ALG_DES3_CBC_NOPAD:
+#endif
+		*size = 8U;
+		break;
+#endif
+	default:
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_DMSG("*size=%ld\n",*size);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+
+/*
+ * brief:	Get context size to AES,DES algorithm.
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*size		- Size of context to AES,DES algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result cipher_get_ctx_size(uint32_t algo, size_t *size)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	PROV_INMSG("START cipher_get_ctx_size\n");
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_AES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_AES_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_AES_CBC_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CTR)
+	case TEE_ALG_AES_CTR:
+#endif
+#if defined(CFG_CRYPTO_CTS)
+	case TEE_ALG_AES_CTS:
+#endif
+#if defined(CFG_CRYPTO_XTS)
+	case TEE_ALG_AES_XTS:
+#endif
+		PROV_DMSG("ctx size = sizeof(SS_AES_Context_t)\n");
+		*size = sizeof(SS_AES_Context_t);
+		break;
+#endif
+#if defined(CFG_CRYPTO_DES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_DES_ECB_NOPAD:
+	case TEE_ALG_DES3_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_DES_CBC_NOPAD:
+	case TEE_ALG_DES3_CBC_NOPAD:
+#endif
+		PROV_DMSG("ctx size = sizeof(SS_DES_Context_t)\n");
+		*size = sizeof(SS_DES_Context_t);
+		break;
+#endif
+	default:
+		PROV_EMSG("ERROR SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Initialize state of AES algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AES contest.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	mode		- Cipher Mode.
+ * param[in]	*key1		- Pinter to the AES key.
+ * param[in]	key1_len	- AES key size.
+ * param[in]	*key2		- Pinter to the AES key(only AES-XST).
+ * param[in]	key2_len	- AES key size(only AES-XST).
+ * param[in]	*iv		- Pointer to the Initialize vector.
+ * param[in]	iv_len		- Initialize vector size.
+ * return	SSError_t	- SS provider error code.
+ */
+static SSError_t ss_aes_init(void *ctx, uint32_t algo, TEE_OperationMode mode,
+		const uint8_t *key1, size_t key1_len, const uint8_t *key2,
+		size_t key2_len, const uint8_t *iv, size_t iv_len)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+
+	SS_AES_Context_t *ss_ctx;
+	CRYS_AESUserContext_t *contextID_ptr;
+	CRYS_AES_IvCounter_t *ivCounter_ptr = NULL;
+	CRYS_AES_Key_t aesKey;
+	CRYS_AES_KeySize_t aesKeySize = CRYS_AES_KeySizeLast;
+	CRYS_AES_EncryptMode_t encDecFlag = CRYS_AES_EncryptModeLast;
+	CRYS_AES_OperationMode_t opeMode = CRYS_AES_OperationModeLast;
+
+	PROV_INMSG("START ss_aes_init\n");
+
+	if ( ctx != NULL) {
+		ss_ctx = (SS_AES_Context_t *)ctx;
+		ss_ctx->crys_error = SS_SUCCESS;
+		ss_ctx->blockSize = 16U;
+		ss_ctx->restBufSize = 0U;
+		ss_ctx->mode = mode;
+		contextID_ptr = &ss_ctx->crys_ctx;
+		(void)memset(contextID_ptr, 0, sizeof(CRYS_AESUserContext_t));
+	} else {
+		PROV_DMSG("ERROR:BAD_PARAMETERS(ctx)\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		if (iv == NULL) {
+			PROV_DMSG("iv = NULL\n");
+			ivCounter_ptr = NULL;
+		} else {
+			PROV_DMSG("iv = NOT NULL\n");
+			ivCounter_ptr = (CRYS_AES_IvCounter_t *)ss_malloc_and_copy(
+					sizeof(CRYS_AES_IvCounter_t), (const void *)iv,
+					iv_len, &res);
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		if ((int32_t)algo == TEE_ALG_AES_XTS) {
+			PROV_DMSG("Copy AES key (XTS)\n");
+			if ((key1 != NULL) && (key2 != NULL) && (key1_len == key2_len)) {
+				switch (key1_len + key2_len) {
+				case 32U:
+					aesKeySize = CRYS_AES_Key256BitSize;
+					break;
+				case 64U:
+					PROV_DMSG("KeySize=512Bit\n");
+					aesKeySize = CRYS_AES_Key512BitSize;
+					break;
+				default:
+					PROV_DMSG("ERROR:BAD_PARAMETERS key_len=%ld\n",
+							key1_len + key2_len);
+					res = SS_ERROR_BAD_PARAMETERS;
+					break;
+				}
+				if (res == SS_SUCCESS) {
+					(void)memcpy(aesKey, key1, key1_len);
+					(void)memcpy((void *)&aesKey[key1_len],
+							key2, key1_len);
+					PROV_DMSG("AES key ...%x%x sizse_num=%d\n",
+							aesKey[1],aesKey[0],aesKeySize);
+				}
+			} else {
+				PROV_DMSG("ERROR:BAD_PARAMETERS(key_ptr)\n");
+				res = SS_ERROR_BAD_PARAMETERS;
+			}
+		} else {
+			PROV_DMSG("Copy AES key (non XTS)\n");
+			if (key1 != NULL) {
+				switch (key1_len) {
+				case 16U:
+					PROV_DMSG("KeySize=128Bit\n");
+					aesKeySize = CRYS_AES_Key128BitSize;
+					break;
+				case 24U:
+					PROV_DMSG("KeySize=192Bit\n");
+					aesKeySize = CRYS_AES_Key192BitSize;
+					break;
+				case 32U:
+					PROV_DMSG("KeySize=256Bit\n");
+					aesKeySize = CRYS_AES_Key256BitSize;
+					break;
+				default:
+					PROV_DMSG("ERROR:BAD_PARAMETERS key_len=%ld\n",
+							key1_len);
+					res = SS_ERROR_BAD_PARAMETERS;
+					break;
+				}
+				if (res == SS_SUCCESS) {
+					(void)memcpy(aesKey, key1,
+							key1_len);
+					PROV_DMSG("AES key ...%x%x sizse_num=%d\n",
+							aesKey[1],aesKey[0],aesKeySize);
+				}
+			} else {
+				PROV_DMSG("ERROR:BAD_PARAMETERS(key_ptr)\n");
+				res = SS_ERROR_BAD_PARAMETERS;
+			}
+		}
+	}
+	if (res == SS_SUCCESS) {
+		switch (mode) {
+		case TEE_MODE_ENCRYPT:
+			PROV_DMSG("encDecFlag=CRYS_AES_Encrypt\n");
+			encDecFlag = CRYS_AES_Encrypt;
+			break;
+		case TEE_MODE_DECRYPT:
+			PROV_DMSG("encDecFlag=CRYS_AES_Decrypt\n");
+			encDecFlag = CRYS_AES_Decrypt;
+			break;
+		default:
+			PROV_DMSG("ERROR:BAD_PARAMETERS(mode)\n");
+			res = SS_ERROR_BAD_PARAMETERS;
+			break;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		switch ((int32_t)algo) {
+		case TEE_ALG_AES_ECB_NOPAD:
+			PROV_DMSG("opeMode=CRYS_AES_ECB_mode\n");
+			opeMode = CRYS_AES_ECB_mode;
+			break;
+		case TEE_ALG_AES_CBC_NOPAD:
+			PROV_DMSG("opeMode=CRYS_AES_CBC_mode\n");
+			opeMode = CRYS_AES_CBC_mode;
+			break;
+		case TEE_ALG_AES_CTR:
+			PROV_DMSG("opeMode=CRYS_AES_CTR_mode\n");
+			opeMode = CRYS_AES_CTR_mode;
+			break;
+		case TEE_ALG_AES_CTS:
+			PROV_DMSG("opeMode=CRYS_AES_CBC_CTS_mode\n");
+			opeMode = CRYS_AES_CBC_CTS_mode;
+			break;
+		case TEE_ALG_AES_XTS:
+			PROV_DMSG("opeMode=CRYS_AES_XTS_mode\n");
+			ss_ctx->blockSize = 32U;
+			opeMode = CRYS_AES_XTS_mode;
+			break;
+		default:
+			PROV_DMSG("ERROR:BAD_PARAMETERS(algo)\n");
+			res = SS_ERROR_NOT_SUPPORTED;
+			break;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: CRYS_AES_Init\n");
+		crys_res = CRYS_AES_Init(
+				contextID_ptr,
+				*ivCounter_ptr,
+				aesKey,
+				aesKeySize, encDecFlag, opeMode);
+		ss_ctx->crys_error = crys_res;
+		res = ss_translate_error_crys2ss_aes(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	ss_free((void *)ivCounter_ptr);
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+
+/*
+ * brief:	Initialize state of DES algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AES contest.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	mode		- Cipher Mode.
+ * param[in]	*key1		- Pinter to the AES key.
+ * param[in]	key1_len	- AES key size.
+ * param[in]	*key2		- Pinter to the AES key(only AES-XST).
+ * param[in]	key2_len	- AES key size(only AES-XST).
+ * param[in]	*iv		- Pointer to the Initialize vector.
+ * param[in]	iv_len		- Initialize vector size.
+ * return	SSError_t	- SS provider error code.
+ */
+#define DESKEY_SIZE_BYTE 8U
+static SSError_t ss_des_init(void *ctx, uint32_t algo, TEE_OperationMode mode,
+		const uint8_t *key1, size_t key1_len,
+		const uint8_t *key2 __unused, size_t key2_len __unused,
+		const uint8_t *iv, size_t iv_len)
+{
+
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+
+	SS_DES_Context_t *ss_ctx;
+	CRYS_DESUserContext_t *contextID_ptr;
+	CRYS_DES_Iv_t *ivConter_ptr = NULL;
+	CRYS_DES_Key_t *desKey = NULL;
+	CRYS_DES_NumOfKeys_t numOfKeys = CRYS_DES_NumOfKeysLast;
+	CRYS_DES_EncryptMode_t encDecFlag = CRYS_DES_EncryptModeLast;
+	CRYS_DES_OperationMode_t opeMode = CRYS_DES_OperationModeLast;
+
+	PROV_INMSG("START ss_des_init\n");
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_DES_Context_t *)ctx;
+		ss_ctx->crys_error = SS_SUCCESS;
+		ss_ctx->blockSize = 8U;
+		ss_ctx->restBufSize= 0U;
+		contextID_ptr = &ss_ctx->crys_ctx;
+		(void)memset(contextID_ptr, 0, sizeof(CRYS_DESUserContext_t));
+	} else {
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		if (iv != NULL) {
+			ivConter_ptr = (CRYS_DES_Iv_t *)ss_malloc_and_copy(
+					sizeof(CRYS_DES_Iv_t), (const void *)iv, iv_len,
+					&res);
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		desKey = (CRYS_DES_Key_t *)ss_malloc(sizeof(CRYS_DES_Key_t),
+				&res);
+
+	}
+
+	if (res == SS_SUCCESS) {
+		if (key1 == NULL) {
+			PROV_DMSG("ERROR: BAD_PARAMETERS(key1)\n");
+			res = SS_ERROR_BAD_PARAMETERS;
+		}
+		if (key2_len != 0U) {
+			PROV_DMSG("ERROR: BAD_PARAMETERS(key2_len)\n");
+			res = SS_ERROR_BAD_PARAMETERS;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		switch ((int32_t)algo) {
+		case TEE_ALG_DES_ECB_NOPAD:
+		case TEE_ALG_DES_CBC_NOPAD:
+			PROV_DMSG("algo = DES   ");
+			switch (key1_len) {
+			case (DESKEY_SIZE_BYTE):
+				(void)memcpy(desKey->key1, key1,
+						DESKEY_SIZE_BYTE);
+				numOfKeys = CRYS_DES_1_KeyInUse;
+				PROV_DMSG("numOfKeys = 1\n");
+				break;
+			default:
+				PROV_DMSG("ERROR: BAD_PARAMETERS(key1_len)\n");
+				res = SS_ERROR_BAD_PARAMETERS;
+				break;
+			}
+			break;
+		case TEE_ALG_DES3_ECB_NOPAD:
+		case TEE_ALG_DES3_CBC_NOPAD:
+			PROV_DMSG("algo = DES3   ");
+			switch (key1_len) {
+			case (DESKEY_SIZE_BYTE*2U):
+				(void)memcpy(desKey->key1, key1,
+						DESKEY_SIZE_BYTE);
+				(void)memcpy(desKey->key2,
+						key1 + DESKEY_SIZE_BYTE,
+						DESKEY_SIZE_BYTE);
+				numOfKeys = CRYS_DES_2_KeysInUse;
+				PROV_DMSG("numOfKeys = 2\n");
+				break;
+			case (DESKEY_SIZE_BYTE*3U):
+				(void)memcpy(desKey->key1, key1,
+						DESKEY_SIZE_BYTE);
+				(void)memcpy(desKey->key2,
+						key1 + DESKEY_SIZE_BYTE,
+						DESKEY_SIZE_BYTE);
+				(void)memcpy(desKey->key3,
+						key1 + (DESKEY_SIZE_BYTE * 2U),
+						DESKEY_SIZE_BYTE);
+				numOfKeys = CRYS_DES_3_KeysInUse;
+				PROV_DMSG("numOfKeys = 3\n");
+				break;
+			default:
+				PROV_DMSG("ERROR: BAD_PARAMETERS(key1_len)\n");
+				res = SS_ERROR_NOT_SUPPORTED;
+				break;
+			}
+			break;
+		default:
+			PROV_DMSG("ERROR: BAD_PARAMETERS(algo)\n");
+			res = SS_ERROR_BAD_PARAMETERS;
+			break;
+		}
+
+	}
+	if (res == SS_SUCCESS) {
+		switch (mode) {
+		case TEE_MODE_ENCRYPT:
+			PROV_DMSG("numOfKeys = 3\n");
+			encDecFlag = CRYS_DES_Encrypt;
+			break;
+		case TEE_MODE_DECRYPT:
+			PROV_DMSG("numOfKeys = 3\n");
+			encDecFlag = CRYS_DES_Decrypt;
+			break;
+		default:
+			PROV_DMSG("ERROR: BAD_PARAMETERS(mode)\n");
+			res = SS_ERROR_BAD_PARAMETERS;
+			break;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		switch ((int32_t)algo) {
+		case TEE_ALG_DES_ECB_NOPAD:
+		case TEE_ALG_DES3_ECB_NOPAD:
+			PROV_DMSG("numOfKeys = 2\n");
+			opeMode = CRYS_DES_ECB_mode;
+			break;
+		case TEE_ALG_DES_CBC_NOPAD:
+		case TEE_ALG_DES3_CBC_NOPAD:
+			PROV_DMSG("numOfKeys = 3\n");
+			opeMode = CRYS_DES_CBC_mode;
+			break;
+		default:
+			PROV_EMSG("NOT_SUPPORTED\n");
+			res = SS_ERROR_NOT_SUPPORTED;
+			break;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		crys_res = CRYS_DES_Init(
+				contextID_ptr,
+				*ivConter_ptr,
+				desKey,
+				numOfKeys, encDecFlag, opeMode);
+		ss_ctx->crys_error = crys_res;
+		res = ss_translate_error_crys2ss_des(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	ss_free((void *)ivConter_ptr);
+	ss_free((void *)desKey);
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Initialize state of AES,DES algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AES contest.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	mode		- Cipher Mode.
+ * param[in]	*key1		- Pinter to the AES key.
+ * param[in]	key1_len	- AES key size.
+ * param[in]	*key2		- Pinter to the AES key(only AES-XST).
+ * param[in]	key2_len	- AES key size(only AES-XST).
+ * param[in]	*iv		- Pointer to the Initialize vector.
+ * param[in]	iv_len		- Initialize vector size.
+ * return	SSError_t	- SS provider error code.
+ */
+static TEE_Result cipher_init(
+		void *ctx, uint32_t algo,
+		TEE_OperationMode mode,
+		const uint8_t *key1, size_t key1_len,
+		const uint8_t *key2, size_t key2_len,
+		const uint8_t *iv,   size_t iv_len)
+{
+	SSError_t res;
+	PROV_INMSG("*ctx=%p, algo=%d, mode=%d, *key1=%p, key1_len=%ld\n",ctx,algo,mode,key1,key1_len);
+	PROV_INMSG("*key2=%p, key2_len=%ld, *iv=%p, *iv_len=%ld\n",key2,key2_len,iv,iv_len);
+
+	PROV_DMSG("Input key1\n");
+	PROV_DHEXDUMP(key1,key1_len);
+	PROV_DMSG("Input key2\n");
+	PROV_DHEXDUMP(key2,key2_len);
+	PROV_DMSG("Input iv\n");
+	PROV_DHEXDUMP(iv,iv_len);
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_AES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_AES_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_AES_CBC_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CTR)
+	case TEE_ALG_AES_CTR:
+#endif
+#if defined(CFG_CRYPTO_CTS)
+	case TEE_ALG_AES_CTS:
+#endif
+#if defined(CFG_CRYPTO_XTS)
+	case TEE_ALG_AES_XTS:
+#endif
+		PROV_DMSG("Input ctx\n");
+		PROV_DHEXDUMP(ctx,sizeof(SS_AES_Context_t));
+		PROV_DMSG("CALL: ss_aes_init\n");
+		res = ss_aes_init(ctx, algo, mode, key1, key1_len, key2,
+				key2_len, iv, iv_len);
+		PROV_DMSG("Result: 0x%08x\n",res);
+		break;
+#endif
+#if defined(CFG_CRYPTO_DES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_DES_ECB_NOPAD:
+	case TEE_ALG_DES3_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_DES_CBC_NOPAD:
+	case TEE_ALG_DES3_CBC_NOPAD:
+#endif
+		PROV_DMSG("CALL: ss_aes_init\n");
+		res = ss_des_init(ctx, algo, mode, key1, key1_len, key2,
+				key2_len, iv, iv_len);
+		PROV_DMSG("Result: 0x%08x\n",res);
+		break;
+#endif
+	case TEE_ALG_DES_CBC_MAC_NOPAD:
+	case TEE_ALG_DES_CBC_MAC_PKCS5:
+	case TEE_ALG_DES3_CBC_MAC_NOPAD:
+	case TEE_ALG_DES3_CBC_MAC_PKCS5:
+	case TEE_ALG_AES_GCM:
+	case TEE_ALG_AES_CCM:
+	case TEE_ALG_AES_CBC_MAC_NOPAD:
+	case TEE_ALG_AES_CBC_MAC_PKCS5:
+	case TEE_ALG_AES_CMAC:
+	default:
+		PROV_DMSG("ERROR:SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return ss_translate_error_ss2tee(res);
+}
+
+/*
+ * brief:	Block Data Update state of AES algorithm.
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*dstPtr		- Pointer to destination data buffer.
+ * param[in]	dstSize		- destination data size.
+ * param[in]	blockSize	- block data size.
+ * return	SSError_t	- Internal error code of this provider.
+ */
+static SSError_t ss_swap_cts_block(uint32_t algo, uint8_t *dstPtr,
+		uint32_t dstSize, uint32_t blockSize)
+{
+	SSError_t res = SS_SUCCESS;
+	uint8_t *swapPtr;
+	PROV_DMSG("algo=0x%08x dstPtr=%p\n", algo, dstPtr);
+	PROV_DMSG("dInSize=%d blkSize=%d\n", dstSize, blockSize);
+	if ((0U == (dstSize % blockSize)) && (TEE_ALG_AES_CTS == (int32_t)algo)) {
+		swapPtr = (uint8_t *)ss_malloc(dstSize, &res);
+		if (SS_SUCCESS == res) {
+			(void)memcpy(swapPtr, dstPtr + blockSize, blockSize);
+			(void)memcpy(swapPtr + blockSize, dstPtr, blockSize);
+			(void)memcpy(dstPtr, swapPtr, dstSize);
+			ss_free(swapPtr);
+		}
+	}
+	return res;
+}
+
+#define CTS_OFFSET 17U
+/*
+ * brief:	Block Data Update state of AES algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AES,DES context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	last_block	- If source data is last chunk, the value is true.
+ * param[in]	*data		- Pointer to source data buffer.
+ * param[in]	len		- Source data size.
+ * param[in]	*dst		- Pointer to destination data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static SSError_t ss_aes_update(void *ctx, uint32_t algo, bool last_block,
+		const uint8_t *data, size_t len, uint8_t *dst)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_AES_Context_t *ss_ctx = NULL;
+	CRYS_AESUserContext_t  *ContextID_ptr;
+	uint8_t *dataIn_ptr = NULL;
+	uint32_t dataInSize;
+	uint8_t *dataOut_ptr = NULL;
+	uint8_t *ctsData = NULL;
+
+	PROV_INMSG("START ss_aes_update\n");
+
+	CHECK_CONTEXT(res, ss_ctx, SS_AES_Context_t, ctx);
+
+	if (SS_SUCCESS == res) {
+		if (NULL != dst) {
+			dataOut_ptr = dst;
+		} else {
+			res = SS_ERROR_BAD_PARAMETERS;
+			PROV_EMSG("BAD_PARAMETERS(dst)\n");
+		}
+	}
+
+	if (SS_SUCCESS == res) {
+		if (((uint32_t)TEE_ALG_AES_CTS == algo) && (true == last_block)) {
+			if (CTS_OFFSET <= len) {
+				len -= CTS_OFFSET;
+			} else {
+				res = SS_ERROR_BAD_PARAMETERS;
+			}
+		}
+	}
+
+	if (SS_SUCCESS == res) {
+		res = ss_buffer_update(ss_ctx, algo, data, len, &dataOut_ptr);
+	}
+
+	if ((SS_SUCCESS == res) && (true == last_block)) {
+		if ((uint32_t)TEE_ALG_AES_CTS == algo) {
+			dataInSize = ss_ctx->restBufSize + CTS_OFFSET;
+			ctsData = (uint8_t *)ss_malloc(dataInSize, &res);
+			if (SS_SUCCESS == res) {
+				(void)memcpy(ctsData, ss_ctx->restBuf,
+						ss_ctx->restBufSize);
+				(void)memcpy((ctsData + ss_ctx->restBufSize),
+						(data + len), CTS_OFFSET);
+				dataIn_ptr = ctsData;
+				if (TEE_MODE_DECRYPT == ss_ctx->mode) {
+					PROV_DMSG("algo=0x%08x dstData=%p\n",
+							algo, ctsData);
+					PROV_DMSG("dstSize=%d blkSize=%d\n",
+							dataInSize,
+							ss_ctx->blockSize);
+					res = ss_swap_cts_block(algo, ctsData,
+							dataInSize,
+							ss_ctx->blockSize);
+				}
+
+			}
+		} else {
+			dataInSize = ss_ctx->restBufSize;
+			dataIn_ptr = ss_ctx->restBuf;
+		}
+		if (SS_SUCCESS == res) {
+			ContextID_ptr = &ss_ctx->crys_ctx;
+			crys_res = CRYS_AES_Finish(ContextID_ptr, dataIn_ptr,
+					dataInSize, dataOut_ptr);
+			ss_ctx->crys_error = crys_res;
+			res = ss_translate_error_crys2ss_aes(crys_res);
+		}
+		if ((SS_SUCCESS == res) && (TEE_MODE_ENCRYPT == ss_ctx->mode)) {
+			PROV_DMSG("algo=0x%08x dstData=%p\n", algo,
+					dataOut_ptr);
+			PROV_DMSG("dstSize=%d blkSize=%d\n", dataInSize,
+					ss_ctx->blockSize);
+			res = ss_swap_cts_block(algo, dataOut_ptr, dataInSize,
+					ss_ctx->blockSize);
+		}
+		PROV_DMSG("crys_res=0x%08x -> res=0x%08x\n", crys_res, res);
+		ss_free(ctsData);
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+
+}
+
+/*
+ * brief:	Block Data Update state of DES algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AES,DES context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*data		- Pointer to source data buffer.
+ * param[in]	len		- Source data size.
+ * param[in]	*dst		- Pointer to destination data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static SSError_t ss_des_update(void *ctx, uint32_t algo, const uint8_t *data,
+		size_t len, uint8_t *dst)
+{
+	SSError_t res = SS_SUCCESS;
+	SS_DES_Context_t *ss_ctx = NULL;
+	uint8_t *dataOut_ptr = NULL;
+
+	PROV_INMSG("START cipher_init\n");
+
+	CHECK_CONTEXT(res, ss_ctx, SS_DES_Context_t, ctx);
+
+	if (SS_SUCCESS == res) {
+		if (NULL != dst) {
+			dataOut_ptr = dst;
+		} else {
+			res = SS_ERROR_BAD_PARAMETERS;
+			PROV_EMSG("BAD_PARAMETERS(dst)\n");
+		}
+	}
+
+	if (SS_SUCCESS == res) {
+		res = ss_buffer_update(ss_ctx, algo, data, len,
+				&dataOut_ptr);
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Block Data Update state of AES,DES algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AES,DES context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	last_block	- If source data is last chunk, the value is true.
+ * param[in]	*data		- Pointer to source data buffer.
+ * param[in]	len		- Source data size.
+ * param[in]	*dst		- Pointer to destination data buffer.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result cipher_update(void *ctx, uint32_t algo,
+		TEE_OperationMode mode __unused,
+		bool last_block, const uint8_t *data, size_t len, uint8_t *dst)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+
+	PROV_INMSG("*ctx=%p, algo=%d, mode=%d, last_block=%d\n",ctx,algo,mode,last_block);
+	PROV_INMSG("*data=%p, len=%ld, *dst=%p\n",data,len,dst);
+
+	PROV_DMSG("Input src data\n");
+	PROV_DHEXDUMP(data,len);
+	PROV_DMSG("Input dst data\n");
+	PROV_DHEXDUMP(dst,len);
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_AES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_AES_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_AES_CBC_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CTR)
+	case TEE_ALG_AES_CTR:
+#endif
+#if defined(CFG_CRYPTO_CTS)
+	case TEE_ALG_AES_CTS:
+#endif
+#if defined(CFG_CRYPTO_XTS)
+	case TEE_ALG_AES_XTS:
+#endif
+		PROV_DMSG("CALL: ss_aes_update\n");
+		PROV_DMSG("Input ctx\n");
+		PROV_DHEXDUMP(ctx,sizeof(SS_AES_Context_t));
+		res = ss_aes_update(ctx, algo,last_block, data, len, dst);
+		PROV_DMSG("Result: 0x%08x\n",res);
+		break;
+#endif
+#if defined(CFG_CRYPTO_DES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_DES_ECB_NOPAD:
+	case TEE_ALG_DES3_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_DES_CBC_NOPAD:
+	case TEE_ALG_DES3_CBC_NOPAD:
+#endif
+		PROV_DMSG("CALL: ss_des_update\n");
+		PROV_DMSG("Input ctx\n");
+		PROV_DHEXDUMP(ctx,sizeof(SS_DES_Context_t));
+		res = ss_des_update(ctx, algo, data, len, dst);
+		PROV_DMSG("Result: 0x%08x\n",res);
+		break;
+#endif
+	case TEE_ALG_DES_CBC_MAC_NOPAD:
+	case TEE_ALG_DES_CBC_MAC_PKCS5:
+	case TEE_ALG_DES3_CBC_MAC_NOPAD:
+	case TEE_ALG_DES3_CBC_MAC_PKCS5:
+	case TEE_ALG_AES_GCM:
+	case TEE_ALG_AES_CCM:
+	case TEE_ALG_AES_CBC_MAC_NOPAD:
+	case TEE_ALG_AES_CBC_MAC_PKCS5:
+	case TEE_ALG_AES_CMAC:
+	default:
+		PROV_DMSG("ERROR:SS_ERROR_NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_DMSG("Output dst data\n");
+	PROV_DHEXDUMP(dst,len);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Finalize state of AES algorithm.
+ *
+ * param[in]	*ctx		- Context to HASH algorithm.
+ * param[in]	algo		- Cryptographic algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static void ss_aes_final(void *ctx, uint32_t algo)
+{
+	TEE_Result res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_AES_Context_t *ss_ctx;
+	CRYS_AESUserContext_t *contextID_ptr;
+
+	PROV_DMSG("*ctx=%p, algo=%d\n",ctx,algo);
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_AES_Context_t *)ctx;
+	} else {
+		PROV_EMSG("ERROR:BAD_PARAMETERS algo=0x%08x\n",algo);
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		contextID_ptr = &ss_ctx->crys_ctx;
+		switch ((int32_t) algo) {
+#if defined(CFG_CRYPTO_AES)
+#if defined(CFG_CRYPTO_ECB)
+		case TEE_ALG_AES_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+		case TEE_ALG_AES_CBC_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CTR)
+		case TEE_ALG_AES_CTR:
+#endif
+#if defined(CFG_CRYPTO_CTS)
+		case TEE_ALG_AES_CTS:
+#endif
+#if defined(CFG_CRYPTO_XTS)
+		case TEE_ALG_AES_XTS:
+#endif
+			PROV_DMSG("CALL: CRYS_AES_Finish\n");
+			crys_res = CRYS_AES_Finish(contextID_ptr, NULL, 0U,
+					NULL);
+			ss_ctx->crys_error = crys_res;
+			PROV_DMSG("Result: crys_res=0x%08x\n", crys_res);
+			break;
+#endif
+		case TEE_ALG_AES_GCM:
+		case TEE_ALG_AES_CCM:
+		case TEE_ALG_AES_CBC_MAC_NOPAD:
+		case TEE_ALG_AES_CBC_MAC_PKCS5:
+		case TEE_ALG_AES_CMAC:
+		default:
+			break;
+		}
+	}
+	return;
+}
+
+
+/*
+ * brief:	Finalize state of AES,DES algorithm.
+ *
+ * param[in]	*ctx		- Context to HASH algorithm.
+ * param[in]	algo		- Cryptographic algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static void ss_des_final(void *ctx, uint32_t algo)
+{
+	TEE_Result res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_DES_Context_t *ss_ctx;
+	CRYS_DESUserContext_t *contextID_ptr;
+
+	PROV_DMSG("*ctx=%p, algo=%d\n",ctx,algo);
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_DES_Context_t *)ctx;
+	} else {
+		PROV_EMSG("ERROR:BAD_PARAMETERS algo=0x%08x\n",algo);
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		contextID_ptr = &ss_ctx->crys_ctx;
+
+		switch ((int32_t) algo) {
+#if defined(CFG_CRYPTO_DES)
+#if defined(CFG_CRYPTO_ECB)
+		case TEE_ALG_DES_ECB_NOPAD:
+		case TEE_ALG_DES3_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_ECB)
+		case TEE_ALG_DES_CBC_NOPAD:
+		case TEE_ALG_DES3_CBC_NOPAD:
+#endif
+			PROV_DMSG("CALL: CRYS_DES_Free\n");
+			crys_res = CRYS_DES_Free(contextID_ptr);
+			ss_ctx->crys_error = crys_res;
+			PROV_DMSG("Result: crys_res=0x%08x\n", crys_res);
+			break;
+		case TEE_ALG_DES3_CBC_MAC_NOPAD:
+		case TEE_ALG_DES3_CBC_MAC_PKCS5:
+		case TEE_ALG_DES_CBC_MAC_NOPAD:
+		case TEE_ALG_DES_CBC_MAC_PKCS5:
+#endif
+		default:
+			break;
+		}
+	}
+	return;
+}
+
+/*
+ * brief:	Finalize state of AES,DES algorithm.
+ *
+ * param[in]	*ctx		- Context to HASH algorithm.
+ * param[in]	algo		- Cryptographic algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static void cipher_final(void *ctx, uint32_t algo)
+{
+	PROV_INMSG("*ctx=%p, algo=%d\n",ctx,algo);
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_AES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_AES_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_AES_CBC_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CTR)
+	case TEE_ALG_AES_CTR:
+#endif
+#if defined(CFG_CRYPTO_CTS)
+	case TEE_ALG_AES_CTS:
+#endif
+#if defined(CFG_CRYPTO_XTS)
+	case TEE_ALG_AES_XTS:
+#endif
+		PROV_DMSG("CALL: ss_aes_final\n");
+		PROV_DMSG("Input ctx\n");
+		PROV_DHEXDUMP(ctx,sizeof(SS_AES_Context_t));
+		ss_aes_final(ctx, algo);
+		break;
+#endif
+#if defined(CFG_CRYPTO_DES)
+#if defined(CFG_CRYPTO_ECB)
+	case TEE_ALG_DES_ECB_NOPAD:
+	case TEE_ALG_DES3_ECB_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CBC)
+	case TEE_ALG_DES_CBC_NOPAD:
+	case TEE_ALG_DES3_CBC_NOPAD:
+#endif
+		PROV_DMSG("CALL: ss_des_final\n");
+		PROV_DMSG("Input ctx\n");
+		PROV_DHEXDUMP(ctx,sizeof(SS_DES_Context_t));
+		ss_des_final(ctx, algo);
+		break;
+#endif
+	case TEE_ALG_DES_CBC_MAC_NOPAD:
+	case TEE_ALG_DES_CBC_MAC_PKCS5:
+	case TEE_ALG_DES3_CBC_MAC_NOPAD:
+	case TEE_ALG_DES3_CBC_MAC_PKCS5:
+	case TEE_ALG_AES_GCM:
+	case TEE_ALG_AES_CCM:
+	case TEE_ALG_AES_CBC_MAC_NOPAD:
+	case TEE_ALG_AES_CBC_MAC_PKCS5:
+	case TEE_ALG_AES_CMAC:
+	default:
+		break;
+	}
+	return;
+}
+
+#endif /* _CFG_CRYPTO_WITH_CIPHER */
+
+/*****************************************************************************
+ * Message Authentication Code functions
+ *****************************************************************************/
+
+#if defined(_CFG_CRYPTO_WITH_MAC)
+/*
+ * brief:	Get context size to HMAC,AES-MAC algorithm.
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*size		- Size of context to AES,DES algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result mac_get_ctx_size(uint32_t algo, size_t *size)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+
+	PROV_INMSG("START: mac_get_ctx_size\n");
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_HMAC)
+	case TEE_ALG_HMAC_MD5:
+	case TEE_ALG_HMAC_SHA224:
+	case TEE_ALG_HMAC_SHA1:
+	case TEE_ALG_HMAC_SHA256:
+	case TEE_ALG_HMAC_SHA384:
+	case TEE_ALG_HMAC_SHA512:
+		PROV_DMSG("ctx size = sizeof(SS_HMAC_Context_t)\n");
+		*size = sizeof(SS_HMAC_Context_t);
+		break;
+#endif
+#if defined(CFG_CRYPTO_CBC_MAC)
+	case TEE_ALG_AES_CBC_MAC_NOPAD:
+	case TEE_ALG_AES_CBC_MAC_PKCS5:
+		PROV_DMSG("ctx size = sizeof(SS_AES_Context_t)\n");
+		*size = sizeof(SS_AES_Context_t);
+		break;
+#endif
+#if defined(CFG_CRYPTO_CMAC)
+	case TEE_ALG_AES_CMAC:
+		PROV_DMSG("ctx size = sizeof(SS_AES_Context_t)\n");
+		*size = sizeof(SS_AES_Context_t);
+		break;
+#endif
+	default:
+
+		PROV_EMSG("NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+
+/*
+ * brief:	Initialize state of AES-MAC algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AES contest.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*key		- Pinter to the AES key.
+ * param[in]	len		- AES key size.
+ * return	SSError_t	- SS provider error code.
+ */
+static SSError_t ss_aesmac_init(void *ctx, uint32_t algo __unused,
+		const uint8_t *key, size_t len)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_AES_Context_t *ss_ctx;
+	CRYS_AESUserContext_t *contextID_ptr;
+	CRYS_AES_IvCounter_t ivCounter_ptr = {0U};
+	CRYS_AES_OperationMode_t aesMode;
+	CRYS_AES_Key_t aesKey = {0U};
+	CRYS_AES_KeySize_t aeskeySize;
+
+	PROV_INMSG("START: ss_aesmac_init\n");
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_AES_Context_t *)ctx;
+		(void)memset(ss_ctx,0,sizeof(SS_AES_Context_t));
+		ss_ctx->crys_error = SS_SUCCESS;
+		ss_ctx->blockSize = 16U;
+		ss_ctx->restBufSize = 0U;
+		contextID_ptr = &ss_ctx->crys_ctx;
+	} else {
+		PROV_EMSG("BAD_PARAMETERS(ctx)\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		switch (len) {
+		case 16U:
+			PROV_DMSG("key_len = 128bit\n");
+			aeskeySize = CRYS_AES_Key128BitSize;
+			break;
+		case 24U:
+			PROV_DMSG("key_len = 192bit\n");
+			aeskeySize = CRYS_AES_Key192BitSize;
+			break;
+		case 32U:
+			PROV_DMSG("key_len = 256bit\n");
+			aeskeySize = CRYS_AES_Key256BitSize;
+			break;
+		default:
+			PROV_EMSG("BAD_PARAMETERS(len)\n");
+			aeskeySize = CRYS_AES_KeySizeLast;
+			res = SS_ERROR_BAD_PARAMETERS;
+			break;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		if (key == NULL) {
+			PROV_EMSG("BAD_PARAMETERS(key)\n");
+			res = SS_ERROR_BAD_PARAMETERS;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_CBC_MAC)
+		case TEE_ALG_AES_CBC_MAC_NOPAD:
+		case TEE_ALG_AES_CBC_MAC_PKCS5:
+			PROV_DMSG("algo = AES MAC\n");
+			aesMode = CRYS_AES_MAC_mode;
+			break;
+#endif
+#if defined(CFG_CRYPTO_CMAC)
+		case TEE_ALG_AES_CMAC:
+			PROV_DMSG("algo = CMAC\n");
+			aesMode = CRYS_AES_CMAC_mode;
+			break;
+#endif
+		default:
+			PROV_EMSG("NOT_SUPPORTED\n");
+			res = SS_ERROR_NOT_SUPPORTED;
+			break;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		(void)memcpy(aesKey, key, len);
+		PROV_DMSG("CALL:  CRYS_AES_Init()\n");
+		crys_res = CRYS_AES_Init(contextID_ptr, ivCounter_ptr, aesKey,
+				aeskeySize, CRYS_AES_Encrypt, aesMode);
+		ss_ctx->crys_error = crys_res;
+		res = ss_translate_error_crys2ss_aes(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Initialize state of HMAC algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the HASH contest.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*key		- Pinter to the Random key.
+ * param[in]	len		- Random key size.
+ * return	SSError_t	- SS provider error code.
+ */
+static SSError_t ss_hmac_init(void *ctx, uint32_t algo, const uint8_t *key,
+		size_t len)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_HMAC_Context_t *ss_ctx;
+	CRYS_HMACUserContext_t *contextID_ptr;
+	uint8_t *hashKey_ptr;
+	uint16_t hashKeySize;
+	CRYS_HASH_OperationMode_t opeMode;
+
+	PROV_INMSG("START: ss_hmac_init\n");
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_HMAC_Context_t *)ctx;
+		(void)memset(ss_ctx,0,sizeof(SS_HMAC_Context_t));
+		ss_ctx->crys_error = SS_SUCCESS;
+		ss_ctx->restBufSize = 0U;
+		contextID_ptr = &ss_ctx->crys_ctx;
+		hashKey_ptr = (uint8_t *)key;
+		hashKeySize = (uint16_t)len;
+		ss_ctx->blockSize = 64U;
+	} else {
+		PROV_EMSG("BAD_PARAMETERS(ctx)\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_MD5)
+		case TEE_ALG_HMAC_MD5:
+			PROV_DMSG("algo = TEE_ALG_HMAC_MD5\n");
+			opeMode = CRYS_HASH_MD5_mode;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA1)
+		case TEE_ALG_HMAC_SHA1:
+			PROV_DMSG("algo = TEE_ALG_HMAC_SHA1\n");
+			opeMode = CRYS_HASH_SHA1_mode;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA224)
+		case TEE_ALG_HMAC_SHA224:
+			PROV_DMSG("algo = TEE_ALG_HMAC_SHA224\n");
+			opeMode = CRYS_HASH_SHA224_mode;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA256)
+		case TEE_ALG_HMAC_SHA256:
+			PROV_DMSG("algo = TEE_ALG_HMAC_SHA256\n");
+			opeMode = CRYS_HASH_SHA256_mode;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA384)
+		case TEE_ALG_HMAC_SHA384:
+			PROV_DMSG("algo = TEE_ALG_HMAC_SHA384\n");
+			opeMode = CRYS_HASH_SHA384_mode;
+			ss_ctx->blockSize = 128U;
+			break;
+#endif
+#if defined(CFG_CRYPTO_SHA512)
+		case TEE_ALG_HMAC_SHA512:
+			PROV_DMSG("algo = TEE_ALG_HMAC_SHA512\n");
+			opeMode = CRYS_HASH_SHA512_mode;
+			ss_ctx->blockSize = 128U;
+			break;
+#endif
+		default:
+			PROV_EMSG("NOT_SUPPORTED\n");
+			opeMode = CRYS_HASH_OperationModeLast;
+			res = SS_ERROR_NOT_SUPPORTED;
+			break;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL:  CRYS_HMAC_Init()\n");
+		crys_res = CRYS_HMAC_Init(contextID_ptr, opeMode, hashKey_ptr,
+				hashKeySize);
+		ss_ctx->crys_error = crys_res;
+		res = ss_translate_error_crys2ss_hmac(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Initialize state of HMAC,AES-MAC algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the HASH contest.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*key		- Pinter to the Random key.
+ * param[in]	len		- Random key size.
+ * return	SSError_t	- SS provider error code.
+ */
+static TEE_Result mac_init(void *ctx, uint32_t algo, const uint8_t *key,
+		size_t len)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+
+	PROV_INMSG("START: mac_init\n");
+	PROV_DMSG("algo = 0x%08x\n",algo);
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_HMAC)
+	case TEE_ALG_HMAC_MD5:
+	case TEE_ALG_HMAC_SHA1:
+	case TEE_ALG_HMAC_SHA224:
+	case TEE_ALG_HMAC_SHA256:
+	case TEE_ALG_HMAC_SHA384:
+	case TEE_ALG_HMAC_SHA512:
+		PROV_DMSG("CALL:  ss_hmac_init()\n");
+		res = ss_hmac_init(ctx, algo, key, len);
+		break;
+#endif
+#if defined(CFG_CRYPTO_CBC_MAC)
+	case TEE_ALG_AES_CBC_MAC_NOPAD:
+	case TEE_ALG_AES_CBC_MAC_PKCS5:
+		PROV_DMSG("CALL:  ss_aesmac_init()\n");
+		res = ss_aesmac_init(ctx, algo, key, len);
+		break;
+#endif
+#if defined(CFG_CRYPTO_CMAC)
+	case TEE_ALG_AES_CMAC:
+		PROV_DMSG("CALL:  ss_aesmac_init()\n");
+		res = ss_aesmac_init(ctx, algo, key, len);
+		break;
+#endif
+	default:
+		PROV_EMSG("NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Block Data Update state of HMAC algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the HMAC context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*data		- Pointer to source data buffer.
+ * param[in]	len		- Source data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static SSError_t ss_hmac_update(void *ctx, uint32_t algo, const uint8_t *data, size_t len)
+{
+	SSError_t res = SS_SUCCESS;
+	SS_HMAC_Context_t *ss_ctx;
+	uint8_t *nullBuf = NULL;
+
+	PROV_INMSG("START: ss_hmac_update\n");
+
+	CHECK_CONTEXT(res, ss_ctx, SS_HMAC_Context_t, ctx);
+
+	if(SS_SUCCESS == res){
+		res = ss_buffer_update(ctx, algo, data, len, &nullBuf);
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Block Data Update state of AES-MAC algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AES-MAC context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*data		- Pointer to source data buffer.
+ * param[in]	len		- Source data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static SSError_t ss_aesmac_update(void *ctx, uint32_t algo, const uint8_t *data,
+		size_t len)
+{
+	SSError_t res = SS_SUCCESS;
+	SS_AES_Context_t *ss_ctx;
+	uint8_t *nullBuf = NULL;
+
+	PROV_INMSG("START: ss_aesmac_update\n");
+
+	CHECK_CONTEXT(res, ss_ctx, SS_AES_Context_t, ctx);
+
+	if(SS_SUCCESS == res){
+		res = ss_buffer_update(ctx, algo, data, len, &nullBuf);
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Block Data Update state of HMAC,AES-MAC algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the HMAC,AES-MAC context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*data		- Pointer to source data buffer.
+ * param[in]	len		- Source data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result mac_update(void *ctx, uint32_t algo, const uint8_t *data,
+		size_t len)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+
+	PROV_INMSG("START: mac_update\n");
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_HMAC)
+	case TEE_ALG_HMAC_MD5:
+	case TEE_ALG_HMAC_SHA224:
+	case TEE_ALG_HMAC_SHA1:
+	case TEE_ALG_HMAC_SHA256:
+	case TEE_ALG_HMAC_SHA384:
+	case TEE_ALG_HMAC_SHA512:
+		PROV_DMSG("CALL: ss_hmac_update()\n");
+		res = ss_hmac_update(ctx, algo, data, len);
+		break;
+#endif
+#if defined(CFG_CRYPTO_AES)
+#if defined(CFG_CRYPTO_CBC_MAC)
+	case TEE_ALG_AES_CBC_MAC_PKCS5:
+	case TEE_ALG_AES_CBC_MAC_NOPAD:
+#endif
+#if defined(CFG_CRYPTO_CMAC)
+	case TEE_ALG_AES_CMAC:
+#endif
+		PROV_DMSG("CALL: ss_aesmac_update() algo=CMAC\n");
+		res = ss_aesmac_update(ctx, algo, data, len);
+		break;
+#endif
+	case TEE_ALG_DES_CBC_MAC_NOPAD:
+	case TEE_ALG_DES_CBC_MAC_PKCS5:
+	case TEE_ALG_DES3_CBC_MAC_NOPAD:
+	case TEE_ALG_DES3_CBC_MAC_PKCS5:
+	default:
+		PROV_EMSG("NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Finalize state of HMAC algorithm.
+ *
+ * param[in]	*ctx		- Context to HMAC,AES-MAC algorithm.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*digest		- Pointer to the digest(MAC) data.
+ * param[out]	digest_len	- Digest(MAC) data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static SSError_t ss_hmac_final(void *ctx, uint32_t algo, uint8_t *digest,
+		size_t digest_len)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_HMAC_Context_t *ss_ctx;
+	CRYS_HMACUserContext_t *contextID_ptr;
+	CRYS_HASH_Result_t hmacResultBuff;
+	uint32_t hmacResultLen = 0U;
+
+	PROV_INMSG("START: ss_hmac_final\n");
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_HMAC_Context_t *)ctx;
+	} else {
+		PROV_EMSG("BAD_PARAMETERS(ctx)\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		if (ss_ctx->crys_error != SS_SUCCESS) {
+			PROV_EMSG("BAD_STATE\n");
+			res = SS_ERROR_BAD_STATE;
+		} else {
+			contextID_ptr = &ss_ctx->crys_ctx;
+
+			switch ((int32_t)algo) {
+			case TEE_ALG_HMAC_MD5:
+				PROV_DMSG("algo=TEE_ALG_HMAC_MD5\n");
+				hmacResultLen = 16U;
+				break;
+			case TEE_ALG_HMAC_SHA1:
+				PROV_DMSG("algo=TEE_ALG_HMAC_SHA1\n");
+				hmacResultLen = 20U;
+				break;
+			case TEE_ALG_HMAC_SHA224:
+				PROV_DMSG("algo=TEE_ALG_HMAC_SHA224\n");
+				hmacResultLen = 28U;
+				break;
+			case TEE_ALG_HMAC_SHA256:
+				PROV_DMSG("algo=TEE_ALG_HMAC_SHA256\n");
+				hmacResultLen = 32U;
+				break;
+			case TEE_ALG_HMAC_SHA384:
+				PROV_DMSG("algo=TEE_ALG_HMAC_SHA384\n");
+				hmacResultLen = 48U;
+				break;
+			case TEE_ALG_HMAC_SHA512:
+				PROV_DMSG("algo=TEE_ALG_HMAC_SHA512\n");
+				hmacResultLen = 64U;
+				break;
+			default:
+				PROV_EMSG("NOT_SUPPORTED\n");
+				res = SS_ERROR_NOT_SUPPORTED;
+				break;
+			}
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		if (digest == NULL) {
+			PROV_EMSG("BAD_PARAMETERS(digest)\n");
+			res = SS_ERROR_BAD_PARAMETERS;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		if (digest_len < (size_t)hmacResultLen) {
+			PROV_EMSG("SHORT_BUFFER(hmacResultLen)\n");
+			res = SS_ERROR_SHORT_BUFFER;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		if(ss_ctx->restBufSize != 0U){
+			crys_res = CRYS_HMAC_Update(contextID_ptr,
+					ss_ctx->restBuf, ss_ctx->restBufSize);
+			ss_ctx->crys_error = crys_res;
+			res = ss_translate_error_crys2ss_hmac(crys_res);
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: CRYS_HMAC_Finish()\n");
+		crys_res = CRYS_HMAC_Finish(contextID_ptr, hmacResultBuff);
+		ss_ctx->crys_error = crys_res;
+		res = ss_translate_error_crys2ss_hmac(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+	if (res == SS_SUCCESS) {
+		(void)memcpy(digest, hmacResultBuff, hmacResultLen);
+	}
+
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Finalize state of AES-MAC algorithm.
+ *
+ * param[in]	*ctx		- Context to HMAC,AES-MAC algorithm.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*digest		- Pointer to the digest(MAC) data.
+ * param[out]	digest_len	- Digest(MAC) data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static SSError_t ss_aesmac_final(void *ctx, uint32_t algo, uint8_t *digest, size_t digest_len)
+{
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_AES_Context_t *ss_ctx;
+	CRYS_AESUserContext_t *contextID_ptr;
+	uint8_t *dataIn_ptr;
+        uint32_t dataInSize;
+
+	PROV_INMSG("START: ss_aesmac_final\n");
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_AES_Context_t *)ctx;
+	} else {
+		PROV_EMSG("BAD_PARAMETERS(ctx)\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+	if (res == SS_SUCCESS) {
+		if(digest_len < 16U) {
+			res = SS_ERROR_BAD_PARAMETERS;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		if (ss_ctx->crys_error != SS_SUCCESS) {
+			PROV_EMSG("BAD_STATE\n");
+			res = SS_ERROR_BAD_STATE;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		contextID_ptr = &ss_ctx->crys_ctx;
+		PROV_DMSG("CALL: CRYS_AES_Finish()\n");
+		if ((int32_t)algo == TEE_ALG_AES_CBC_MAC_PKCS5) {
+			(void)memset(ss_ctx->restBuf + ss_ctx->restBufSize,
+					(int32_t)ss_ctx->blockSize - (int32_t)ss_ctx->restBufSize,
+					ss_ctx->blockSize - ss_ctx->restBufSize);
+			dataIn_ptr = ss_ctx->restBuf;
+			dataInSize = ss_ctx->blockSize;
+		} else {
+			if(ss_ctx->restBufSize != 0U){
+				dataIn_ptr = ss_ctx->restBuf;
+				dataInSize = ss_ctx->restBufSize;
+			} else {
+				dataIn_ptr = NULL;
+				dataInSize = 0U;
+			}
+		}
+		crys_res = CRYS_AES_Finish(contextID_ptr, dataIn_ptr, dataInSize, digest);
+		ss_ctx->crys_error = crys_res;
+		res = ss_translate_error_crys2ss_aes(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+	}
+	PROV_OUTMSG("return res=0x%08x\n", res);
+	return res;
+}
+
+/*
+ * brief:	Finalize state of HMAC,AES-MAC algorithm.
+ *
+ * param[in]	*ctx		- Context to HMAC,AES-MAC algorithm.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*digest		- Pointer to the digest(MAC) data.
+ * param[out]	digest_len	- Digest(MAC) data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result mac_final(void *ctx, uint32_t algo, uint8_t *digest,
+		size_t digest_len)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+
+	PROV_INMSG("START: mac_final\n");
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_HMAC)
+	case TEE_ALG_HMAC_MD5:
+	case TEE_ALG_HMAC_SHA224:
+	case TEE_ALG_HMAC_SHA1:
+	case TEE_ALG_HMAC_SHA256:
+	case TEE_ALG_HMAC_SHA384:
+	case TEE_ALG_HMAC_SHA512:
+		PROV_DMSG("CALL: ss_hmac_final()\n");
+		res = ss_hmac_final(ctx, algo, digest, digest_len);
+		break;
+#endif
+#if defined(CFG_CRYPTO_CBC_MAC)
+	case TEE_ALG_AES_CBC_MAC_PKCS5:
+	case TEE_ALG_AES_CBC_MAC_NOPAD:
+		PROV_DMSG("CALL: ss_aesmac_final() algo=AES_MAC\n");
+		res = ss_aesmac_final(ctx, algo, digest, digest_len);
+		break;
+#endif
+#if defined(CFG_CRYPTO_CMAC)
+	case TEE_ALG_AES_CMAC:
+		PROV_DMSG("CALL: ss_aesmac_final() algo=CMAC\n");
+		res = ss_aesmac_final(ctx, algo, digest, digest_len);
+		break;
+#endif
+	case TEE_ALG_DES_CBC_MAC_NOPAD:
+	case TEE_ALG_DES_CBC_MAC_PKCS5:
+	case TEE_ALG_DES3_CBC_MAC_NOPAD:
+	case TEE_ALG_DES3_CBC_MAC_PKCS5:
+	default:
+		PROV_EMSG("NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+#endif /* _CFG_CRYPTO_WITH_MAC */
+
+/******************************************************************************
+ * Authenticated encryption
+ ******************************************************************************/
+
+#if defined(_CFG_CRYPTO_WITH_AUTHENC)
+#define TEE_CCM_NONCE_MAX_LENGTH	13U
+#define TEE_CCM_NONCE_MIN_LENGTH	7U
+#define TEE_CCM_TAG_MAX_LENGTH		16U
+#define TEE_CCM_TAG_MIN_LENGTH		4U
+#define TEE_xCM_TAG_MAX_LENGTH		16U
+
+/*
+ * brief:	Get context size to AESCCM algorithm.
+ *
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[out]	*size		- Size of context to AESCCM algorithm.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result authenc_get_ctx_size(uint32_t algo, size_t *size)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	PROV_INMSG("START: authenc_get_ctx_size\n");
+
+	switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_CCM)
+	case TEE_ALG_AES_CCM:
+		PROV_DMSG("ctx_size=sizeof(SS_AESCCM_Context_t)\n");
+		*size = sizeof(SS_AESCCM_Context_t);
+		break;
+#endif
+#if defined(CFG_CRYPTO_GCM)
+	case TEE_ALG_AES_GCM:
+#endif
+	default:
+		PROV_EMSG("NOT_SUPPORTED\n");
+		res = SS_ERROR_NOT_SUPPORTED;
+		break;
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Initialize state of AESCCM algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AESCCM contest.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	mode		- Operation Mode (Encrypt or Decrypt).
+ * param[in]	*key		- Pinter to the AES key.
+ * param[in]	key_len		- AES key size.
+ * param[in]	*nonce		- Pinter to the nonce data.
+ * param[in]	nonce_len	- nonce data size.
+ * param[in]	tag_len		- Tag data size.
+ * param[in]	aad_len		- Add data size.
+ * param[in]	payload_len	- Payload data size.
+ * return	SSError_t	- SS provider error code.
+ */
+static TEE_Result authenc_init(void *ctx, uint32_t algo, TEE_OperationMode mode,
+		const uint8_t *key, size_t key_len, const uint8_t *nonce,
+		size_t nonce_len, size_t tag_len, size_t aad_len,
+		size_t payload_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_AESCCM_Context_t *ss_ctx;
+	CRYS_AESCCM_UserContext_t *contextID_ptr;
+	CRYS_AES_EncryptMode_t encrDecrMode;
+	CRYS_AESCCM_Key_t ccmkey;
+	CRYS_AESCCM_KeySize_t ccmkeySize;
+	uint32_t ddataSize;
+	uint32_t textSize;
+	uint8_t *n_ptr;
+	uint8_t sizeOfN;
+	uint8_t sizeOfT;
+
+	PROV_INMSG("START: authenc_init\n");
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_AESCCM_Context_t *)ctx;
+		(void)memset(ss_ctx,0,sizeof(SS_AESCCM_Context_t));
+		ss_ctx->crys_error = SS_SUCCESS;
+		ss_ctx->blockSize = 16U;
+		ss_ctx->restBufSize = 0U;
+		ss_ctx->tagSize = tag_len;
+		contextID_ptr = &ss_ctx->crys_ctx;
+	} else {
+		PROV_EMSG("BAD_PARAMETERS(ctx)\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		contextID_ptr = &ss_ctx->crys_ctx;
+		ddataSize = (uint32_t)aad_len;
+		textSize = (uint32_t)payload_len;
+		n_ptr = (uint8_t *)nonce;
+		sizeOfN = (uint8_t)nonce_len;
+		sizeOfT = (uint8_t)tag_len;
+
+		switch (mode) {
+		case TEE_MODE_ENCRYPT:
+			PROV_DMSG("mode=TEE_MODE_ENCRYPT\n");
+			encrDecrMode = CRYS_AES_Encrypt;
+			break;
+		case TEE_MODE_DECRYPT:
+			PROV_DMSG("mode=TEE_MODE_DECRYPT\n");
+			encrDecrMode = CRYS_AES_Decrypt;
+			break;
+		default:
+			PROV_EMSG("BAD_PARAMETERS(mode)\n");
+			encrDecrMode = CRYS_AES_EncryptModeLast;
+			res = SS_ERROR_BAD_PARAMETERS;
+			break;
+		}
+	}
+
+	if ((res == SS_SUCCESS) && (key == NULL)) {
+		PROV_EMSG("BAD_PARAMETERS(key)\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		switch (key_len) {
+		case 16U:
+			PROV_DMSG("key_len=128 bit\n");
+			ccmkeySize = CRYS_AES_Key128BitSize;
+			break;
+		case 24U:
+			PROV_DMSG("key_len=192 bit\n");
+			ccmkeySize = CRYS_AES_Key192BitSize;
+			break;
+		case 32U:
+			PROV_DMSG("key_len=256 bit\n");
+			ccmkeySize = CRYS_AES_Key256BitSize;
+			break;
+		default:
+			PROV_EMSG("BAD_PARAMETERS(key_len)\n");
+			ccmkeySize = CRYS_AES_KeySizeLast;
+			res = SS_ERROR_BAD_PARAMETERS;
+			break;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		(void)memcpy(ccmkey, key, key_len);
+		switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_CCM)
+		case TEE_ALG_AES_CCM:
+			PROV_DMSG("algo=TEE_ALG_AES_CCM\n");
+			if ((nonce_len > TEE_CCM_NONCE_MAX_LENGTH)
+					|| (nonce_len < TEE_CCM_NONCE_MIN_LENGTH)) {
+				PROV_EMSG("BAD_PARAMETERS(nonce_len)\n");
+				res = SS_ERROR_BAD_PARAMETERS;
+			}
+			if ((sizeOfT > TEE_CCM_TAG_MAX_LENGTH)
+					|| (sizeOfT < TEE_CCM_TAG_MIN_LENGTH)) {
+				PROV_EMSG("BAD_PARAMETERS(sizeOfT) size\n");
+				res = SS_ERROR_BAD_PARAMETERS;
+			}
+			if ((sizeOfT & 0x01U) == 1U) {
+				PROV_EMSG("BAD_PARAMETERS(sizeOfT) even\n");
+				res = SS_ERROR_BAD_PARAMETERS;
+			}
+			if (res == SS_SUCCESS) {
+				PROV_DMSG("CALL: CRYS_AESCCM_Init()\n");
+				crys_res = CRYS_AESCCM_Init(contextID_ptr,
+						encrDecrMode, ccmkey,
+						ccmkeySize, ddataSize, textSize,
+						n_ptr, sizeOfN, sizeOfT);
+				ss_ctx->crys_error = crys_res;
+				res = ss_translate_error_crys2ss_ccm(crys_res);
+				PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+			}
+			break;
+#endif
+#if defined(CFG_CRYPTO_GCM)
+		case TEE_ALG_AES_GCM:
+#endif
+		default:
+			PROV_EMSG("NOT_SUPPORTED\n");
+			res = SS_ERROR_NOT_SUPPORTED;
+			break;
+		}
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Block Add Data Update state of AESCCM algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AESCCM context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*data		- Pointer to source data buffer.
+ * param[in]	len		- Source data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result authenc_update_aad(void *ctx, uint32_t algo,
+		TEE_OperationMode mode __unused, const uint8_t *data,
+		size_t len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	SS_AESCCM_Context_t *ss_ctx;
+	CRYS_AESCCM_UserContext_t *contextID_ptr;
+	uint8_t *dataIn_ptr;
+	uint32_t dataInSize;
+
+	PROV_INMSG("START: authenc_update_aad\n");
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_AESCCM_Context_t *)ctx;
+	} else {
+		PROV_EMSG("BAD_PARAMETERS(ctx)\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		if (ss_ctx->crys_error != SS_SUCCESS) {
+			PROV_EMSG("BAD_STATE\n");
+			res = SS_ERROR_BAD_STATE;
+		} else {
+			contextID_ptr = &ss_ctx->crys_ctx;
+			dataIn_ptr = (uint8_t *)data;
+			dataInSize = (uint32_t)len;
+
+			switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_CCM)
+			case TEE_ALG_AES_CCM:
+				PROV_DMSG("algo=TEE_ALG_AES_CCM\n");
+				PROV_DMSG("CALL: CRYS_AESCCM_BlockAdata()\n");
+				crys_res = CRYS_AESCCM_BlockAdata(contextID_ptr,
+						dataIn_ptr, dataInSize);
+				ss_ctx->crys_error = crys_res;
+				res = ss_translate_error_crys2ss_ccm(crys_res);
+				PROV_DMSG("Result: crys_res=0x%08x\n", crys_res);
+				break;
+#endif
+#if defined(CFG_CRYPTO_GCM)
+			case TEE_ALG_AES_GCM:
+#endif
+			default:
+				PROV_EMSG("BAD_PARAMETERS(ctx)\n");
+				res = SS_ERROR_NOT_SUPPORTED;
+				break;
+			}
+		}
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Block Payload Data Update state of AESCCM algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AESCCM context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*src_data	- Pointer to source data buffer.
+ * param[in]	src_len		- Source data size.
+ * param[in]	*dst_data	- Pointer to destination data buffer.
+ * param[in]	dst_len		- Destination data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result authenc_update_payload(void *ctx, uint32_t algo,
+		TEE_OperationMode mode __unused, const uint8_t *src_data,
+		size_t src_len, uint8_t *dst_data, size_t *dst_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	SS_AESCCM_Context_t *ss_ctx;
+
+	PROV_INMSG("START: authenc_update_payload\n");
+
+	CHECK_CONTEXT(res, ss_ctx, SS_AESCCM_Context_t, ctx);
+
+	if (SS_SUCCESS == res) {
+		if ((MAX_DATAIN_CCM_SIZE < src_len)
+				|| ((src_len % 16U) != 0U)) {
+			res = SS_ERROR_BAD_PARAMETERS;
+			PROV_EMSG("BAD_PARAMETERS src_len=%ld\n", src_len);
+		}
+
+	}
+
+	if (SS_SUCCESS == res) {
+		if (*dst_len < src_len) {
+			res = SS_ERROR_SHORT_BUFFER;
+			PROV_EMSG("SHORT_BUFFER src_len=%ld dst_len=%ld\n",
+					src_len, *dst_len);
+		}
+	}
+
+	if (SS_SUCCESS == res) {
+		switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_CCM)
+		case TEE_ALG_AES_CCM:
+			PROV_DMSG("ctx=%p algo=0x%08x\n", ctx, algo);
+			PROV_DMSG("src_data=%p dst_len=%ld dst_data=%p\n",
+					src_data, src_len, dst_data);
+			res = ss_buffer_update(ctx, algo, src_data,
+					src_len, &dst_data);
+			if(SS_SUCCESS == res){
+				*dst_len = src_len;
+			}
+			break;
+#endif
+#if defined(CFG_CRYPTO_GCM)
+		case TEE_ALG_AES_GCM:
+#endif
+		default:
+			res = SS_ERROR_NOT_SUPPORTED;
+			PROV_EMSG("BAD_PARAMETERS(algo)\n");
+			break;
+		}
+	}
+
+	/* dst_len not used for SS provider*/
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Finalize state (Encrypt) of AESCCM algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AESCCM context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*src_data	- Pointer to source data buffer.
+ * param[in]	src_len		- Source data size.
+ * param[out]	*dst_data	- Pointer to destination data buffer.
+ * param[out]	*dst_tag	- Pointer to tag data buffer.
+ * param[out]	dst_tag_len	- Tag data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result authenc_enc_final(void *ctx, uint32_t algo,
+		const uint8_t *src_data, size_t src_len, uint8_t *dst_data,
+		size_t *dst_len __unused, uint8_t *dst_tag, size_t *dst_tag_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+
+	SS_AESCCM_Context_t *ss_ctx;
+	CRYS_AESCCM_UserContext_t *contextID_ptr;
+	uint8_t *dataIn_ptr;
+	uint32_t dataInSize;
+	uint8_t *dataOut_ptr;
+	CRYS_AESCCM_Mac_Res_t macRes = {0U};
+	uint8_t sizeOfT;
+
+	PROV_INMSG("START: authenc_enc_final\n");
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_AESCCM_Context_t *)ctx;
+	} else {
+		PROV_EMSG("BAD_PARAMETERS(ctx)\n");
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+
+	if (res == SS_SUCCESS) {
+		if (ss_ctx->crys_error != SS_SUCCESS) {
+			res = SS_ERROR_BAD_STATE;
+			PROV_EMSG("BAD_STATE\n");
+		} else {
+			contextID_ptr = &ss_ctx->crys_ctx;
+			dataIn_ptr = (uint8_t *)src_data;
+			dataInSize = (uint32_t)src_len;
+			dataOut_ptr = (uint8_t *)dst_data;
+			sizeOfT = (uint8_t)*dst_tag_len;
+			/* Check the tag length */
+			if (sizeOfT < ss_ctx->tagSize) {
+				*dst_tag_len = ss_ctx->tagSize;
+				res = SS_ERROR_SHORT_BUFFER;
+				PROV_EMSG("ERROR:SHORT_BUFFER(sizeOfT)\n");
+			}
+		}
+	}
+	if (res == SS_SUCCESS) {
+		switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_CCM)
+		case TEE_ALG_AES_CCM:
+			PROV_DMSG("algo=TEE_ALG_AES_CCM\n");
+			/* Compute the tag */
+			PROV_DMSG("CALL: CRYS_AESCCM_Finish()\n");
+			crys_res = CRYS_AESCCM_Finish(contextID_ptr, dataIn_ptr,
+					dataInSize, dataOut_ptr, macRes,
+					&sizeOfT);
+			ss_ctx->crys_error = crys_res;
+			res = ss_translate_error_crys2ss_ccm(crys_res);
+			PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+
+			break;
+#endif
+#if defined(CFG_CRYPTO_GCM)
+		case TEE_ALG_AES_GCM:
+#endif
+		default:
+			res = SS_ERROR_NOT_SUPPORTED;
+			PROV_EMSG("NOT_SUPPORTED\n");
+			break;
+		}
+	}
+
+	if (res == SS_SUCCESS) {
+		*dst_len = dataInSize;
+		*dst_tag_len = sizeOfT;
+		(void)memcpy(dst_tag, macRes, (size_t)sizeOfT);
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Finalize state (Decrypt) of AESCCM algorithm.
+ *
+ * param[in]	*ctx		- Pointer to the AESCCM context.
+ * param[in]	algo		- Cryptographic algorithm.
+ * param[in]	*src_data	- Pointer to source data buffer.
+ * param[in]	src_len		- Source data size.
+ * param[out]	*dst_data	- Pointer to destination data buffer.
+ * param[in]	*tag		- Pointer to tag data buffer.
+ * param[in]	tag_len		- Tag data size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result authenc_dec_final(void *ctx, uint32_t algo,
+		const uint8_t *src_data, size_t src_len, uint8_t *dst_data,
+		size_t *dst_len __unused, const uint8_t *tag, size_t tag_len)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+
+	SS_AESCCM_Context_t *ss_ctx;
+	CRYS_AESCCM_UserContext_t *contextID_ptr;
+	uint8_t *dataIn_ptr;
+	uint32_t dataInSize;
+	uint8_t *dataOut_ptr;
+	CRYS_AESCCM_Mac_Res_t macRes = {0U};
+	uint8_t sizeOfT;
+
+	PROV_INMSG("START: authenc_dec_final\n");
+
+	if (ctx != NULL) {
+		ss_ctx = (SS_AESCCM_Context_t *)ctx;
+	} else {
+		res = SS_ERROR_BAD_PARAMETERS;
+		PROV_EMSG("BAD_PARAMETERS(ctx)\n");
+	}
+
+	if (res == SS_SUCCESS) {
+		if (ss_ctx->crys_error != SS_SUCCESS) {
+			res = SS_ERROR_BAD_STATE;
+			PROV_EMSG("BAD_STATE\n");
+
+		} else {
+			contextID_ptr = &ss_ctx->crys_ctx;
+			dataIn_ptr = (uint8_t *)src_data;
+			dataInSize = (uint32_t)src_len;
+			dataOut_ptr = (uint8_t *)dst_data;
+			sizeOfT = (uint8_t)tag_len;
+			if (sizeOfT == 0U) {
+				res = SS_ERROR_SHORT_BUFFER;
+				PROV_EMSG("ERROR:SHORT_BUFFER(sizeOfT)\n");
+			}
+		}
+	}
+	if (res == SS_SUCCESS) {
+		if (sizeOfT > (uint8_t) TEE_xCM_TAG_MAX_LENGTH) {
+			res = SS_ERROR_BAD_PARAMETERS;
+			PROV_EMSG("BAD_PARAMETERS(sizeOfT)\n");
+		} else {
+			(void)memcpy(macRes, tag, sizeOfT);
+		}
+	}
+	if (res == SS_SUCCESS) {
+		switch ((int32_t)algo) {
+#if defined(CFG_CRYPTO_CCM)
+		case TEE_ALG_AES_CCM:
+
+			crys_res = CRYS_AESCCM_Finish(contextID_ptr, dataIn_ptr,
+					dataInSize, dataOut_ptr, macRes,
+					&sizeOfT);
+			ss_ctx->crys_error = crys_res;
+			res = ss_translate_error_crys2ss_ccm(crys_res);
+			PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",crys_res,res);
+			if (res == SS_SUCCESS) {
+				*dst_len = dataInSize;
+			}
+			break;
+#endif
+#if defined(CFG_CRYPTO_GCM)
+		case TEE_ALG_AES_GCM:
+#endif
+		default:
+			res = SS_ERROR_NOT_SUPPORTED;
+			PROV_EMSG("BAD_PARAMETERS(algo)\n");
+			break;
+		}
+	}
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	In case of SS provider, this function do nothing.
+ * return	void
+ */
+static void authenc_final(void *ctx __unused, uint32_t algo __unused)
+{
+	PROV_INMSG("START: authenc_final (do nothing)\n");
+	return;
+}
+#endif /* _CFG_CRYPTO_WITH_AUTHENC */
+
+/******************************************************************************
+ * Pseudo Random Number Generator
+ ******************************************************************************/
+
+/*
+ * brief:	Generate a random number.
+ *
+ * param[in]	*buf		- Pointer to the memory block to output data buffer.
+ * param[in]	blen		- Size of Output data buffer you want.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result prng_read(void *buf, size_t blen)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_RND_WorkBuff_t *rndWorkBuff;
+	uint16_t outSizeBytes;
+	uint8_t *out_ptr;
+
+	PROV_INMSG("START: prng_read\n");
+
+	out_ptr = (uint8_t *)buf;
+	outSizeBytes = (uint16_t)blen;
+	rndWorkBuff = (CRYS_RND_WorkBuff_t *)ss_malloc(
+			sizeof(CRYS_RND_WorkBuff_t), &res);
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: CRYS_RND_Instantiation()\n");
+		crys_res = CRYS_RND_Instantiation(rndWorkBuff);
+		res = ss_translate_error_crys2ss_rnd(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",
+				crys_res, res);
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: CRYS_RND_GenerateVector()\n");
+		crys_res = CRYS_RND_GenerateVector(outSizeBytes, out_ptr);
+		res = ss_translate_error_crys2ss_rnd(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",
+				crys_res, res);
+	}
+
+	ss_free((void *)rndWorkBuff);
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n", res, tee_res);
+	return tee_res;
+}
+
+
+
+/*
+ * brief:	Generate a random number (SHE).
+ *
+ * param[in]	*buf		- Pointer to the memory block to output data buffer.
+ * param[in]	blen		- Size of Output data buffer you want.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result prng_read_without_init(void *buf, size_t blen)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+	CRYSError_t crys_res;
+	uint16_t outSizeBytes;
+	uint8_t *out_ptr;
+
+	PROV_INMSG("START: prng_read\n");
+
+	out_ptr = (uint8_t *)buf;
+	outSizeBytes = (uint16_t)blen;
+
+	PROV_DMSG("CALL: CRYS_RND_GenerateVector()\n");
+	crys_res = CRYS_RND_GenerateVector(outSizeBytes, out_ptr);
+	res = ss_translate_error_crys2ss_rnd(crys_res);
+	PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n", crys_res, res);
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n", res, tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Add entropy for PRNG.
+ *
+ * param[in]	*inbuf		- Pointer to the entropy data buffer.
+ * param[in]	len		- Size of entropy data.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result prng_add_entropy(const uint8_t *inbuf, size_t len)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+	CRYSError_t crys_res;
+	uint8_t *addInput_ptr;
+	uint16_t addInputSizeBytes;
+
+	PROV_INMSG("START: prng_add_entropy\n");
+
+	addInput_ptr = (uint8_t *)inbuf;
+	addInputSizeBytes = (uint16_t)len;
+
+	PROV_DMSG("CALL: CRYS_RND_AddAdditionalInput()\n");
+	crys_res = CRYS_RND_AddAdditionalInput(addInput_ptr, addInputSizeBytes);
+	res = ss_translate_error_crys2ss_rnd(crys_res);
+	PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n", crys_res, res);
+
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n", res, tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	Initialize the random number generato.
+ *
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result prng_init(void)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_RND_WorkBuff_t *rndWorkBuff;
+
+	PROV_INMSG("START: prng_init\n");
+
+	rndWorkBuff = (CRYS_RND_WorkBuff_t *)ss_malloc(
+			sizeof(CRYS_RND_WorkBuff_t), &res);
+
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("CALL: CRYS_RND_Instantiation()\n");
+		crys_res = CRYS_RND_Instantiation(rndWorkBuff);
+		res = ss_translate_error_crys2ss_rnd(crys_res);
+		PROV_DMSG("Result: crys_res=0x%08x -> res=0x%08x\n",
+				crys_res, 	res);
+	}
+	ss_free(rndWorkBuff);
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",
+			res, tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	This function enables derivation of 128 bit customer keys
+ * 		by performing AES CMAC on customer input.
+ *
+ * param[in]	keyType		- Input keyType 0:SESSION_KEY 1:KDR_KEY.
+ * param[in]	*in		- Input buffer address to make MAC.
+ * param[in]	inSize		- Size of Input buffer address.
+ * param[in]	out		- Output buffer address to get result.
+ * param[in]	outSize		- Size of Output buffer address.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_cmac_derivekey(uint32_t keyType, uint8_t *in,
+		uint32_t inSize, uint8_t *out, uint32_t outSize)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	DxUTILError_t util_res;
+	DX_UTIL_KeyType_t aesKeyType;
+	uint8_t *pDataIn;
+	uint32_t dataInSize;
+	DX_UTIL_AES_CmacResult_t pCmacResult;
+
+	pDataIn = in;
+	dataInSize = inSize;
+
+	switch (keyType) {
+	case 0U:
+		aesKeyType = DX_UTIL_SESSION_KEY;
+		break;
+	case 1U:
+		aesKeyType = DX_UTIL_KDR_KEY;
+		break;
+	default:
+		res = SS_ERROR_BAD_PARAMETERS;
+		break;
+	}
+
+	if (res == SS_SUCCESS) {
+		if (out == NULL) {
+			res = SS_ERROR_BAD_PARAMETERS;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		if (outSize < 16U) {
+			res = SS_ERROR_BAD_PARAMETERS;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		util_res = DX_UTIL_CmacDeriveKey(aesKeyType, pDataIn,
+				dataInSize, pCmacResult);
+		res = ss_translate_error_crys2ss_util(util_res);
+	}
+	if (res == SS_SUCCESS) {
+		(void)memcpy(out, pCmacResult,
+				sizeof(DX_UTIL_AES_CmacResult_t));
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n", res, tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	This function gets RPMB key.
+ * param[out]	out		- Pointer to 32byte output, to be used as RPMB key.
+ * param[out]	outSize		- Size of Output buffer size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_rpmb_derivekey(uint8_t *out, uint32_t outSize)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	DxUTILError_t util_res;
+	DxUtilRpmbKey_t pCmacResult;
+	uint32_t rpmbKeySize;
+
+	rpmbKeySize = sizeof(DxUtilRpmbKey_t);
+	if (out == NULL) {
+		PROV_EMSG("But Parameters in=%p",in);
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+	if (res == SS_SUCCESS) {
+		if (outSize < rpmbKeySize) {
+			PROV_EMSG("Short Buffer outSize=%d rpmbKeySize=%d",
+					outSize, rpmbKeySize);
+			res = SS_ERROR_SHORT_BUFFER;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("DX_UTIL_SignRPMBFrames() pCmacResult=%p\n",pCmacResult);
+		util_res = DX_UTIL_DeriveRPMBKey(pCmacResult);
+		PROV_DHEXDUMP(pHmacResult, hmacSize);
+		res = ss_translate_error_crys2ss_util(util_res);
+		PROV_DMSG("return util_res=0x%08x -> res=0x%08x\n", res,
+				tee_res);
+	}
+	if (res == SS_SUCCESS) {
+		(void)memcpy(out, pCmacResult, rpmbKeySize);
+		PROV_DHEXDUMP(out, hmacSize);
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n", res, tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	This function gets RPMB sign frames.
+ * param[out]	pListOfDataFrames		- Pointer to a list of 284 Byte frame addresses.
+ *                        The entire frame list will be signed.
+ * param[out]	listSize		- The number of 284 Byte frames in the list, up to 65,535.
+ * param[out]	out		- Pointer to the output data (HMAC result).
+ * param[out]	outSize		- Size of Output buffer size.
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result do_rpmb_signframes(uint64_t *in, uint32_t listSize,
+		uint8_t *out, uint32_t outSize)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	DxUTILError_t util_res;
+	DxUtilHmacResult_t pHmacResult;
+	uint32_t hmacSize;
+
+	PROV_INMSG("in=%p listSize=%d out=%p outSize=%d\n", in, listSize, out,
+			outSize);
+	hmacSize = (uint32_t)DX_UTIL_HMAC_SHA256_DIGEST_SIZE_IN_WORDS
+			* sizeof(uint32_t);
+	if (in == NULL) {
+		PROV_EMSG("But Parameters in=%p",in);
+		res = SS_ERROR_BAD_PARAMETERS;
+	}
+	if (res == SS_SUCCESS) {
+		if (out == NULL) {
+			PROV_EMSG("But Parameters out=%p",out);
+			res = SS_ERROR_BAD_PARAMETERS;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		if (outSize < hmacSize) {
+			PROV_EMSG("Short Buffer outSize=%d hmacSize=%d",
+					outSize, hmacSize);
+			res = SS_ERROR_SHORT_BUFFER;
+		}
+	}
+	if (res == SS_SUCCESS) {
+		PROV_DMSG("DX_UTIL_SignRPMBFrames()\n");
+		PROV_DMSG("in=%p listSize=%d pHmacResult=%p\n", in, listSize,
+				pHmacResult);
+		util_res = DX_UTIL_SignRPMBFrames((unsigned long *)in, listSize,
+				pHmacResult);
+		PROV_DHEXDUMP(pHmacResult, hmacSize);
+		res = ss_translate_error_crys2ss_util(util_res);
+		PROV_DMSG("return util_res=0x%08x -> res=0x%08x\n", res,
+				tee_res);
+	}
+	if (res == SS_SUCCESS) {
+		(void)memcpy(out, pHmacResult, hmacSize);
+		PROV_DHEXDUMP(out, hmacSize);
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n", res, tee_res);
+	return tee_res;
+}
+
+/*
+ * brief:	This function provides AES unwrap for a user key or OEM key.
+ *
+ * param[in]	 *srcData	- Input buffer address to make MAC.
+ * param[in]	 srcLen		- Size of Input buffer address.
+ * param[in]	 *keyData	- Key data address.
+ * param[in]	 keySize	- Key data size.
+ * param[in]	 isSecretKey	- Input keyType 0:User key 1:OEM key.
+ * param[out]	 *destData	- Output buffer address to get result.
+ * param[in/out] *dstLen	- Size of Output buffer address.
+ * return	 TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result cipher_unwrap(void *srcData, uint32_t srcLen,
+		const void *keyData, uint32_t keySize, uint32_t isSecretKey,
+		void *destData, uint32_t *dstLen)
+{
+	TEE_Result tee_res;
+	SSError_t res = SS_SUCCESS;
+	CRYSError_t crys_res;
+	CRYS_AES_Key_t unwrapKey;
+	CRYS_AES_KeySize_t keySizeNum = CRYS_AES_KeySizeLast;
+	uint32_t dataOutLen;
+
+	dataOutLen = *dstLen;
+	if (0U == isSecretKey) {
+		switch (keySize) {
+		case 16U:
+			PROV_DMSG("KeySize=128Bit\n");
+			keySizeNum = CRYS_AES_Key128BitSize;
+			break;
+		case 24U:
+			PROV_DMSG("KeySize=192Bit\n");
+			keySizeNum = CRYS_AES_Key192BitSize;
+			break;
+		case 32U:
+			PROV_DMSG("KeySize=256Bit\n");
+			keySizeNum = CRYS_AES_Key256BitSize;
+			break;
+		default:
+			PROV_EMSG("Error keySize=%d\n", keySize);
+			res = SS_ERROR_BAD_PARAMETERS;
+			break;
+		}
+		if (SS_SUCCESS == res) {
+			if (NULL != keyData) {
+				(void)memcpy(unwrapKey, keyData, keySize);
+			}
+		}
+	}
+	if (SS_SUCCESS == res) {
+		PROV_DMSG("Call CRYS_AESUNWRAP() dataOutLen=%d\n", dataOutLen);
+		crys_res = CRYS_AESUNWRAP((uint8_t *)srcData, srcLen, unwrapKey,
+				keySizeNum, isSecretKey, (uint8_t *)destData,
+				&dataOutLen);
+		PROV_DMSG("End  CRYS_AESUNWRAP() dataOutLen=%d\n", dataOutLen);
+		PROV_DMSG("tee_res=0x%08x res=0x%08x\n", tee_res, res);
+		res = ss_translate_error_crys2ss_aes(crys_res);
+	}
+	if (SS_SUCCESS == res) {
+		*dstLen = dataOutLen;
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_DMSG("tee_res=0x%08x res=0x%08x\n", tee_res, res);
+	return tee_res;
+}
+
+#define LTC_MAX_BITS_PER_VARIABLE   (4096U)
+#define LTC_VARIABLE_NUMBER         (50U)
+static uint32_t _ltc_mempool_u32[mpa_scratch_mem_size_in_U32(
+	LTC_VARIABLE_NUMBER, LTC_MAX_BITS_PER_VARIABLE)];
+static void tee_ltc_alloc_mpa(void)
+{
+	mpa_scratch_mem mem_pool = (void *)_ltc_mempool_u32;
+
+	init_mpa_tomcrypt(mem_pool);
+	mpa_init_scratch_mem(mem_pool, sizeof(_ltc_mempool_u32),
+			     LTC_MAX_BITS_PER_VARIABLE);
+
+	mpa_set_random_generator(crypto_ops.prng.read);
+}
+
+/*
+ * brief:	Initialize of Crypto Engine Secure and PKA engines.
+ *
+ * return	TEE_Result	- TEE internal API error code.
+ */
+static TEE_Result tee_ss_init(void)
+{
+	TEE_Result tee_res;
+	SSError_t res;
+	DX_CclibRetCode_t crys_res;
+	DxUTILError_t util_res;
+	PROV_INMSG("START tee_ss_init\n");
+	crys_res = DX_CclibInit();
+	res = ss_translate_error_crys2ss_init(crys_res);
+	PROV_DMSG("crys_res=0x%08x -> res=0x%08x \n",crys_res,res);
+	if (res == SS_SUCCESS) {
+		util_res = DX_UTIL_SetSessionKey();
+		res = ss_translate_error_crys2ss_util(util_res);
+	}
+#if defined(CFG_CRYPT_ENABLE_CEPKA)
+	if (res == SS_SUCCESS) {
+		res = pka_verify_init();
+	}
+#endif
+	if (res == SS_SUCCESS) {
+		tee_ltc_alloc_mpa();
+	}
+	tee_res = ss_translate_error_ss2tee(res);
+	PROV_OUTMSG("return res=0x%08x -> tee_res=0x%08x\n",res,tee_res);
+
+	return tee_res;
+}
+
+const struct crypto_ops crypto_ops = {
+	.name = "Crypto Engine Secure/PKA provider",
+	.init = &tee_ss_init,
+#if defined(_CFG_CRYPTO_WITH_HASH)
+	.hash = {
+		.get_ctx_size = &hash_get_ctx_size,
+		.init = &hash_init,
+		.update = &hash_update,
+		.final = &hash_final,
+	},
+#endif
+#if defined(_CFG_CRYPTO_WITH_CIPHER)
+	.cipher = {
+		.get_ctx_size = &cipher_get_ctx_size,
+		.init = &cipher_init,
+		.update = &cipher_update,
+		.final = &cipher_final,
+		.get_block_size = &cipher_get_block_size,
+		.unwrap = &cipher_unwrap,
+	},
+#endif
+#if defined(_CFG_CRYPTO_WITH_MAC)
+	.mac = {
+		.get_ctx_size = &mac_get_ctx_size,
+		.init = &mac_init,
+		.update = &mac_update,
+		.final = &mac_final,
+	},
+#endif
+#if defined(_CFG_CRYPTO_WITH_AUTHENC)
+	.authenc = {
+		.get_ctx_size = &authenc_get_ctx_size,
+		.init = &authenc_init,
+		.update_aad = &authenc_update_aad,
+		.update_payload = &authenc_update_payload,
+		.enc_final = &authenc_enc_final,
+		.dec_final = &authenc_dec_final,
+		.final = &authenc_final,
+	},
+#endif
+#if defined(_CFG_CRYPTO_WITH_ACIPHER)
+	.acipher = {
+#if defined(CFG_CRYPTO_RSA)
+		.alloc_rsa_keypair = &do_alloc_rsa_keypair,
+		.alloc_rsa_public_key = &do_alloc_rsa_public_key,
+		.free_rsa_public_key = &free_rsa_public_key,
+		.gen_rsa_key = &do_gen_rsa_key,
+		.rsaes_decrypt = &do_rsaes_decrypt,
+		.rsaes_encrypt = &do_rsaes_encrypt,
+		.rsanopad_decrypt = &do_rsanopad_decrypt,
+		.rsanopad_encrypt = &do_rsanopad_encrypt,
+		.rsassa_sign = &do_rsassa_sign,
+		.rsassa_verify = &do_rsassa_verify,
+#endif
+#if defined(CFG_CRYPTO_DH)
+		.alloc_dh_keypair = &do_alloc_dh_keypair,
+		.gen_dh_key = &do_gen_dh_key,
+		.dh_shared_secret = &do_dh_shared_secret,
+#endif
+#if defined(CFG_CRYPTO_DSA)
+		/* DSA (DO NOT SUPPOTED) */
+		.alloc_dsa_keypair = &do_alloc_dsa_keypair,
+		.alloc_dsa_public_key = &do_alloc_dsa_public_key,
+		.gen_dsa_key = &do_gen_dsa_key,
+		.dsa_sign = &do_dsa_sign,
+		.dsa_verify = &do_dsa_verify,
+#endif
+#if defined(CFG_CRYPTO_ECC)
+		/* ECDSA and ECDH */
+		.alloc_ecc_keypair = &do_alloc_ecc_keypair,
+		.alloc_ecc_public_key = &do_alloc_ecc_public_key,
+		.gen_ecc_key = &do_gen_ecc_key,
+		.free_ecc_public_key = &free_ecc_public_key,
+
+		/* ECDSA only */
+		.ecc_sign = &do_ecc_sign,
+		.ecc_verify = &do_ecc_verify,
+		/* ECDH only */
+		.ecc_shared_secret = &do_ecc_shared_secret,
+#endif
+	},
+	.bignum = {
+		.allocate = &bn_allocate,
+		.bin2bn = &bn_bin2bn,
+		.num_bytes = &bn_num_bytes,
+		.bn2bin = &bn_bn2bin,
+		.copy = &bn_copy,
+		.free = &bn_free,
+		.clear = &bn_clear,
+		.num_bits = &bn_num_bits,
+		.compare = &bn_compare,
+	},
+#endif /* _CFG_CRYPTO_WITH_ACIPHER */
+	.prng = {
+		.add_entropy = &prng_add_entropy,
+		.read = &prng_read,
+		.read_without_init = &prng_read_without_init,
+		.init = &prng_init,
+	},
+	.util = {
+		.cmac_derivekey = &do_cmac_derivekey,
+		.rpmb_derivekey = &do_rpmb_derivekey,
+		.rpmb_signframes = &do_rpmb_signframes,
+	}
+};
diff --git a/core/tee/sub.mk b/core/tee/sub.mk
index 1a20c15..a3586ea 100644
--- a/core/tee/sub.mk
+++ b/core/tee/sub.mk
@@ -25,7 +25,7 @@ srcs-$(CFG_CRYPTO_PBKDF2) += tee_cryp_pbkdf2.c
 ifeq ($(CFG_WITH_USER_TA),y)
 
 srcs-y += tee_svc.c
-cppflags-tee_svc.c-y += -DTEE_IMPL_VERSION=$(TEE_IMPL_VERSION)
+cppflags-tee_svc.c-y += -DTEE_IMPL_VERSION='$(TEE_IMPL_VERSION)'
 srcs-y += tee_svc_cryp.c
 srcs-y += tee_svc_storage.c
 srcs-$(CFG_RPMB_FS) += tee_rpmb_fs.c
diff --git a/core/tee/tee_fs_key_manager.c b/core/tee/tee_fs_key_manager.c
index 7840d73..befd4b5 100644
--- a/core/tee/tee_fs_key_manager.c
+++ b/core/tee/tee_fs_key_manager.c
@@ -202,6 +202,9 @@ static TEE_Result do_auth_enc(TEE_OperationMode mode,
 	uint8_t *ctx = NULL;
 	size_t ctx_size;
 	size_t tag_len = TEE_FS_KM_MAX_TAG_LEN;
+#if defined(ENABLE_CRYPTOENGINE)
+	uint8_t key_iv[TEE_FS_KM_FEK_SIZE + TEE_FS_KM_IV_LEN];
+#endif
 
 	if ((mode != TEE_MODE_ENCRYPT) && (mode != TEE_MODE_DECRYPT))
 		return TEE_ERROR_BAD_PARAMETERS;
@@ -222,14 +225,32 @@ static TEE_Result do_auth_enc(TEE_OperationMode mode,
 		EMSG("request memory size %zu failed", ctx_size);
 		return TEE_ERROR_OUT_OF_MEMORY;
 	}
-
+#if defined(ENABLE_CRYPTOENGINE)
+	res = crypto_ops.authenc.init(ctx, TEE_FS_KM_AUTH_ENC_ALG,
+			mode, fek, fek_len, hdr->aad.iv,
+			TEE_FS_KM_IV_LEN, TEE_FS_KM_MAX_TAG_LEN,
+			sizeof(key_iv), in_size);
+#else
 	res = crypto_ops.authenc.init(ctx, TEE_FS_KM_AUTH_ENC_ALG,
 			mode, fek, fek_len, hdr->aad.iv,
 			TEE_FS_KM_IV_LEN, TEE_FS_KM_MAX_TAG_LEN,
 			sizeof(struct aad), in_size);
+#endif
 	if (res != TEE_SUCCESS)
 		goto exit;
 
+#if defined(ENABLE_CRYPTOENGINE)
+		(void)memcpy(&key_iv[0], hdr->aad.encrypted_key,
+				TEE_FS_KM_FEK_SIZE);
+		(void)memcpy(&key_iv[TEE_FS_KM_FEK_SIZE], hdr->aad.iv,
+				TEE_FS_KM_IV_LEN);
+
+		res = crypto_ops.authenc.update_aad(ctx, TEE_FS_KM_AUTH_ENC_ALG,
+				mode, &key_iv[0],
+				TEE_FS_KM_FEK_SIZE + TEE_FS_KM_IV_LEN);
+		if (res != TEE_SUCCESS)
+			goto exit;
+#else
 	res = crypto_ops.authenc.update_aad(ctx, TEE_FS_KM_AUTH_ENC_ALG,
 			mode, (uint8_t *)hdr->aad.encrypted_key,
 			TEE_FS_KM_FEK_SIZE);
@@ -241,6 +262,7 @@ static TEE_Result do_auth_enc(TEE_OperationMode mode,
 			TEE_FS_KM_IV_LEN);
 	if (res != TEE_SUCCESS)
 		goto exit;
+#endif
 
 	if (mode == TEE_MODE_ENCRYPT) {
 		res = crypto_ops.authenc.enc_final(ctx, TEE_FS_KM_AUTH_ENC_ALG,
diff --git a/core/tee/tee_ree_fs.c b/core/tee/tee_ree_fs.c
index 4455801..1e1d24f 100644
--- a/core/tee/tee_ree_fs.c
+++ b/core/tee/tee_ree_fs.c
@@ -1035,7 +1035,7 @@ static int read_block_from_storage(struct tee_fs_fd *fdp, struct block *b)
 	}
 
 	b->data_size = res;
-	DMSG("Successfully read block%d from storage, size=%d",
+	DMSG("Successfully read block%d from storage, size=%zu",
 		b->block_num, b->data_size);
 	res = 0;
 fail:
@@ -1065,7 +1065,7 @@ static int flush_block_to_storage(struct tee_fs_fd *fdp, struct block *b,
 			b->block_num, res);
 		goto fail;
 	}
-	DMSG("Successfully writen block%d to storage, size=%d",
+	DMSG("Successfully writen block%d to storage, size=%zu",
 		b->block_num, b->data_size);
 	res = 0;
 fail:
diff --git a/core/tee/tee_rpmb_fs.c b/core/tee/tee_rpmb_fs.c
index e7c0516..3f91140 100644
--- a/core/tee/tee_rpmb_fs.c
+++ b/core/tee/tee_rpmb_fs.c
@@ -63,6 +63,10 @@ struct tee_rpmb_fs_stat {
 	uint32_t reserved;
 };
 
+#if !defined(CFG_CRYPT_HW_CRYPTOENGINE) || (CFG_CRYPT_HW_CRYPTOENGINE == 0)
+#error "RPMB requires Crypto Engine."
+#endif
+
 /**
  * FS parameters: Information often used by internal functions.
  * fat_start_address will be set by rpmb_fs_setup().
@@ -314,6 +318,8 @@ out:
  * to return error code!
  */
 static TEE_Result tee_get_hw_unique_key(struct tee_hw_unique_key *hwkey)
+	__unused;
+static TEE_Result tee_get_hw_unique_key(struct tee_hw_unique_key *hwkey)
 {
 	if (!hwkey)
 		return TEE_ERROR_BAD_PARAMETERS;
@@ -326,41 +332,17 @@ static TEE_Result tee_get_hw_unique_key(struct tee_hw_unique_key *hwkey)
 static TEE_Result tee_rpmb_key_gen(uint16_t dev_id __unused,
 				   uint8_t *key, uint32_t len)
 {
-	TEE_Result res;
-	struct tee_hw_unique_key hwkey;
-	uint8_t *ctx = NULL;
+	TEE_Result res = TEE_SUCCESS;
 
 	if (!key || RPMB_KEY_MAC_SIZE != len) {
 		res = TEE_ERROR_BAD_PARAMETERS;
-		goto out;
 	}
 
-	IMSG("RPMB: Using generated key");
-	res = tee_get_hw_unique_key(&hwkey);
-	if (res != TEE_SUCCESS)
-		goto out;
-
-	ctx = malloc(rpmb_ctx->hash_ctx_size);
-	if (!ctx) {
-		res = TEE_ERROR_OUT_OF_MEMORY;
-		goto out;
+	if (res == TEE_SUCCESS) {
+		IMSG("RPMB: Using generated key");
+		res = crypto_ops.util.rpmb_derivekey(key, len);
 	}
-
-	res = crypto_ops.mac.init(ctx, TEE_ALG_HMAC_SHA256, hwkey.data,
-				  HW_UNIQUE_KEY_LENGTH);
-	if (res != TEE_SUCCESS)
-		goto out;
-
-	res = crypto_ops.mac.update(ctx, TEE_ALG_HMAC_SHA256,
-				    (uint8_t *)rpmb_ctx->cid,
-				    RPMB_EMMC_CID_SIZE);
-	if (res != TEE_SUCCESS)
-		goto out;
-
-	res = crypto_ops.mac.final(ctx, TEE_ALG_HMAC_SHA256, key, len);
-
-out:
-	free(ctx);
+	
 	return res;
 }
 
@@ -393,41 +375,34 @@ static void bytes_to_u16(uint8_t *bytes, uint16_t *u16)
 }
 
 static TEE_Result tee_rpmb_mac_calc(uint8_t *mac, uint32_t macsize,
-				    uint8_t *key, uint32_t keysize,
+				    uint8_t *key __unused,
+				    uint32_t keysize __unused,
 				    struct rpmb_data_frame *datafrms,
 				    uint16_t blkcnt)
 {
 	TEE_Result res = TEE_ERROR_GENERIC;
 	int i;
-	uint8_t *ctx = NULL;
+	size_t listsize;
+	uint64_t *listfrm = NULL;
 
-	if (!mac || !key || !datafrms)
+	if ((mac == NULL) || (datafrms == NULL) || (blkcnt == 0U)) {
 		return TEE_ERROR_BAD_PARAMETERS;
+	}
 
-	ctx = malloc(rpmb_ctx->hash_ctx_size);
-	if (!ctx)
-		return TEE_ERROR_OUT_OF_MEMORY;
+	listsize = sizeof(void *) * (size_t)blkcnt;
+	listfrm = malloc(listsize);
 
-	res = crypto_ops.mac.init(ctx, TEE_ALG_HMAC_SHA256, key, keysize);
-	if (res != TEE_SUCCESS)
-		goto func_exit;
+	if (listfrm == NULL) {
+		return TEE_ERROR_OUT_OF_MEMORY;
+	}
 
 	for (i = 0; i < blkcnt; i++) {
-		res = crypto_ops.mac.update(ctx, TEE_ALG_HMAC_SHA256,
-					  datafrms[i].data,
-					  RPMB_MAC_PROTECT_DATA_SIZE);
-		if (res != TEE_SUCCESS)
-			goto func_exit;
+		/* Add list */
+		listfrm[i] = (uint64_t)&datafrms[i].data;
 	}
+	res = crypto_ops.util.rpmb_signframes(listfrm, (uint32_t)blkcnt, mac, macsize);
 
-	res = crypto_ops.mac.final(ctx, TEE_ALG_HMAC_SHA256, mac, macsize);
-	if (res != TEE_SUCCESS)
-		goto func_exit;
-
-	res = TEE_SUCCESS;
-
-func_exit:
-	free(ctx);
+	free(listfrm);
 	return res;
 }
 
@@ -711,12 +686,13 @@ static TEE_Result tee_rpmb_data_cpy_mac_calc(struct rpmb_data_frame *datafrm,
 {
 	TEE_Result res = TEE_ERROR_GENERIC;
 	int i;
-	uint8_t *ctx = NULL;
 	uint16_t offset;
 	uint32_t size;
 	uint8_t *data;
 	uint16_t start_idx;
 	struct rpmb_data_frame localfrm;
+	size_t listsize;
+	uint64_t *listfrm = NULL;
 
 	if (!datafrm || !rawdata || !nbr_frms || !lastfrm)
 		return TEE_ERROR_BAD_PARAMETERS;
@@ -728,16 +704,12 @@ static TEE_Result tee_rpmb_data_cpy_mac_calc(struct rpmb_data_frame *datafrm,
 
 	data = rawdata->data;
 
-	ctx = malloc(rpmb_ctx->hash_ctx_size);
-	if (!ctx) {
-		res = TEE_ERROR_OUT_OF_MEMORY;
-		goto func_exit;
-	}
+	listsize = sizeof(void *) * (size_t)nbr_frms;
+	listfrm = malloc(listsize);
 
-	res = crypto_ops.mac.init(ctx, TEE_ALG_HMAC_SHA256, rpmb_ctx->key,
-				  RPMB_KEY_MAC_SIZE);
-	if (res != TEE_SUCCESS)
-		goto func_exit;
+	if (listfrm == NULL) {
+		return TEE_ERROR_OUT_OF_MEMORY;
+	}
 
 	/*
 	 * Note: JEDEC JESD84-B51: "In every packet the address is the start
@@ -755,11 +727,8 @@ static TEE_Result tee_rpmb_data_cpy_mac_calc(struct rpmb_data_frame *datafrm,
 		 */
 		memcpy(&localfrm, &datafrm[i], RPMB_DATA_FRAME_SIZE);
 
-		res = crypto_ops.mac.update(ctx, TEE_ALG_HMAC_SHA256,
-					    localfrm.data,
-					    RPMB_MAC_PROTECT_DATA_SIZE);
-		if (res != TEE_SUCCESS)
-			goto func_exit;
+		/* Add list */
+		listfrm[i] = (uint64_t)&datafrm[i].data;
 
 		if (i == 0) {
 			/* First block */
@@ -787,21 +756,14 @@ static TEE_Result tee_rpmb_data_cpy_mac_calc(struct rpmb_data_frame *datafrm,
 	if (res != TEE_SUCCESS)
 		goto func_exit;
 
-	/* Update MAC against the last block */
-	res = crypto_ops.mac.update(ctx, TEE_ALG_HMAC_SHA256, lastfrm->data,
-				    RPMB_MAC_PROTECT_DATA_SIZE);
-	if (res != TEE_SUCCESS)
-		goto func_exit;
-
-	res = crypto_ops.mac.final(ctx, TEE_ALG_HMAC_SHA256, rawdata->key_mac,
-				   RPMB_KEY_MAC_SIZE);
-	if (res != TEE_SUCCESS)
-		goto func_exit;
-
-	res = TEE_SUCCESS;
+	/* Add list against the last block */
+	listfrm[nbr_frms -1U] = (uint64_t)lastfrm->data;
+	res = crypto_ops.util.rpmb_signframes(listfrm, (uint32_t)nbr_frms,
+						rawdata->key_mac,
+						RPMB_KEY_MAC_SIZE);
 
 func_exit:
-	free(ctx);
+	free(listfrm);
 	return res;
 }
 
diff --git a/core/tee/tee_svc_cryp.c b/core/tee/tee_svc_cryp.c
index 8bf798c..7ba70f1 100644
--- a/core/tee/tee_svc_cryp.c
+++ b/core/tee/tee_svc_cryp.c
@@ -2430,7 +2430,7 @@ static TEE_Result tee_svc_cipher_update_helper(unsigned long state,
 	}
 
 	if (last_block && cs->ctx_finalize != NULL) {
-		cs->ctx_finalize(cs->ctx, cs->mode);
+		cs->ctx_finalize(cs->ctx, cs->algo);
 		cs->ctx_finalize = NULL;
 	}
 
@@ -3514,3 +3514,18 @@ out:
 	free(params);
 	return res;
 }
+
+TEE_Result syscall_rcar_aes_unwrap(void *srcData, uint32_t srcLen, void *keyData,
+		uint32_t keySize, uint32_t isSecretKey, void *destData,
+		uint32_t *dstLen)
+{
+	TEE_Result ret;
+
+	if (NULL != (crypto_ops.cipher.unwrap)) {
+		ret = crypto_ops.cipher.unwrap(srcData, srcLen, keyData,
+				keySize, isSecretKey, destData, dstLen);
+	} else {
+		ret = TEE_ERROR_NOT_IMPLEMENTED;
+	}
+	return ret;
+}
diff --git a/core/tee/tee_svc_storage.c b/core/tee/tee_svc_storage.c
index 11046d6..c576235 100644
--- a/core/tee/tee_svc_storage.c
+++ b/core/tee/tee_svc_storage.c
@@ -43,12 +43,14 @@
  * The value TEE_STORAGE_PRIVATE will select the REE FS if available, otherwise
  * RPMB.
  */
-static const struct tee_file_operations *file_ops(uint32_t storage_id)
+const struct tee_file_operations *file_ops(uint32_t storage_id)
 {
 
 	switch (storage_id) {
 	case TEE_STORAGE_PRIVATE:
-#if defined(CFG_REE_FS)
+#if defined(CFG_STANDALONE_FS)
+		return &standalone_fs_ops;
+#elif defined(CFG_REE_FS)
 		return &ree_fs_ops;
 #elif defined(CFG_RPMB_FS)
 		return &rpmb_fs_ops;
@@ -63,6 +65,10 @@ static const struct tee_file_operations *file_ops(uint32_t storage_id)
 	case TEE_STORAGE_PRIVATE_RPMB:
 		return &rpmb_fs_ops;
 #endif
+#ifdef CFG_STANDALONE_FS
+	case TEE_STORAGE_PRIVATE_STANDALONE:
+		return &standalone_fs_ops;
+#endif
 	default:
 		return NULL;
 	}
diff --git a/lib/libutee/arch/arm/utee_syscalls_asm.S b/lib/libutee/arch/arm/utee_syscalls_asm.S
index 7148daa..7e7fe4c 100644
--- a/lib/libutee/arch/arm/utee_syscalls_asm.S
+++ b/lib/libutee/arch/arm/utee_syscalls_asm.S
@@ -187,3 +187,5 @@
                 TEE_SCN_SE_CHANNEL_CLOSE, 1
 
         UTEE_SYSCALL utee_cache_operation, TEE_SCN_CACHE_OPERATION, 3
+
+        UTEE_SYSCALL urcar_aes_unwrap, RCAR_SCN_AES_UNWRAP, 7
diff --git a/lib/libutee/include/tee_api.h b/lib/libutee/include/tee_api.h
index 4a12e60..5465291 100644
--- a/lib/libutee/include/tee_api.h
+++ b/lib/libutee/include/tee_api.h
@@ -462,4 +462,7 @@ void TEE_BigIntComputeFMM(TEE_BigIntFMM *dest, TEE_BigIntFMM *op1,
 			  TEE_BigIntFMM *op2, TEE_BigInt *n,
 			  TEE_BigIntFMMContext *context);
 
+TEE_Result RCAR_AesUnwrap(void *srcData, uint32_t srcLen, void *keyData,
+	uint32_t keySize, uint32_t isSecretKey, void *destData, uint32_t *dstLen);
+
 #endif /* TEE_API_H */
diff --git a/lib/libutee/include/tee_api_defines_extensions.h b/lib/libutee/include/tee_api_defines_extensions.h
index 5c6d1a0..351780a 100644
--- a/lib/libutee/include/tee_api_defines_extensions.h
+++ b/lib/libutee/include/tee_api_defines_extensions.h
@@ -86,5 +86,7 @@
 #define TEE_STORAGE_PRIVATE_REE	 0x80000000
 /* Storage is the Replay Protected Memory Block partition of an eMMC device */
 #define TEE_STORAGE_PRIVATE_RPMB 0x80000100
+/* Storage is provided by the QSPI/Hyper Flash */
+#define TEE_STORAGE_PRIVATE_STANDALONE 0x80001000
 
 #endif /* TEE_API_DEFINES_EXTENSIONS_H */
diff --git a/lib/libutee/include/tee_syscall_numbers.h b/lib/libutee/include/tee_syscall_numbers.h
index 2c1d443..87bc7ac 100644
--- a/lib/libutee/include/tee_syscall_numbers.h
+++ b/lib/libutee/include/tee_syscall_numbers.h
@@ -99,8 +99,9 @@
 #define TEE_SCN_SE_CHANNEL_TRANSMIT		68
 #define TEE_SCN_SE_CHANNEL_CLOSE		69
 #define TEE_SCN_CACHE_OPERATION			70
+#define RCAR_SCN_AES_UNWRAP			71
 
-#define TEE_SCN_MAX				70
+#define TEE_SCN_MAX				71
 
 /* Maximum number of allowed arguments for a syscall */
 #define TEE_SVC_MAX_ARGS			8
diff --git a/lib/libutee/include/utee_syscalls.h b/lib/libutee/include/utee_syscalls.h
index 9a9a4d7..ef86985 100644
--- a/lib/libutee/include/utee_syscalls.h
+++ b/lib/libutee/include/utee_syscalls.h
@@ -293,4 +293,7 @@ TEE_Result utee_se_channel_close(unsigned long c);
 /* op is of type enum utee_cache_operation */
 TEE_Result utee_cache_operation(void *va, size_t l, unsigned long op);
 
+TEE_Result urcar_aes_unwrap(void *srcData, uint32_t srcLen, void *keyData,
+	uint32_t keySize, uint32_t isSecretKey, void *destData, uint32_t *dstLen);
+
 #endif /* UTEE_SYSCALLS_H */
diff --git a/lib/libutee/tee_api.c b/lib/libutee/tee_api.c
index 1084aac..45e3761 100644
--- a/lib/libutee/tee_api.c
+++ b/lib/libutee/tee_api.c
@@ -340,3 +340,10 @@ TEE_Result TEE_CacheInvalidate(char *buf, size_t len)
 {
 	return utee_cache_operation(buf, len, TEE_CACHEINVALIDATE);
 }
+
+TEE_Result RCAR_AesUnwrap(void *srcData, uint32_t srcLen, void *keyData,
+	uint32_t keySize, uint32_t isSecretKey, void *destData, uint32_t *dstLen)
+{
+	return urcar_aes_unwrap(srcData, srcLen, keyData, keySize, isSecretKey,
+			destData, dstLen);
+}
diff --git a/lib/libutee/tee_api_objects.c b/lib/libutee/tee_api_objects.c
index 8765f57..de5b1c7 100644
--- a/lib/libutee/tee_api_objects.c
+++ b/lib/libutee/tee_api_objects.c
@@ -409,11 +409,6 @@ TEE_Result TEE_OpenPersistentObject(uint32_t storageID, void *objectID,
 	TEE_Result res;
 	uint32_t obj;
 
-	if (storageID != TEE_STORAGE_PRIVATE) {
-		res = TEE_ERROR_ITEM_NOT_FOUND;
-		goto out;
-	}
-
 	if (!objectID) {
 		res = TEE_ERROR_ITEM_NOT_FOUND;
 		goto out;
@@ -456,11 +451,6 @@ TEE_Result TEE_CreatePersistentObject(uint32_t storageID, void *objectID,
 	TEE_Result res;
 	uint32_t obj;
 
-	if (storageID != TEE_STORAGE_PRIVATE) {
-		res = TEE_ERROR_ITEM_NOT_FOUND;
-		goto err;
-	}
-
 	if (!objectID) {
 		res = TEE_ERROR_ITEM_NOT_FOUND;
 		goto err;
@@ -621,9 +611,6 @@ TEE_Result TEE_StartPersistentObjectEnumerator(TEE_ObjectEnumHandle
 {
 	TEE_Result res;
 
-	if (storageID != TEE_STORAGE_PRIVATE)
-		return TEE_ERROR_ITEM_NOT_FOUND;
-
 	res = utee_storage_start_enum((unsigned long)objectEnumerator,
 				      storageID);
 
diff --git a/mk/config.mk b/mk/config.mk
index 5bbf8dc..47b935b 100644
--- a/mk/config.mk
+++ b/mk/config.mk
@@ -133,7 +133,7 @@ CFG_RPMB_FS_DEV_ID ?= 0
 # Applies to both the REE and the RPMB filesystems
 CFG_ENC_FS ?= y
 
-ifeq (,$(filter y,$(CFG_REE_FS) $(CFG_RPMB_FS)))
+ifeq (,$(filter y,$(CFG_REE_FS) $(CFG_RPMB_FS) $(CFG_STANDALONE_FS)))
 $(error At least one filesystem must be enabled)
 endif
 
-- 
1.9.1

